#+title: Personal DWM Configuration with Polybar
#+author: Sravan Balaji
#+auto_tangle: t
#+startup: showeverything

* Welcome

My personal configuration of dwm, written as an [[https://orgmode.org][Org Mode]] document.

Run the block below with ~C-c C-c~ to tangle code blocks to config file.

#+begin_src emacs-lisp :tangle no
  (org-mode-restart)
  (org-babel-tangle)
#+end_src

After making changes, run the following in a terminal to recompile.

#+begin_src bash :tangle no
  sudo make clean install
#+end_src

* dwm - dynamic window manager

dwm is an extremely fast, small, and dynamic window manager for X.

** Requirements

In order to build dwm you need the Xlib header files.

** Installation

Edit config.mk to match your local setup (dwm is installed into the /usr/local namespace by default).

Afterwards enter the following command to build and install dwm (if necessary as root):

#+begin_src bash :tangle no
  make clean install
#+end_src

** Running dwm

Add the following line to your .xinitrc to start dwm using startx:

#+begin_src bash :tangle no
    exec dwm
#+end_src

In order to connect dwm to a specific display, make sure that the DISPLAY environment variable is set correctly, e.g.:

#+begin_src bash :tangle no
    DISPLAY=foo.bar:1 exec dwm
#+end_src


(This will start dwm on display :1 of the host foo.bar.)

In order to display status info in the bar, you can do something like this in your .xinitrc:

#+begin_src bash :tangle no
  while xsetroot -name "`date` `uptime | sed 's/.*,//'`"
  do
      sleep 1
  done &
  exec dwm
#+end_src

* dwm flexipatch

This dwm 6.2 (67d76bd, 2021-03-29) side project has a different take on dwm patching. It uses preprocessor directives to decide whether or not to include a patch during build time. Essentially this means that this build, for better or worse, contains both the patched *and* the original code. The aim being that you can select which patches to include and the build will contain that code and nothing more. Due to the complexity of some of the patches dwm-flexipatch has diverged from mainstream dwm by making some core patches non-optional for maintenance reasons. For the classic dwm-flexipatch build refer to branch [[https://github.com/bakkeby/dwm-flexipatch/tree/dwm-flexipatch-1.0][dwm-flexipatch-1.0]].

For example to include the ~alpha~ patch then you would only need to flip this setting from 0 to 1 in [[https://github.com/bakkeby/dwm-flexipatch/blob/master/patches.def.h][patches.h]]:

#+begin_src c :tangle no
#define BAR_ALPHA_PATCH 1
#+end_src

So if you have ever been curious about trying out dwm, but have been discouraged by manual patching, then this may be a good starting point to see what a "fully fledged" dwm can look like. Want to try out the ~pertag~ patch? Just flip a config and recompile. Once you have found out what works for you and what doesn't then you should be in a better position to choose patches should you want to start patching from scratch.

Alternatively if you have found the patches you want, but don't want the rest of the flexipatch entanglement on your plate then you may want to have a look at [[https://github.com/bakkeby/flexipatch-finalizer][flexipatch-finalizer]]; a custom pre-processor tool that removes all the unused flexipatch code leaving you with a build that contains the patches you selected.

Refer to [[https://dwm.suckless.org/][https://dwm.suckless.org/]] for details on the dwm window manager, how to install it and how it works.

If you are experiencing issues then you may want to check out the [[https://github.com/bakkeby/dwm-flexipatch/discussions/categories/known-issues][Known Issues]] discussion category.

** Changelog

2021-09-08 - Added the alwayscenter patch

2021-07-27 - Added the winicon patch

2021-05-30 - Added togglelayout and toggletag patches

2021-04-16 - Vanitygaps: replaced smartgaps with smartgaps\_fact, allowing gaps to be disabled or increased when there is only one client.

2021-04-14 - Upgraded the dwmblocks patch for statuscmd which changes the signalling mechanism from SIGUSR1 to SIGRTMIN which is likely to cause issues for those that already have a working setup. A compatibility option has been added which changes this back to SIGUSR1. Note that configuration was also changed.

2021-04-07 - Added xkb patch

2021-04-06 - Added the distributetags patch

2021-04-04 - Added option for having different gaps on a per tag basis

2021-03-31 - Added tapresize patch (contributed by [[https://github.com/verschmelzen][verschmelzen]]

2021-03-29 - Removed alwaysfullscreen patch (merged into dwm 6.2)

2021-03-09 - Added the tab patch and the LG3D patch

2021-02-11 - Added the riodraw and focusdir patches

2021-01-22 - Added the placemouse patch

2021-01-02 - Added the Layoutmenu patch

2020-10-26 - Added the \_NET\_CLIENT\_LIST\_STACKING patch

2020-09-29 - Added the on\_empty\_keys patch (ported from InstantOS)

2020-09-28 - Added the \_IS\_FLOATING patch (embedded in the EWMHTAGS patch)

2020-09-18 - Added the nomodbuttons patch allowing for toggleable mouse button bindings that have no modifiers

2020-09-10 - Added the anybar patch (with experimental support for dwm bar(s) + anybar)

2020-09-09 - Added the bar border patch

2020-09-08 - Added ipc v1.5.5 patch

2020-09-07 - Scratchpads improvement (multi-monitor support)

2020-09-05 - Assortment of fullscreen improvements

2020-08-27 - Added aspectresize patch

2020-08-25 - Unified tag icon handling while adding support for different icons per monitor. Added alttagsdecoration patch.

2020-08-22 - Added logic to auto-hide bars if nothing is drawn on them (e.g. for standalone bars that only show certain clients). Added clientindicators patch and unified indicator code. Simplified Pango integration by settling on common function signatures.

2020-08-21 - Simplification of color configuration; settling on a set of color schemes that is shared between multiple patches (urgentborder, floatborder and titlecolor patches made non-optional)

2020-08-20 - Added experimental flexwintitle patch based on bartabgroups

2020-08-13 - Added bartabgroups patch

2020-08-11 - Added decoration hints and focusmaster patches

2020-08-10 - Added cool autostart, insets and steam patches

2020-08-02 - Added reorganizetags patch

2020-07-19 - Added barmodules patch - making extrabar, leftlayout, staticstatus and statusallmons patches redundant, added powerline patch

2020-07-18 - **Note**: Up until now building dwm-flexipath without any patches selected would have given you something more or less identical with mainstream dwm. In order to reduce complexity when it comes to maintainance future versions of dwm-flexipatch may diverge from this by making some patches non-optional. For the classic dwm-flexipatch and its many patch integration hints refer to branch [[https://github.com/bakkeby/dwm-flexipatch/tree/dwm-flexipatch-1.0][dwm-flexipatch-1.0]] which will be subject to bug fixes and mainstream dwm updates as far as feasible.

2020-07-05 - Extrabar compatibility improvements (staticstatus, status2d, dwmblocks) and fix for systray randomly causing dwm to crash when first systray application starts

2020-06-24 - Added resizepoint, statusbutton and sendmon_keepfocus patches

2020-06-21 - Added floatpos and bar_height patches

2020-06-19 - Added tagothermonitor patch

2020-06-15 - Added sizehints patch

2020-06-14 - Added RULE macro to replace rules setup making the default config less of an abomination and making it simpler to include new rules based patches

2020-06-11 - Added the pango patch

2020-06-10 - Added the staticstatus patch

2020-05-31 - Added the keymodes patch

2020-05-29 - Added the color emoji patch

2020-05-26 - Added the status2d patch (with alpha, systray, statuspadding and dwmblocks compatibility, no statuscolors or extrabar compatibility)

2020-05-21 - Added the moveplace and moveresize patches

2020-05-03 - Added the shiftviewclients patch and the no transparent borders patch which removes opacity from window borders when the alpha patch is not used

2020-05-02 - Added dwmblocks patch

2020-04-27 - Upgraded the tagmonfixfs patch to better support moving fullscreen windows to adjacent monitors

2020-04-26 - Expanded monitor rules patch to include nmaster, showbar and topbar options

2020-04-23 - Improved swallow and switchtag compatibility

2020-04-16 - Upgraded the scratchpad patch to the multiple scratchpads patch \[[[https://lists.suckless.org/hackers/2004/17205.html][ref]]\]. Updated the statuscolors patch with the width computation fix \[[[https://lists.suckless.org/hackers/2004/17207.html][ref]]\].

2020-04-13 - Added statuscmd patch

2020-03-31 - Added the rounded corners patch

2020-03-27 - Revamped the dragmfact patch to support both horizontal and vertical layout splits as well as centered master variants

2020-03-25 - Added dragcfact patch

2020-03-23 - Added stacker patch

2020-03-21 - Reworked a series of layouts to re-allocate remaining pixels following an even (or cfacts) split with the aim of presenting a pixel perfect layout. This affects the following layouts: tile, bstack, bstackhoriz, centered master, centered floating master, columns, deck, and corresponding flextile-deluxe layouts

2020-02-11 - Added swaptags and vtcolor patches

2020-02-09 - Added alternative scratchpad patch

2020-02-02 - Added fsignal and transferall patches

2020-01-29 - Added swapfocus and shiftview patches

2020-01-26 - Added transfer patch

2020-01-24 - Added barpadding patch (incl. statusallmons, statuspadding, statuscolors, systray, alpha, holdbar and extrabar patch compatibility). Moved patches.h to patches.def.h to mimic the config pattern of having default and personal settings.

2020-01-17 - Added inplacerotate patch

2019-12-15 - Updated dragmfact patch to include fix patch to make it work with multiple monitors

2019-11-26 - Added dmenumatchtop patch, added improvements to the switchtag patch based on ideas from the switchtotag patch

2019-11-21 - Added fakefullscreenclient patch

2019-10-24 - Added dragmfact, extrabar, exresize and nodmenu patches

2019-10-22 - Added ispermanent and swallow patches

2019-10-16 - Introduced [[https://github.com/bakkeby/flexipatch-finalizer][flexipatch-finalizer]]

2019-10-11 - Added the patch to ignore Xft errors when drawing text in the status bar

2019-10-10 - Added mpdcontrol, scratchpad and spawn_cwd cpatches

2019-10-08 - Added columns layout and fakefullscreen patch

2019-10-07 - Added sortscreens and dwmc patches, fixed minor cross-compatibility issues for combo, holdbar, leftlayout, hidevacanttags, taggrid and activetagindicatorbar

2019-10-06 - Added statuscolors and statusallmons patches, fixed minor cross-compatibility issues for killunsel, fullscreen, noborder, tagintostack patches

2019-10-05 - Added killunsel, taggrid, hidevacanttags and cmdcustomize patches

2019-10-04 - Added maximize, movestack, monoclesymbol, noborder, tagall and tagintostack  patches

2019-10-03 - Added onlyquitonempty and switchcol patches

2019-10-02 - Added restartsig, emptyview, focusurgent and focusadjacenttag patches

2019-10-01 - Added leftlayout, fullscreen, holdbar and unfloatvisible patches

2019-09-30 - Replaced flextile with flextile-deluxe, refactored monitor rules to support predetermined layouts per tag

2019-09-15 - Added focusonclick, xrdb, viewontag, urgentborder and winview patches

2019-09-14 - Added setborderpx, selfrestart and push (no master variant), sticky and warp patches

2019-09-13 - Added titlecolor and push patches

2019-09-12 - Added activetagindicatorbar, alwaysfullscreen and autoresize patches

2019-09-11 - Added monitor rules, combo and ewmhtags patches

2019-09-10 - Minor tweaks to awesomebar patch (incl. alpha and systray compatibility). Added floatbordercolor patch.

2019-09-09 - Added deck, fibonacci (dwindle and spiral), gridmode, gapplessgrid, horizgrid, nrowgrid, centeredmaster and flextile layouts. Added alternativetags and awesomebar patches.

2019-09-08 - Added cfacts and vanitygaps patches, added bstack and bstackhoriz layouts

2019-09-07 - Added cyclelayouts, resizecorners, rotatestack, savefloats, statuspadding, switchtag, center and windowrolerule patches

2019-09-06 - Added attachabove, attachaside, attachbelow, attachbottom, autostart, fancybar, focusonnetactive and losefullscreen patches

2019-09-05 - Alpha, systray, togglefullscreen, tagallmon, tagmonfixfs, tagswapmon, pertag and zoomswap patches added

** Patches Included

   - [[https://dwm.suckless.org/patches/activetagindicatorbar/][activetagindicatorbar]]
      - this patch changes the rectangle indicating if a tag is used by a client into a bar above
        the tag name

   - [[https://dwm.suckless.org/patches/alpha/][alpha]]
      - adds transparency for the status bar

   - [[https://dwm.suckless.org/patches/alternativetags/][alternativetags]]
      - adds alternative tags which can be toggled on the fly for the sole purpose of providing
        visual aid

   - [[https://dwm.suckless.org/patches/alttagsdecoration/][alttagsdecoration]]
      - provides the ability to use alternative text for tags which contain at least one window

   - [[https://dwm.suckless.org/patches/alwayscenter/][alwayscenter]]
      - makes all floating windows centered, like the center patch, but without a rule

   - +[[https://dwm.suckless.org/patches/alwaysfullscreen/][alwaysfullscreen]]+
      - +prevents the focus to drift from the active fullscreen client when using focusstack\(\)+

   - [[https://dwm.suckless.org/patches/anybar/][anybar]]
      - enables dwm to manage external status bars such as lemonbar and polybar
      - dwm treats the external bar as it would its own, so all regular dwm commands such as
        togglebar affect the external bar in the same way

   - [[https://dwm.suckless.org/patches/aspectresize/][aspectresize]]
      - allows windows to be resized with its aspect ratio remaining constant

   - [[https://dwm.suckless.org/patches/attachabove/][attachabove]]
      - new windows are placed above selected client

   - [[https://dwm.suckless.org/patches/attachaside/][attachaside]]
      - new windows are placed on top of the stack

   - [[https://dwm.suckless.org/patches/attachbelow/][attachbelow]]
      - new windows are placed below selected client

   - [[https://dwm.suckless.org/patches/attachbottom/][attachbottom]]
      - new windows are placed at the bottom of the stack

   - [[https://dwm.suckless.org/patches/autoresize/][autoresize]]
      - by default, windows that are not visible when requesting a resize/move will not get
        resized/moved, with this patch, however, they will

   - [[https://dwm.suckless.org/patches/autostart/][autostart]]
      - makes dwm run =~/.dwm/autostart_blocking.sh= and =~/.dwm/autostart.sh &= on startup

   - [[https://dwm.suckless.org/patches/awesomebar/][awesomebar]]
      - enhanced taskbar that allows focus / hiding / unhiding of windows by clicking on the status
        bar

   - [[https://codemadness.org/paste/dwm-border-bar.patch][bar_border]]
      - adds a border around the bar similarly to how client windows have borders

   - [[https://dwm.suckless.org/patches/bar_height/][bar_height]]
      - allows the bar height to be explicitly set rather than being derived from font

   - [[https://github.com/bakkeby/patches/wiki/barmodules/][barmodules]]
      - splits the dwm bar into modules allowing for re-arrangement of the bar and easier
        integration for new features

   - [[https://dwm.suckless.org/patches/barpadding/][barpadding]]
      - adds vertical and horizontal space between the statusbar and the edge of the screen

   - [[https://dwm.suckless.org/patches/bartabgroups/][bartabgroups]]
      - turns the titlebar area into a mfact-respecting tab-bar showing each client's title

   - [[https://dwm.suckless.org/patches/center/][center]]
      - adds an iscentered rule to automatically center clients on the current monitor

   - [[https://dwm.suckless.org/patches/cfacts/][cfacts]]
      - the cfacts patch provides the ability to assign different weights to clients in their
        respective stack in tiled layout

   - [[https://dwm.suckless.org/patches/clientindicators/][clientindicators]]
      - draws a dot indicator overlayed on each tag icon for each client
      - the selected client is drawn as a larger horizontal line

   - [[https://dwm.suckless.org/patches/cmdcustomize/][cmdcustomize]]
      - allows color attributes to be set through the command line

   - [[https://dwm.suckless.org/patches/colorbar/][colorbar]]
      - lets you change the foreground and background color of every statusbar element

   - color_emoji
      - enables color emoji in dmenu by removing a workaround for a BadLength error in the Xft
        library when color glyphs are used
      - enabling this will crash dwm on encountering such glyphs unless you also have an updated
        Xft library that can handle them

   - [[https://dwm.suckless.org/patches/combo/][combo]]
      - allows you to select multiple tags by pressing all the right keys as a combo, e.g. hold MOD
        and press and hold 1 and 3 together to view those two tags

   - [[https://dwm.suckless.org/patches/cool_autostart/][cool_autostart]]
      - allows dwm to execute commands from an array in the config.h file
      - when dwm exits all processes from the autostart array will be killed automatically

   - [[https://dwm.suckless.org/patches/cyclelayouts/][cyclelayouts]]
      - lets you cycle through all your layouts

   - [[https://dwm.suckless.org/patches/decoration_hints/][decoration_hints]]
      - make dwm respect =_MOTIF_WM_HINTS= property, and not draw borders around windows
       requesting for it
      - some applications use this property to notify window managers to not draw window
        decorations
      - not respecting this property leads to issues with applications that draw their own borders,
        like chromium (with "Use system title bar and borders" turned off) or vlc in fullscreen mode

   - [[https://dwm.suckless.org/patches/reorganizetags/][distributetags]]
      - this reorganisetags variant re-distributes all clients on the current monitor evenly across
        all tags

   - [[https://dwm.suckless.org/patches/dmenumatchtop][dmenumatchtop]]
      - updates the position of dmenu to match that of the bar
      - i.e. if topbar is 0 then dmenu will appear at the bottom and if 1 then dmenu will appear at
        the top

   - [[https://github.com/bakkeby/patches/wiki/dragcfact/][dragcfact]]
      - lets you resize clients' size (i.e. modify cfact) by holding modkey + shift + right-click
        and dragging the mouse

   - [[https://github.com/bakkeby/patches/wiki/dragmfact/][dragmfact]]
      - lets you resize the split in layouts (i.e. modify mfact) by holding the modkey + shift
        + left-click and dragging the mouse
      - this is a bespoke patch that supports vertical and horizontal layout splits as well as
        centered master variants

   - [[https://gist.github.com/danbyl/54f7c1d57fc6507242a95b71c3d8fdea][dwmblocks]]
      - signal integration to use dwm with a patched [[https://github.com/torrinfail/dwmblocks][dwmblocks]]
      - combined with the statuscmd patch this gives a clickable statusbar

   - [[http://dwm.suckless.org/patches/dwmc/][dwmc]]
      - a simple dwmc client using a fork of fsignal to communicate with dwm

   - [[https://dwm.suckless.org/patches/emptyview/][emptyview]]
      - allows no tag at all to be selected
      - dwm will start with no tag selected and when a client with no tag rule is started and no
        tag is selected then it will be opened on the first tag

   - [[https://dwm.suckless.org/patches/ewmhtags/][ewmhtags]]
      - adds EWMH support for =_NET_NUMBER_OF_DESKTOPS=, =_NET_CURRENT_DESKTOP=, =_NET_DESKTOP_NAMES=
        and =_NET_DESKTOP_VIEWPORT=, which allows for compatibility with other bars and programs
        that request workspace information, e.g. polybar's xworkspaces module

   - [[https://dwm.suckless.org/patches/exresize/][exresize]]
      - this patch allows the user to change size and placement of floating windows using only the
        keyboard
      - it also allows for temporary vertical and horizontal extension of windows similar to other
        WMs fill command

   - +[[https://dwm.suckless.org/patches/extrabar/][extrabar]]+
      - +enables an extra status bar in dwm in a similar manner to the dualstatus patch+
      - +if the primary status is at the top via topbar then the extra status bar will be placed at
        the bottom and vice versa+

   - extrastatus
      - formerly extrabar - now only splits the status into to statuses by using a status separator

   - [[https://dwm.suckless.org/patches/fakefullscreen/][fakefullscreen]]
      - only allow clients to "fullscreen" into the space currently given to them
      - as an example, this will allow you to view a fullscreen video in your browser on one half
        of the screen, while having the other half available for other tasks

   - [[https://github.com/bakkeby/patches/wiki/fakefullscreenclient/][fakefullscreenclient]]
      - similarly to the fakefullscreen patch this patch only allows clients to "fullscreen" into
        the space currently given to them
      - as an example, this will allow you to view a fullscreen video in your browser on one half
        of the screen, while having the other half available for other tasks
      - the "twist" with this patch is that fake fullscreen can be toggled on a per client basis
        rather than applying to all clients globally

   - [[https://dwm.suckless.org/patches/fancybar/][fancybar]]
      - shows the titles of all visible windows in the status bar

   - flexwintitle
      - based on the bartabgroups patch, this is a layout aware barmodules module for handling
        window titles intended to be used with flextile-deluxe

   - +[[https://dwm.suckless.org/patches/float_border_color/][floatbordercolor]]+
      - +this patch allows a different border color to be chosen for floating windows+

   - [[https://github.com/bakkeby/patches/wiki/floatpos/][floatpos]]
      - adds a float rule allowing the size and position of floating windows to be specified
      - control the size and position of floating windows similar to exresize, moveresize,
        moveplace patches
      - specify size and position using absolute, relative or fixed co-ordinates or
      - position floating windows in a grid-like manner

   - [[https://dwm.suckless.org/patches/focusadjacenttag/][focusadjacenttag]]
      - provides the ability to focus the tag on the immediate left or right of the currently
        focused tag
      - it also allows to send the focused window either on the left or the right tag

   - [[https://github.com/bakkeby/patches/wiki/focusdir][focusdir]]
      - allows focusing on clients based on direction (up, down, left, right) instead of client
        order

   - [[https://dwm.suckless.org/patches/focusmaster/][focusmaster]]
      - a simple patch that just puts focus back to the master client

   - [[https://dwm.suckless.org/patches/focusonclick/][focusonclick]]
      - this patch makes you switch focus only by mouse click and not sloppy (focus follows mouse
        pointer)

   - [[https://dwm.suckless.org/patches/focusonnetactive/][focusonnetactive]]
      - by default, dwm responds to =_NET_ACTIVE_WINDOW= client messages by setting the urgency bit
        on the named window
      - this patch activates the window instead

   - [[https://dwm.suckless.org/patches/focusurgent/][focusurgent]]
      - adds a keyboard shortcut to select the next window having the urgent flag regardless of the
        tag it is on

   - [[https://dwm.suckless.org/patches/fsignal/][fsignal]]
      - send "fake signals" to dwm for handling, using xsetroot
      - this will not conflict with the status bar, which also is managed using xsetroot

   - [[https://dwm.suckless.org/patches/fullscreen/][fullscreen]]
      - applies the monocle layout with the focused client on top and hides the bar
      - when pressed again it shows the bar and restores the layout that was active before going
        fullscreen

   - [[https://dwm.suckless.org/patches/hide_vacant_tags/][hidevacanttags]]
      - prevents dwm from drawing tags with no clients (i.e. vacant) on the bar

   - [[http://dwm.suckless.org/patches/holdbar/][holdbar]]
      - with this patch dwm's built-in status bar is only shown when HOLDKEY is pressed
      - additionally the bar will now overlay the display

   - [[https://groups.google.com/forum/m/#!topic/wmii/7bncCahYIww][ignore-xft-errors-when-drawing-text]]
      - sometimes dwm crashes when it cannot render some glyphs in window titles (usually emoji)
      - this patch is essentially a hack to ignore any errors when drawing text on the status bar
        and may be removed if a more appropriate solution comes up

   - [[https://dwm.suckless.org/patches/inplacerotate/][inplacerotate]]
      - allows rotation of all clients in the master or stack area without affecting the other area

   - [[https://dwm.suckless.org/patches/insets/][insets]]
      - lets custom insets from each edge of the screen to be defined
      - an example use case would be to make space for an external bar

   - [[https://github.com/mihirlad55/dwm-ipc][ipc]]
      - implements inter-process communication through a UNIX socket for dwm
      - allows for the window manager to be queried for information, e.g. listen for events such as
        tag or layout changes, as well as send commands to control the window manager via other
        programs

   - [[https://github.com/bakkeby/dwm-flexipatch/issues/50][_IS_FLOATING]]
      - adds the =_IS_FLOATING= xproperty for floating windows
      - this can allow for a compositor to handle floating windows differently to tiled windows,
        e.g. only show shadows on floating windows
      - this patch is enabled via the ewmhtags patch

   - [[https://dwm.suckless.org/patches/ispermanent/][ispermanent]]
      - adds rule option for clients to avoid accidental termination by killclient for sticky
        windows

   - [[https://dwm.suckless.org/patches/keymodes/][keymodes]]
      - this patch adds key modes (like in vim or emacs) where chains of keyboard shortcuts can be
        performed

   - +[[http://dwm.suckless.org/patches/leftlayout/][leftlayout]]+
      - +moves the layout symbol in the status bar to the left hand side+

   - LG3D
      - changes the window manager name to "LG3d" instead of "dwm" as a workaround for Java
        applications that assume that the window manager is using window reparenting
      - refer to the ISSUES secton of the dwm man page for more details

   - [[https://github.com/bakkeby/patches/wiki/losefullscreen/][losefullscreen]]
      - by default in dwm it is possible to make an application fullscreen, then use the focusstack
        keybindings to focus on other windows beneath the current window
      - it is also possible to spawn new windows (e.g. a terminal) that end up getting focus while
        the previous window remains in fullscreen
      - this patch ensures that in such scenarios the previous window loses fullscreen

   - [[https://dwm.suckless.org/patches/maximize/][maximize]]
      - adds helper functions for maximizing, horizontally and vertically, floating windows using
        keybindings

   - [[https://dwm.suckless.org/patches/mpdcontrol/][mpdcontrol]]
      - adds keyboard bindings to control MDP (Music Player Daemon)

   - [[https://github.com/bakkeby/patches/wiki/monitorrules/][monitorrules]]
      - adds rules per monitor, e.g. have default layouts per monitor
      - the use case for this is if the second monitor is vertical (i.e. rotated) then you may want
        to use a different default layout for this monitor than what is used for the main monitor
        (for example normal vertical split for main monitor and horizontal split for the second)

   - [[https://dwm.suckless.org/patches/monoclesymbol/][monoclesymbol]]
      - always display the the monocle-symbol as defined in config.h if the monocle-layout is
        activated
      - do not display the number of open clients in the current tag

   - [[https://dwm.suckless.org/patches/moveresize/][moveresize]]
      - allows you to move and resize dwm's clients using keyboard bindings

   - [[https://dwm.suckless.org/patches/movestack/][movestack]]
      - allows you to move clients around in the stack and swap them with the master

   - [[https://github.com/bakkeby/patches/wiki/netclientliststacking][netclientliststacking]]
      - adds support for the =_NET_CLIENT_LIST_STACKING= atom, needed by certain applications
        like the Zoom video conferencing application

   - [[https://dwm.suckless.org/patches/noborder/][noborder]]
      - removes the border when there is only one window visible

   - [[https://git.suckless.org/sites/commit/ed68e3629de4ef2ca2d3f8893a79fb570b4c0cbc.html][nodmenu]]
      - enable modifying dmenu in config.def.h which resulted previously in a compilation error
        because two lines of code hardcode dmenu into dwm
      - allows complete removal of dmenu, should you want to do that
      - NB: this patch was removed from the patches listing on the suckless page due to it's simplicity

   - nomodbuttons
      - allows for toggleable client button bindings that have no modifiers
      - this can, for example, allow you to move or resize using the mouse alone without holding
        down a modifier key, which can be practical if you have extra buttons on your mouse

   - [[https://github.com/szatanjl/dwm/commit/1529909466206016f2101457bbf37c67195714c8][no_transparent_borders]]
      - when terminals have transparency then their borders also become transparent
      - this patch ensures that borders have no transparency
      - note that this patch is only relevant if you are not using the alpha patch

   - [[https://github.com/bakkeby/dwm-flexipatch/issues/51][on_empty_keys]]
      - port of InstantWM's on_empty_keys functionality allowing keybindings that apply only when a
        tag/view is empty
      - an example use case is being able to launch applications with first hand keys like "f" to
        launch firefox

   - [[https://dwm.suckless.org/patches/onlyquitonempty/][onlyquitonempty]]
      - makes it so dwm will only exit via quit() if no windows are open (in order to prevent
        accidental loss of work)

   - [[https://dwm.suckless.org/patches/pango/][pango]]
      - adds simple markup for status messages using pango markup

   - [[https://dwm.suckless.org/patches/pertag/][pertag]]
      - adds nmaster, mfact, layouts and more per tag rather than per monitor

   - [[https://github.com/bakkeby/patches/wiki/placemouse][placemouse]]
      - lets the user change the position of a client in the stack using the mouse.

   - [[https://gitlab.com/udiboy1209-suckless/dwm/-/commit/071f5063e8ac4280666828179f92788d893eea40#4b1a539194be7467cefbda22f675a3b7c19ceca7][powerline]]
      - adds drawing of powerline arrows (and diagonal lines) for both the status bar and the tags

   - [[https://dwm.suckless.org/patches/push/][push]]
      - this patch provides a way to move clients up and down inside the client list

   - [[https://dwm.suckless.org/patches/reorganizetags/][reorganizetags]]
      - shifts all clients per tag to leftmost unoccupied tags
      - e.g. if clients A, B, C are tagged on tags 1, 5, 9 respectively, when reorganized they will
        now be on tag 1, 2, and 3

   - [[https://dwm.suckless.org/patches/resizecorners/][resizecorners]]
      - by default, windows only resize from the bottom right corner
      - with this patch the mouse is warped to the nearest corner and you resize from there

   - [[https://github.com/bakkeby/patches/wiki/resizepoint/][resizepoint]]
      - practically the same as resizecorners, but the cursor does not warp to any of the window
        corners

   - [[https://dwm.suckless.org/patches/restartsig/][restartsig]]
      - adds a keyboard shortcut to restart dwm or alternatively by using kill -HUP dwmpid
      - additionally dwm can quit cleanly by using kill -TERM dwmpid

   - [[https://github.com/bakkeby/patches/wiki/riodraw/][riodraw]]
      - adds rio-like drawing to spawn new windows or to resize the selected client (ported from
        instantWM)
      - depends on an external tool slop being installed

   - [[https://dwm.suckless.org/patches/rotatestack/][rotatestack]]
      - let's you rotate through the stack using keyboard shortcuts

   - [[https://github.com/mitchweaver/suckless/blob/master/dwm/patches/mitch-06-rounded_corners-f04cac6d6e39cd9e3fc4fae526e3d1e8df5e34b2.patch][roundedcorners]]
      - adds rounded corners to client windows

   - [[https://dwm.suckless.org/patches/save_floats/][savefloats]]
      - saves size and position of every floating window before it is forced into tiled mode
      - if the window is made floating again then the old dimensions will be restored

   - [[https://dwm.suckless.org/patches/scratchpad/][scratchpad]]
      - the scratchpad patch allows you to spawn or restore a floating terminal window

   - [[https://github.com/GasparVardanyan/dwm-scratchpad][scratchpad_alt_1]]
      - this alternative patch enables a scratchpad feature in dwm similar to the scratchpad
        feature in i3wm

   - [[https://dwm.suckless.org/patches/selfrestart/][selfrestart]]
      - restart dwm without the unnecessary dependency of an external script

   - [[https://github.com/bakkeby/patches/wiki/sendmon_keepfocus/][sendmon_keepfocus]]
      - minor patch that allow clients to keep focus when being sent to another monitor

   - [[https://dwm.suckless.org/patches/setborderpx/][setborderpx]]
      - this patch allows border pixels to be changed during runtime

   - [[https://github.com/chau-bao-long/dotfiles/blob/master/suckless/dwm/shiftview.diff][shiftview]]
      - adds keybindings for left and right circular shift through tags
      - also see focusadjacenttag

   - [[https://github.com/bakkeby/patches/wiki/shiftviewclients/][shiftviewclients]]
      - variant of the shiftview patch which skips tags that have no clients

   - [[https://dwm.suckless.org/patches/sizehints/][sizehints]]
      - makes dwm obey even "soft" sizehints for new clients

   - [[https://www.mail-archive.com/hackers@suckless.org/msg09400.html][sortscreens]]
      - this patch aims to address some inconsistencies when it comes to focusmon, tagmon and
        similar functionality by explicitly sorting screens left to right (or top to bottom in a
        vertical layout)

   - [[https://dwm.suckless.org/patches/spawn_cwd/][spawn_cwd]]
      - spawns programs from currently focused client's working directory

   - [[https://dwm.suckless.org/patches/stacker/][stacker]]
      - provides comprehensive utilities for managing the client stack

   - +[[https://dwm.suckless.org/patches/staticstatus/][staticstatus]]+
      - +allows the status text to be fixed to the bar on a specific monitor rather than being drawn on the focused monitor+

   - [[https://dwm.suckless.org/patches/status2d/][status2d]]
      - allows colors and rectangle drawing in the dwm status bar

   - +[[https://dwm.suckless.org/patches/statuspadding/][statusallmons]]+
      - +this patch draws and updates the statusbar on all monitors+

   - [[https://dwm.suckless.org/patches/statusbutton/][statusbutton]]
      - adds a clickable button to the left hand side of the statusbar

   - [[https://dwm.suckless.org/patches/statuscmd/][statuscmd]]
      - adds the ability to execute shell commands based on the mouse button and position when
        clicking the status bar

   - [[https://dwm.suckless.org/patches/statuscolors/][statuscolors]]
      - enables colored text in the status bar allowing multiple color combinations for use in the
        status script

   - [[https://dwm.suckless.org/patches/statuspadding/][statuspadding]]
      - adds configuration options for horizontal and vertical padding in the status bar

   - [[https://github.com/bakkeby/patches/wiki/steam][steam]]
      - a minor patch that works around the issue of floating Steam windows jumping around the
        screen when they receive focus

   - [[https://dwm.suckless.org/patches/sticky/][sticky]]
      - adds toggleable keyboard shortcut to make a client 'sticky', i.e. visible on all tags

   - [[https://dwm.suckless.org/patches/swallow/][swallow]]
      - this patch adds "window swallowing" to dwm as known from Plan 9's windowing system rio
      - clients marked with isterminal in config.h swallow a window opened by any child process,
        e.g. running xclock in a terminal
      - closing the xclock window restores the terminal window in the current position

   - [[https://dwm.suckless.org/patches/swapfocus/][swapfocus]]
      - this patch depends on the pertag patch and makes it possible to switch focus with a single
        shortcut (mod-s) instead of having to think if you should use mod-j or mod-k for reaching
        the previously used window

   - [[https://dwm.suckless.org/patches/swaptags/][swaptags]]
      - allows swapping the contents of the currently selected tag with another tag by using
        keyboard shortcuts

   - [[https://dwm.suckless.org/patches/switchcol/][switchcol]]
      - allows you to switch focus between the master and stack columns using a single keybinding

   - [[https://github.com/bakkeby/patches/wiki/switchtag/][switchtag]]
      - when an application opens on a specific tab this patch adds the option to also switch to
        that tag when the application starts
      - optionally, the previous view can also be restored when the client is closed

   - [[https://dwm.suckless.org/patches/systray/][systray]]
      - adds system tray in the status bar

   - [[https://dwm.suckless.org/patches/tab/][tab]]
      - transforms the monocle layout into a "tabbed" layout if more than one window is present on
        the monocle view
      - this is essentially just a specific bar
      - the patch has been added for demonstration purposes only and has limited compatibility with
        other patches
      - it will conflict space-wise with a second bar
      - note that fancybar, awesomebar, bartabgroups and similar patches make the tab patch
        redundant

   - [[https://dwm.suckless.org/patches/tagall/][tagall]]
      - adds keyboard shortcuts to move all (or only floating) windows from one tag to another

   - [[https://github.com/bakkeby/patches/wiki/tagallmon/][tagallmon]]
      - move all visible windows to an adjacent monitor

   - [[https://dwm.suckless.org/patches/tagintostack/][tagintostack]]
      - makes new clients attach into the stack area when you toggle a new tag into view
      - this means your master area will remain unchanged when toggling views

   - [[https://dwm.suckless.org/patches/taggrid/][taggrid]]
      - adds an option to place tags in rows like in many other window managers

   - [[https://github.com/bakkeby/patches/wiki/tagmonfixfs/][tagmonfixfs]]
      - allows moving a fullscreen window to another monitor while remaining in fullscreen

   - [[https://dwm.suckless.org/patches/tagothermonitor/][tagothermonitor]]
      - adds functions and keybindings to tag a window to a desired tag on an adjacent monitor

   - [[https://github.com/bakkeby/patches/wiki/tagswapmon/][tagswapmon]]
      - swap all visible windows on one monitor with those of an adjacent monitor

   - [[https://dwm.suckless.org/patches/tapresize/][tapresize]]
      - allows resizing of windows using a touchpad
      - uses vertical and horizontal scroll events allowing you to use one-finger tap for moving
        windows and two-finger tap for resizing

   - +[[https://dwm.suckless.org/patches/titlecolor/][titlecolor]]+
      - +adds a new color scheme used by the (selected) window title in the bar+

   - [[https://github.com/bakkeby/patches/wiki/togglefullscreen/][togglefullscreen]]
      - allows you to toggle fullscreen on and off using a single shortcut key

   - [[https://github.com/bakkeby/patches/wiki/toggletag][toggletag]]
      - toggle tags using the same keyboard shortcuts to view tags
      - e.g. hitting ~MOD+4~ lets you view tag 4 and hitting the keybinding a second time brings
        you back to where you were before

   - [[https://github.com/bakkeby/patches/wiki/togglelayout][togglelayout]]
      - toggle layout using the same keyboard shortcuts to set the layout
      - e.g. hitting ~MOD+m~ switches to monocle layout, hitting the same keybinding again brings
        you back to the previous layout

   - [[https://dwm.suckless.org/patches/transfer/][transfer]]
      - lets you transfer the currently focused client between the master and stack area while
        increasing or decreasing the master area (nmaster) accordingly

   - [[https://dwm.suckless.org/patches/transfer/][transferall]]
      - lets you transfer all clients between the master and stack area while increasing or
        decreasing the master area (nmaster) accordingly

   - [[https://dwm.suckless.org/patches/unfloatvisible/][unfloatvisible]]
      - resets isfloating on any visible windows that have it set and optionally also applies a
        layout

   - [[https://dwm.suckless.org/patches/killunsel/][killunsel]]
      - kills all visible clients that are not selected (only the selected client will remain)

   - +[[https://dwm.suckless.org/patches/urgentborder/][urgentborder]]+
      - +this patch makes "urgent" windows have different colors+

   - [[https://github.com/bakkeby/patches/blob/master/dwm/dwm-vanitygaps-6.2.diff][vanitygaps]]
      - adds configurable gaps between windows differentiating between outer, inner, horizontal and
        vertical gaps

   - [[https://dwm.suckless.org/patches/viewontag/][viewontag]]
      - follow a window to the tag it is being moved to

   - [[https://dwm.suckless.org/patches/vtcolors/][vtcolor]]
      - this patch adds the ability for dwm to read colors from the linux virtual console
        essentially allowing you to use the same color scheme as your regular tty

   - [[https://dwm.suckless.org/patches/warp/][warp]]
      - warps the mouse cursor to the center of the currently focused window or screen when the
        mouse cursor is (a) on a different screen or (b) on top of a different window

  - [[https://dwm.suckless.org/patches/winicon/][winicon]]
    - adds the window icon next to the window title in the bar

   - [[https://github.com/bakkeby/patches/wiki/windowrolerule/][windowrolerule]]
      - sometimes a single application opens different windows depending on the task at hand and
        this is often reflected in the =WM_WINDOW_ROLE(STRING)= x property
      - this patch adds the role field to the rule configuration so that one can differentiate
        between, say, Firefox "browser" vs "Preferences" vs "Manager" or Google-chrome "browser"
        vs "pop-up".

   - [[http://dwm.suckless.org/patches/winview/][winview]]
      - allows switching the view to that of a given client from the all-window view (Mod-0) using
        a keyboard shortcut

   - [[https://dwm.suckless.org/patches/xkb/][xkb]]
      - remembers keyboard layout per client

   - [[http://dwm.suckless.org/patches/xrdb/][xrdb]]
      - allows dwm to read colors from xrdb (.Xresources) during runtime

   - [[https://www.reddit.com/r/suckless/comments/ie5fe3/zoomfloating_my_own_simple_original_patch/][zoomfloating]]
      - a simple patch that allows floating windows to be zoomed into the master stack position

   - [[https://dwm.suckless.org/patches/zoomswap/][zoomswap]]
      - allows a master and a stack window to swap places rather than every window on the screen
        changing position

** Layouts Included

   - [[https://dwm.suckless.org/patches/bottomstack/][bstack]]
      - bottomstack layout

   - [[https://dwm.suckless.org/patches/bottomstack/][bstackhoriz]]
      - bottomstack horizontal layout

   - [[https://dwm.suckless.org/patches/centeredmaster/][centeredmaster]]
      - centeredmaster layout

   - [[https://dwm.suckless.org/patches/centeredmaster/][centeredfloatingmaster]]
      - centeredfloatingmaster layout

   - [[https://dwm.suckless.org/patches/columns/][columns]]
      - same as the default tile layout except clients in the master area are arranged in columns
        (i.e. left to right)

   - [[https://dwm.suckless.org/patches/deck/][deck]]
      - deck layout - clients in the stack area are arranged on top of each other (like monocle)

   - [[https://dwm.suckless.org/patches/fibonacci/][fibonacci]]
      - fibonacci (dwindle and spiral) layouts

   - [[https://github.com/bakkeby/patches/wiki/flextile-deluxe/][flextile-deluxe]]
      - a re-envisioned, flexible and over-the-top version of the original [[https://dwm.suckless.org/patches/flextile/][flextile]] patch supporting
         - multiple split layouts (horizontal, vertical, centered, floating, fixed)
         - tile arrangement on a per split basis (stack horizontally, stack vertically, grids,
           fibonacci)
         - pertag, cfacts, rmaster, vanitygaps compatibility
         - tile, deck, monocle, centeredmaster, bstack, bstackhoriz, gapplessgrid and more
      - this gives you a lot of versatility in terms of layout

   - [[https://dwm.suckless.org/patches/gaplessgrid/][gapplessgrid]]
      - gappless grid layout

   - [[https://dwm.suckless.org/patches/gridmode/][gridmode]]
      - gridmode (grid) layout

   - [[https://dwm.suckless.org/patches/horizgrid/][horizgrid]]
      - horizontal grid layout

   - [[https://dwm.suckless.org/patches/nrowgrid/][nrowgrid]]
      - nrowgrid layout, number of rows in grid controlled by nmaster

* Patches

This file contains patch control flags.

In principle you should be able to mix and match any patches you may want. In cases where patches are logically incompatible one patch may take precedence over the other as noted in the relevant descriptions.

Although layouts typically come as patches they are differentiated here for grouping purposes.

** Bar Modules

*** Awesome Bar

Enhanced taskbar that shows the titles of all visible windows in the status bar and allows focus / hiding / unhiding of windows by clicking on the status bar.

Awesomebar takes precedence over fancybar.

https://dwm.suckless.org/patches/awesomebar/


#+begin_src c :tangle patches.def.h
  #define BAR_AWESOMEBAR_PATCH 0
#+end_src

*** DWM Blocks

**** Main

This patch depends on statuscmd patch and adds integration with a (patched) dwmblocks instance to give a clickable status bar. One must not necessarily have to use dwmblocks for this feature, any status updater that has support for real-time signals (SIGRTMIN) can be used.

dwmblocks: https://github.com/torrinfail/dwmblocks

https://dwm.suckless.org/patches/statuscmd/

#+begin_src c :tangle patches.def.h
  #define BAR_DWMBLOCKS_PATCH 0
#+end_src

**** SIGUSR1

Originally the dwmblocks + statuscmd patch used a user defined signal (SIGUSR1) for communicating with dwmblocks to indicate update signal and what button was pressed. The signalling was later changed to SIGRTMIN instead.

Ultimately this makes dwmblocks instances that were patched with the old patch are incompatible with the new dwm patch and vice versa.

This is a compatibility patch that makes dwm use SIGUSR1 instead of SIGRTMIN so if button clicks are not working then you may want to try enabling this.

If dwmblocks happen to die like this when clicking on a status

   [1]    54355 user-defined signal 1  dwmblocks

then it suggests that dwmblocks does not support user defined signals and this patch should be left disabled.

Patch: https://gist.github.com/danbyl/54f7c1d57fc6507242a95b71c3d8fdea

https://dwm.suckless.org/patches/statuscmd/

#+begin_src c :tangle patches.def.h
  #define BAR_DWMBLOCKS_SIGUSR1_PATCH 0
#+end_src

*** Fancy Bar

This patch shows the titles of all visible windows in the status bar (as opposed to showing only the selected one).

Awesomebar takes precedence over fancybar. Fancybar takes precedence over the centeredwindowname patch.

https://dwm.suckless.org/patches/fancybar/

#+begin_src c :tangle patches.def.h
  #define BAR_FANCYBAR_PATCH 0
#+end_src

*** Flex Win Title

Being an evolution of the bartabgroups patch the flexwintitle patch specifically taps into the many layout options that flextile-deluxe offers to produce a window title section in the bar that is representative of what is shown on screen.

#+begin_src c :tangle patches.def.h
  #define BAR_FLEXWINTITLE_PATCH 0
#+end_src

*** Layout Menu

This patch adds a context menu for layout switching.

  - xmenu needs to be installed.
  - Edit layoutmenu.sh with the installed layouts and with correct indexes.
  - Place layoutmenu.sh in PATH.
  - The text of the menu items is for display only. Name them however you want.

https://dwm.suckless.org/patches/layoutmenu/

#+begin_src c :tangle patches.def.h
  #define BAR_LAYOUTMENU_PATCH 0
#+end_src

*** Layout Symbol

Show layout symbol in bar

#+begin_src c :tangle patches.def.h
  #define BAR_LTSYMBOL_PATCH 0
#+end_src

*** Powerline

**** Powerline Status

Adds powerline arrows for the status. This uses statuscolors logic for choosing colors for the powerline. As these markers are also control characters there is no explicit statuscmd support for this patch.

Powerline separators are defined as:
#+begin_example
   |\xXX  (creates a hard edge)
   <\xXX  (creates a less than arrow)
   /\xXX  (creates a diagonal line)
#+end_example

Examples:
#+begin_example
   xsetroot -name "$(echo -e '<\x01a<\x02b<\x03c')"
   xsetroot -name "$(echo -e '/\x01d/\x02d/\x03f')"
#+end_example

https://gitlab.com/udiboy1209-suckless/dwm/-/commit/071f5063e8ac4280666828179f92788d893eea40#4b1a539194be7467cefbda22f675a3b7c19ceca7

https://dwm.suckless.org/patches/statuscolors/

#+begin_src c :tangle patches.def.h
  #define BAR_POWERLINE_STATUS_PATCH 0
#+end_src

**** Powerline Tags

Adds powerline arrows for the tags.

https://gitlab.com/udiboy1209-suckless/dwm/-/commit/071f5063e8ac4280666828179f92788d893eea40#4b1a539194be7467cefbda22f675a3b7c19ceca7

#+begin_src c :tangle patches.def.h
  #define BAR_POWERLINE_TAGS_PATCH 0
#+end_src

**** Powerline Tags Slash

Alters the tags powerline to use forward slash instead of arrows.

#+begin_src c :tangle patches.def.h
  #define BAR_POWERLINE_TAGS_SLASH_PATCH 0
#+end_src

*** Tab Groups

This patch turns the titlebar area into a mfact-respecting tabbar showing each client's title.

https://dwm.suckless.org/patches/bartabgroups/

#+begin_src c :tangle patches.def.h
  #define BAR_TABGROUPS_PATCH 0
#+end_src

*** Tag Grid

This patch adds an option to place tags in rows like in many other window managers.

https://dwm.suckless.org/patches/taggrid/

#+begin_src c :tangle patches.def.h
  #define BAR_TAGGRID_PATCH 0
#+end_src

*** Status

Show status in bar

#+begin_src c :tangle patches.def.h
  #define BAR_STATUS_PATCH 0
#+end_src

*** Status Button

This patch adds a clickable button to the left hand side of the statusbar.

https://dwm.suckless.org/patches/statusbutton/

#+begin_src c :tangle patches.def.h
  #define BAR_STATUSBUTTON_PATCH 0
#+end_src

*** Status CMD

This patch adds the ability to execute shell commands based on the mouse button and position when clicking the status bar. Refer to the website for usage.

https://dwm.suckless.org/patches/statuscmd/

#+begin_src c :tangle patches.def.h
  #define BAR_STATUSCMD_PATCH 0
#+end_src

*** Status 2D

**** Main

Status2d allows colors and rectangle drawing in your dwm status bar.

This patch is incompatible with the statuscolors patch which takes precedence.
This patch is incompatible with the extrabar patch.

https://dwm.suckless.org/patches/status2d/

#+begin_src c :tangle patches.def.h
  #define BAR_STATUS2D_PATCH 0
#+end_src

**** No Alpha

Supplementary patch should you want to disable alpha for the status2d section

#+begin_src c :tangle patches.def.h
  #define BAR_STATUS2D_NO_ALPHA_PATCH 0
#+end_src

**** XRDB Term Colors

Addition to the status2d patch that allows the use of terminal colors (color0 through color15) from xrdb in the status, allowing programs like pywal to change statusbar colors.

This adds the C and B codes to use terminal foreground and background colors respectively.

E.g. ^B5^ would use color5 as the background color.

https://dwm.suckless.org/patches/status2d/

#+begin_src c :tangle patches.def.h
  #define BAR_STATUS2D_XRDB_TERMCOLORS_PATCH 0
#+end_src

*** Systray

The systray patch adds systray for the status bar.

https://dwm.suckless.org/patches/systray/

#+begin_src c :tangle patches.def.h
  #define BAR_SYSTRAY_PATCH 0
#+end_src

*** Tags

Show tag symbols in bar.

#+begin_src c :tangle patches.def.h
  #define BAR_TAGS_PATCH 0
#+end_src

*** Window Icon

This patch adds the window icon next to the window title in the bar.

The patch depends on Imlib2 for icon scaling.
You need to uncomment the corresponding line in config.mk to use the -lImlib2 library

Arch Linux:
    ~sudo pacman -S imlib2~
Debian:
    ~sudo apt install libimlib2-dev~

The author recommends adding the compiler flags of -O3 and -march=native to enable auto loop
vectorize for better performance.

https://github.com/AdamYuan/dwm-winicon
https://dwm.suckless.org/patches/winicon

#+begin_src c :tangle patches.def.h
  #define BAR_WINICON_PATCH 0
#+end_src

*** Window Title

**** Main

Show window title in bar.

#+begin_src c :tangle patches.def.h
  #define BAR_WINTITLE_PATCH 0
#+end_src

**** Floating

Shows window titles in the bar, but only for floating clients.

This depends on code from the flexwintitle patch.

Note that the configuration in config.def.h for this is merely an example. If combined with the corresponding hidden patch then these two will overlap unless the width of the modules are controlled.

#+begin_src c :tangle patches.def.h
  #define BAR_WINTITLE_FLOATING_PATCH 0
#+end_src

**** Hidden

Shows window titles in the bar, but only for floating clients.

This depends on code from the flexwintitle patch.

Note that the configuration in config.def.h for this is merely an example. If combined with the corresponding floating patch then these two will overlap unless the width of the modules are controlled.

#+begin_src c :tangle patches.def.h
  #define BAR_WINTITLE_HIDDEN_PATCH 0
#+end_src

*** Title Padding

Title bar modules such as wintitle (default), fancybar and awesomebar do not by default add left and/or right padding as they take up the remaining space. These options allow you explicitly add padding should you need it.

#+begin_src c :tangle patches.def.h
  #define BAR_TITLE_RIGHT_PAD_PATCH 0
  #define BAR_TITLE_LEFT_PAD_PATCH 0
#+end_src

** Bar Options

*** Active Tag Indicator

**** Main

This patch changes the rectangle indicating if a tag is used by a client into a bar above the tag name for better visibility.

Set the tagindicatortype variable in config.h to INDICATOR_TOP_BAR to enable this.

https://dwm.suckless.org/patches/activetagindicatorbar/

#+begin_src c :tangle patches.def.h
  #define BAR_ACTIVETAGINDICATORBAR_PATCH N/A
#+end_src

**** Alternative

Alternative patch to the activetagindicatorbar patch, adds the bar below the tag icon rather than above.

Set the tagindicatortype variable in config.h to INDICATOR_BOTTOM_BAR to enable this.

#+begin_src c :tangle patches.def.h
  #define BAR_ACTIVETAGINDICATORBAR_ALT1_PATCH N/A
#+end_src

*** Alpha

The alpha patch adds transparency for the status bar.

You need to uncomment the corresponding line in config.mk to use the -lXrender library when including this patch.

https://dwm.suckless.org/patches/alpha/

#+begin_src c :tangle patches.def.h
  #define BAR_ALPHA_PATCH 0
#+end_src

*** Alternative Tags

This patch introduces alternative tags which can be switched on the fly for the sole purpose of providing visual aid.

https://dwm.suckless.org/patches/alternativetags/

#+begin_src c :tangle patches.def.h
  #define BAR_ALTERNATIVE_TAGS_PATCH 0
#+end_src

*** Alternative Tags Decoration

This patches provides the ability to use alternative text for tags which contain at least one window.

https://dwm.suckless.org/patches/alttagsdecoration/

#+begin_src c :tangle patches.def.h
  #define BAR_ALTTAGSDECORATION_PATCH 0
#+end_src

*** Anybar

**** Main

This patch enables dwm to manage external status bars such as lemonbar and polybar.

dwm treats the external bar as it would its own, so all regular dwm commands such as togglebar affect the external bar in the same way.

NB: Unless you want both anybar + dwm bar(s) then the recommendation is to disable all bar modules and have { -2 } in the barrules.

https://dwm.suckless.org/patches/anybar/

#+begin_src c :tangle patches.def.h
  #define BAR_ANYBAR_PATCH 1
#+end_src

**** Top and Bottom Bars

Anybar option to place the next bar depending on previous bar's position (top or bottom)

#+begin_src c :tangle patches.def.h
  #define BAR_ANYBAR_TOP_AND_BOTTOM_BARS_PATCH 0
#+end_src

**** Manage Width

Anybar option to let dwm manage the width of the bar.

#+begin_src c :tangle patches.def.h
  #define BAR_ANYBAR_MANAGE_WIDTH_PATCH 0
#+end_src

*** Border

This patch adds a border around the status bar(s) just like the border of client windows.

https://codemadness.org/paste/dwm-border-bar.patch

#+begin_src c :tangle patches.def.h
  #define BAR_BORDER_PATCH 0
#+end_src

*** Centered Window Name

This patch centers the WM_NAME of the currently selected window on the status bar.

This is compatible with the wintitle, bartabgroups, flexwintitle and awesomebar bar modules.

https://dwm.suckless.org/patches/centeredwindowname/

#+begin_src c :tangle patches.def.h
  #define BAR_CENTEREDWINDOWNAME_PATCH 0
#+end_src

*** Client Indicator

Draws a dot indicator overlayed on each tag icon for each client. The selected client is drawn as a larger horizontal line.

Set the tagindicatortype variable in config.h to INDICATOR_CLIENT_DOTS to enable this.

https://dwm.suckless.org/patches/clientindicators/

#+begin_src c :tangle patches.def.h
  #define BAR_CLIENTINDICATOR_PATCH N/A
#+end_src

*** Color Emoji

This patch enables color emoji in dwm by removing a workaround for a BadLength error in the Xft library when color glyphs are used.

To enable this you will need an updated Xft library that can handle color glyphs otherwise dwm will crash on encountering such characters. Note that you will also need a font that provides color emojis for this to work.

#+begin_src c :tangle patches.def.h
  #define BAR_COLOR_EMOJI_PATCH 0
#+end_src

*** Dmenu Match Top

Updates the position of dmenu to match that of the bar. I.e. if topbar is 0 then dmenu will appear at the bottom and if 1 then dmenu will appear at the top.

https://dwm.suckless.org/patches/dmenumatchtop

#+begin_src c :tangle patches.def.h
  #define BAR_DMENUMATCHTOP_PATCH 0
#+end_src

*** Extra Status

Originally this was the extrabar patch, but as the handling of extra bars is now built-in only the splitting of the status by a designated separator remains. As such this has been renamed to more accurately reflect what it does - creating an extra status.

https://dwm.suckless.org/patches/extrabar/

#+begin_src c :tangle patches.def.h
  #define BAR_EXTRASTATUS_PATCH 0
#+end_src

*** EWMH Tags

Adds EWMH support for _NET_NUMBER_OF_DESKTOPS, _NET_CURRENT_DESKTOP, _NET_DESKTOP_NAMES and _NET_DESKTOP_VIEWPORT, which allows for compatibility with other bars and programs that request workspace information. For example polybar's xworkspaces module.

This patch also includes support for adding the _IS_FLOATING property for floating windows allowing for compositors to treat floating windows differently to tiled windows.

E.g. this setting makes picom only render shadows for floating windows:

    shadow-exclude = [ "! _IS_FLOATING@:32c = 1" ];

https://github.com/bakkeby/dwm-flexipatch/issues/50 (_IS_FLOATING patch)

https://dwm.suckless.org/patches/ewmhtags/

#+begin_src c :tangle patches.def.h
  #define BAR_EWMHTAGS_PATCH 1
#+end_src

*** Height

Allows the bar height to be explicitly set rather than being derived from font.

https://dwm.suckless.org/patches/bar_height/

#+begin_src c :tangle patches.def.h
  #define BAR_HEIGHT_PATCH 0
#+end_src

*** Hide Vacant Tags

This patch prevents dwm from drawing tags with no clients (i.e. vacant) on the bar.

https://dwm.suckless.org/patches/hide_vacant_tags/

#+begin_src c :tangle patches.def.h
  #define BAR_HIDEVACANTTAGS_PATCH 0
#+end_src

*** Holdbar

With this patch dwm's built-in status bar is only shown when HOLDKEY is pressed and the bar will now overlay the display.

http://dwm.suckless.org/patches/holdbar/

#+begin_src c :tangle patches.def.h
  #define BAR_HOLDBAR_PATCH 0
#+end_src

*** Ignore Xft Errors When Drawing Text

Sometimes dwm crashes when it cannot render some glyphs in window titles (usually emoji).

This patch is essentially a hack to ignore any errors when drawing text on the status bar.

https://groups.google.com/forum/m/#!topic/wmii/7bncCahYIww

https://docs.google.com/viewer?a=v&pid=forums&srcid=MDAwODA2MTg0MDQyMjE0OTgzMzMBMDQ3ODQzODkyMTU3NTAyMTMxNTYBX2RUMVNtOUtDQUFKATAuMQEBdjI&authuser=0

#+begin_src c :tangle patches.def.h
  #define BAR_IGNORE_XFT_ERRORS_WHEN_DRAWING_TEXT_PATCH 0
#+end_src

*** Padding

This patch adds vertical and horizontal space between the statusbar and the edge of the screen.

https://dwm.suckless.org/patches/barpadding/

#+begin_src c :tangle patches.def.h
  #define BAR_PADDING_PATCH 0
#+end_src

*** Pango

This patch adds simple markup for status messages using pango markup.

This depends on the pango library v1.44 or greater.

You need to uncomment the corresponding lines in config.mk to use the pango libraries when including this patch.

Note that the pango patch does not protect against the BadLength error from Xft when color glyphs are used, which means that dwm will crash if color emoji is used.

If you need color emoji then you may want to install this patched library from the AUR: https://aur.archlinux.org/packages/libxft-bgra/

A long term fix for the libXft library is pending approval of this pull request: https://gitlab.freedesktop.org/xorg/lib/libxft/-/merge_requests/1

Also see:
https://developer.gnome.org/pygtk/stable/pango-markup-language.html
https://lists.suckless.org/hackers/2004/17285.html
https://dwm.suckless.org/patches/pango/

#+begin_src c :tangle patches.def.h
  #define BAR_PANGO_PATCH 0
#+end_src

*** Status Colors

This patch enables colored text in the status bar. It changes the way colors are defined in config.h allowing multiple color combinations for use in the status script.

This patch is incompatible with and takes precedence over the status2d patch.

This patch is compatible with the statuscmd patch with the caveat that the first 16 markers are reserved for status colors restricting block signals to 17 through 31.

https://dwm.suckless.org/patches/statuscolors/

#+begin_src c :tangle patches.def.h
  #define BAR_STATUSCOLORS_PATCH 0
#+end_src

*** Status Padding

This patch adds configuration options for horizontal and vertical padding in the status bar.

https://dwm.suckless.org/patches/statuspadding/

#+begin_src c :tangle patches.def.h
  #define BAR_STATUSPADDING_PATCH 0
#+end_src

*** VT Colors
This patch adds the ability for dwm to read colors from the linux virtual console.

   /sys/module/vt/parameters/default_{red,grn,blu}

Essentially this way the colors you use in your regular tty is "mirrored" to dwm.

https://dwm.suckless.org/patches/vtcolors/

#+begin_src c :tangle patches.def.h
  #define BAR_VTCOLORS_PATCH 0
#+end_src

*** Window Title Actions

This patch allows client windows to be hidden. This code was originally part of awesomebar, but has been separated out so that other bar modules can take advantage of it.

Both awesomebar and bartabgroups patches depend on this patch and it will be auto-enabled during compile time if it is needed. Note that if using flexipatch-finalizer this must be explicitly enabled.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-barmodules-wintitleactions-6.2.diff

#+begin_src c :tangle patches.def.h
  #define BAR_WINTITLEACTIONS_PATCH BAR_AWESOMEBAR_PATCH || BAR_TABGROUPS_PATCH || BAR_FLEXWINTITLE_PATCH
#+end_src

** Other

*** Always Center

All floating windows are centered, like the center patch, but without a rule. The center patch takes precedence over this patch. This patch interferes with the center transient windows patches.

https://dwm.suckless.org/patches/alwayscenter/

#+begin_src c :tangle patches.def.h
  #define ALWAYSCENTER_PATCH 0
#+end_src

*** Aspect Resize

This patch allows windows to be resized with its aspect ratio remaining constant.

https://dwm.suckless.org/patches/aspectresize/

#+begin_src c :tangle patches.def.h
  #define ASPECTRESIZE_PATCH 1
#+end_src

*** Attach Above

This patch adds new clients above the selected client, instead of always becoming the new master. This behaviour is known from Xmonad.

This patch takes precedence over ATTACHASIDE_PATCH.

https://dwm.suckless.org/patches/attachabove/

#+begin_src c :tangle patches.def.h
  #define ATTACHABOVE_PATCH 0
#+end_src

*** Attach Aside

This patch adds new clients on top of the stack.

This patch takes precedence over ATTACHBELOW_PATCH.

https://dwm.suckless.org/patches/attachaside/

#+begin_src c :tangle patches.def.h
  #define ATTACHASIDE_PATCH 0
#+end_src

*** Attach Below

This patch adds new clients below the selected client.

This patch takes precedence over ATTACHBOTTOM_PATCH.

https://dwm.suckless.org/patches/attachbelow/

#+begin_src c :tangle patches.def.h
  #define ATTACHBELOW_PATCH 1
#+end_src

*** Attach Bottom

This patch adds new clients at the bottom of the stack.

https://dwm.suckless.org/patches/attachbottom/

#+begin_src c :tangle patches.def.h
  #define ATTACHBOTTOM_PATCH 0
#+end_src

*** Auto Start

This patch will make dwm run "~/.local/share/dwm/autostart_blocking.sh" and "~/.local/share/dwm/autostart.sh &" before entering the handler loop. One or both of these files can be ommited. Note the path inside .local/share rather than the original ~/.dwm folder.

https://dwm.suckless.org/patches/autostart/

#+begin_src c :tangle patches.def.h
  #define AUTOSTART_PATCH 0
#+end_src

*** Auto Resize

By default, windows that are not visible when requesting a resize/move will not get resized/moved. With this patch, they will.

https://dwm.suckless.org/patches/autoresize/

#+begin_src c :tangle patches.def.h
  #define AUTORESIZE_PATCH 1
#+end_src

*** Center

This patch adds an iscentered rule to automatically center clients on the current monitor.

This patch takes precedence over centeredwindowname, alwayscenter and fancybar patches.

https://dwm.suckless.org/patches/center/

#+begin_src c :tangle patches.def.h
  #define CENTER_PATCH 1
#+end_src

*** Center Transient

**** Main

A transient window is one that is meant to be short lived and is usually raised by a parent window. Such windows are typically dialog boxes and the like.

It should be noted that in dwm transient windows are not subject to normal client rules and they are always floating by default.

This patch centers transient windows on the screen like the center patch does. Note that the 6.2 center patch piggy-backed on the updatewindowtype function to ensure that all dialog boxes were centered, transient or not. This function was removed in relation to adding wintype as a client rule filter, hence this no longer works out of the box. This patch restores previous behaviour with the center patch.

#+begin_src c :tangle patches.def.h
  #define CENTER_TRANSIENT_WINDOWS_PATCH 1
#+end_src

**** By Parent

As above, except that the transient window is centered within the position of the parent window, rather than at the center of the screen. This takes precedence over the above patch.

#+begin_src c :tangle patches.def.h
  #define CENTER_TRANSIENT_WINDOWS_BY_PARENT_PATCH 0
#+end_src

*** CFacts

This patch provides the ability to assign different weights to clients in their respective stack in tiled layout.

https://dwm.suckless.org/patches/cfacts/

#+begin_src c :tangle patches.def.h
  #define CFACTS_PATCH 1
#+end_src

*** CMD Customize

This patch allows color attributes to be set through the command line.

https://dwm.suckless.org/patches/cmdcustomize/

#+begin_src c :tangle patches.def.h
  #define CMDCUSTOMIZE_PATCH 0
#+end_src

*** Combo

This patch tweaks the tagging interface so that you can select multiple tags for tag or view by pressing all the right keys as a combo. For example to view tags 1 and 3, hold MOD and then press and hold 1 and 3 together.

https://dwm.suckless.org/patches/combo/

#+begin_src c :tangle patches.def.h
  #define COMBO_PATCH 1
#+end_src

*** Cool Auto Start

Allow dwm to execute commands from autostart array in your config.h file. When dwm exits then all processes from autostart array will be killed.

https://dwm.suckless.org/patches/cool_autostart/

#+begin_src c :tangle patches.def.h
  #define COOL_AUTOSTART_PATCH 0
#+end_src

*** Cycle Layouts

The cyclelayouts patch lets you cycle through all your layouts.

https://dwm.suckless.org/patches/cyclelayouts/

#+begin_src c :tangle patches.def.h
  #define CYCLELAYOUTS_PATCH 1
#+end_src

*** Decoration Hints

Make dwm respect _MOTIF_WM_HINTS property, and not draw borders around windows requesting for it. Some applications use this property to notify window managers to not draw window decorations.

Not respecting this property leads to issues with applications that draw their own borders, like chromium (with "Use system title bar and borders" turned off) or vlc in fullscreen mode.

https://dwm.suckless.org/patches/decoration_hints/

#+begin_src c :tangle patches.def.h
  #define DECORATION_HINTS_PATCH 0
#+end_src

*** Distribute Tags

This feature distributes all clients on the current monitor evenly across all tags.

It is a variant of the reorganizetags patch.

https://dwm.suckless.org/patches/reorganizetags/

#+begin_src c :tangle patches.def.h
  #define DISTRIBUTETAGS_PATCH 0
#+end_src

*** Drag CFact

Similarly to the dragmfact patch this allows you to click and drag clients to change the cfact to adjust the client's size in the stack. This patch depends on the cfacts patch.

#+begin_src c :tangle patches.def.h
  #define DRAGCFACT_PATCH 0
#+end_src

*** Drag MFact

This patch lets you resize the split in the tile layout (i.e. modify mfact) by holding the modkey and dragging the mouse.

This patch can be a bit wonky with other layouts, but generally works.

https://dwm.suckless.org/patches/dragmfact/

#+begin_src c :tangle patches.def.h
  #define DRAGMFACT_PATCH 0
#+end_src

*** DWMC

Simple dwmc client using a fork of fsignal to communicate with dwm.

To use this either copy the patch/dwmc shell script to somewhere in your path or uncomment the following line in Makefile:

   #cp -f patch/dwmc ${DESTDIR}${PREFIX}/bin

http://dwm.suckless.org/patches/dwmc/

#+begin_src c :tangle patches.def.h
  #define DWMC_PATCH 1
#+end_src

*** Empty View

This patch allows no tag at all to be selected. The result is that dwm will start with no tag selected and when you start a client with no tag rule and no tag selected then it will be opened on the first tag.

https://dwm.suckless.org/patches/emptyview/

#+begin_src c :tangle patches.def.h
  #define EMPTYVIEW_PATCH 0
#+end_src

*** Extension Resize

This patch allows the user to change size and placement of floating windows using only the keyboard. It also allows for temporary vertical and horizontal extension of windows similar to other WMs fill command.

https://dwm.suckless.org/patches/exresize/

#+begin_src c :tangle patches.def.h
  #define EXRESIZE_PATCH 0
#+end_src

*** Fake Fullscreen

Only allow clients to "fullscreen" into the space currently given to them.

As an example, this will allow you to view a fullscreen video in your browser on one half of the screen, while having the other half available for other tasks.

This patch takes precedence over the fakefullscreen client patch below.

https://dwm.suckless.org/patches/fakefullscreen/

#+begin_src c :tangle patches.def.h
  #define FAKEFULLSCREEN_PATCH 0
#+end_src

*** Fake Fullscreen Client

Similarly to the fakefullscreen patch this patch only allows clients to "fullscreen" into the space currently given to them.

The "twist" with this patch is that fake fullscreen can be toggled on a per client basis rather than applying to all clients globally.

Also see the selectivefakefullscreen option that adds a rule option to enabled this on client startup.

#+begin_src c :tangle patches.def.h
  #define FAKEFULLSCREEN_CLIENT_PATCH 0
#+end_src

*** Float Position

**** Main

This patch adds a float rule allowing the size and position of floating windows to be specified It also allows the size and position of floating windows to be controlled similar to the exresize, moveresize, and moveplace patches.

The size and position can be specified using absolute, relative or fixed co-ordinates and

https://github.com/bakkeby/patches/wiki/floatpos/

#+begin_src c :tangle patches.def.h
  #define FLOATPOS_PATCH 0
#+end_src

**** Respect Gaps

Add-on functionality for the above: make the float positions respect outer (vanity)gaps.

#+begin_src c :tangle patches.def.h
  #define FLOATPOS_RESPECT_GAPS_PATCH 0
#+end_src

*** Focus Adjacent Tag

This patch provides the ability to focus the tag on the immediate left or right of the currently focused tag. It also allows to send the focused window either on the left or the right tag.

http://dwm.suckless.org/patches/focusadjacenttag/

#+begin_src c :tangle patches.def.h
  #define FOCUSADJACENTTAG_PATCH 0
#+end_src

*** Focus Direction

Allows focusing on clients based on direction (up, down, left, right) instead of client order.

https://github.com/bakkeby/patches/wiki/focusdir/

#+begin_src c :tangle patches.def.h
  #define FOCUSDIR_PATCH 0
#+end_src

*** Focus Master

A simple patch that just puts focus back to the master client.

https://dwm.suckless.org/patches/focusmaster/

#+begin_src c :tangle patches.def.h
  #define FOCUSMASTER_PATCH 0
#+end_src

*** Focus On Click

Switch focus only by mouse click and not sloppy (focus follows mouse pointer).

https://dwm.suckless.org/patches/focusonclick/

#+begin_src c :tangle patches.def.h
  #define FOCUSONCLICK_PATCH 0
#+end_src

*** Focus Urgent

Selects the next window having the urgent flag regardless of the tag it is on.

The urgent flag can be artificially set with the following xdotool command on any window:

  xdotool selectwindow -- set_window --urgency 1

https://dwm.suckless.org/patches/focusurgent/

#+begin_src c :tangle patches.def.h
  #define FOCUSURGENT_PATCH 0
#+end_src

*** Focus On Net Active

By default, dwm responds to _NET_ACTIVE_WINDOW client messages by setting the urgency bit on the named window. This patch activates the window instead.

https://dwm.suckless.org/patches/focusonnetactive/

#+begin_src c :tangle patches.def.h
  #define FOCUSONNETACTIVE_PATCH 1
#+end_src

*** Fake Signals

Send "fake signals" to dwm for handling, using xsetroot. This will not conflict with the status bar, which also is managed using xsetroot.

Also see the dwmc patch, which takes precedence over this patch.

https://dwm.suckless.org/patches/fsignal/

#+begin_src c :tangle patches.def.h
  #define FSIGNAL_PATCH 0
#+end_src

*** Fullscreen

Applies the monocle layout with the focused client on top and hides the bar. When pressed again it shows the bar and restores the layout that was active before going fullscreen.

https://dwm.suckless.org/patches/fullscreen/

#+begin_src c :tangle patches.def.h
  #define FULLSCREEN_PATCH 0
#+end_src

*** In-Place Rotate

This patch provides a keybinding to rotate all clients in the currently selected area (master or stack) without affecting the other area.

https://dwm.suckless.org/patches/inplacerotate/

#+begin_src c :tangle patches.def.h
  #define INPLACEROTATE_PATCH 0
#+end_src

*** Insets

This patch lets you define custom insets from each edge of the screen. One use case would be to arrange space for an external bar.

https://dwm.suckless.org/patches/insets/

#+begin_src c :tangle patches.def.h
  #define INSETS_PATCH 0
#+end_src

*** IPC

This patch (v1.5.7) implements inter-process communication through a UNIX socket for dwm. This allows for the window manager to be queried for information, e.g. listen for events such as tag or layout changes, as well as send commands to control the window manager via other programs.

You need to uncomment the corresponding lines in config.mk to use the -lyajl library when including this patch.

This patch depends on the following additional library:
   - yajl

https://github.com/mihirlad55/dwm-ipc

https://dwm.suckless.org/patches/ipc/

#+begin_src c :tangle patches.def.h
  #define IPC_PATCH 1
#+end_src

*** Is Permanent

Adds rule option for clients to avoid accidental termination by killclient for sticky windows.

https://dwm.suckless.org/patches/ispermanent/

#+begin_src c :tangle patches.def.h
  #define ISPERMANENT_PATCH 0
#+end_src

*** Key Modes

This patch adds key modes (like in vim or emacs) where chains of keyboard shortcuts can be performed.

https://dwm.suckless.org/patches/keymodes/

#+begin_src c :tangle patches.def.h
  #define KEYMODES_PATCH 0
#+end_src

*** Kill Unselected

This patch adds a keybinding to kills all visible clients that are not selected.

https://dwm.suckless.org/patches/killunsel/

#+begin_src c :tangle patches.def.h
  #define KILLUNSEL_PATCH 0
#+end_src

*** LG3d

This changes the window manager name to LG3d instead of dwm as a workaround for Java applications that assume that the window manager is using window reparenting.

Refer to the ISSUES secton of the dwm man page for more details.

#+begin_src c :tangle patches.def.h
  #define LG3D_PATCH 0
#+end_src

*** Lose Fullscreen

By default in dwm it is possible to make an application fullscreen, then use the focusstack keybindings to focus on other windows beneath the current window.

It is also possible to spawn new windows (e.g. a terminal) that end up getting focus while the previous window remains in fullscreen. This patch ensures that in such scenarios the previous window loses fullscreen.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-losefullscreen-6.2.diff

#+begin_src c :tangle patches.def.h
  #define LOSEFULLSCREEN_PATCH 1
#+end_src

*** Maximize Floating Windows

This patch adds helper functions for maximizing, horizontally and vertically, floating windows using keybindings.

https://dwm.suckless.org/patches/maximize/

#+begin_src c :tangle patches.def.h
  #define MAXIMIZE_PATCH 0
#+end_src

*** Music Player Daemon

Control Music Player Daemon via keybinds.

You need to uncomment the corresponding line in config.mk to use the -lmpdclient library when including this patch.

This patch depends on the following additional library:
   - libmpdclient

https://dwm.suckless.org/patches/mpdcontrol/

#+begin_src c :tangle patches.def.h
  #define MPDCONTROL_PATCH 0
#+end_src

*** Monitor Rules

Adds rules per monitor, e.g. have default layouts per monitor.

The use case for this is if the second monitor is vertical (i.e. rotated) then you may want to use a different default layout for this monitor than what is used for the main monitor. E.g. normal vertical split for main monitor and horizontal split for the second.

#+begin_src c :tangle patches.def.h
  #define MONITOR_RULES_PATCH 0
#+end_src

*** Monocle Symbol

Always display the the monocle-symbol as defined in config.h if the monocle-layout is activated. Do not display the number of open clients in the current tag.

https://dwm.suckless.org/patches/monoclesymbol/

#+begin_src c :tangle patches.def.h
  #define MONOCLESYMBOL_PATCH 0
#+end_src

*** Move Place

Makes a window floating and 1/3rd the height and 1/3rd the width of the screen and is positioned in either the center or one of the 8 cardinal directions depending on which key is pressed.

https://dwm.suckless.org/patches/moveplace/

#+begin_src c :tangle patches.def.h
  #define MOVEPLACE_PATCH 0
#+end_src

*** Move Resize

This patch allows you to move and resize dwm's clients using keyboard bindings.

https://dwm.suckless.org/patches/moveresize/

#+begin_src c :tangle patches.def.h
  #define MOVERESIZE_PATCH 0
#+end_src

*** Move Stack

This patch allows you to move clients around in the stack and swap them with the master.

https://dwm.suckless.org/patches/movestack/

#+begin_src c :tangle patches.def.h
  #define MOVESTACK_PATCH 1
#+end_src

*** Net Client List Stacking

Adds support for the _NET_CLIENT_LIST_STACKING atom, needed by certain applications like the Zoom video conferencing application.

https://github.com/bakkeby/patches/wiki/netclientliststacking/

#+begin_src c :tangle patches.def.h
  #define NET_CLIENT_LIST_STACKING_PATCH 1
#+end_src

*** No Border

Removes the border when there is only one window visible.

https://dwm.suckless.org/patches/noborder/

#+begin_src c :tangle patches.def.h
  #define NOBORDER_PATCH 0
#+end_src

*** No Dmenu

Enable modifying or removing dmenu in config.def.h which resulted previously in a compilation error because two lines of code hardcode dmenu into dwm.

https://dwm.suckless.org/patches/nodmenu/

#+begin_src c :tangle patches.def.h
  #define NODMENU_PATCH 1
#+end_src

*** No Mod Buttons

This patch allows for toggleable client button bindings that have no modifiers.

This can, for example, allow you to move or resize using the mouse alone without holding down a modifier key. This can be practical if you have extra buttons on your mouse.

While you can use button bindings with no modifiers without this patch in a bare dwm, those buttons are then unavailable for use within the application itself so being able to toggle these on and off can be necessary in certain situations (e.g. being able to use back and forward buttons in a browser).

Example bindings:
    { ClkClientWin,              0,              Button8,        movemouse,      {0} },
    { ClkClientWin,              0,              Button9,        resizemouse,    {0} },

#+begin_src c :tangle patches.def.h
  #define NO_MOD_BUTTONS_PATCH 0
#+end_src

*** No Transparent Borders

When terminals have transparency then their borders also become transparent.

This patch ensures that borders have no transparency. Note that this patch is only relevant if you are not using the alpha patch.

https://github.com/szatanjl/dwm/commit/1529909466206016f2101457bbf37c67195714c8

https://dwm.suckless.org/patches/alpha/dwm-fixborders-6.2.diff

#+begin_src c :tangle patches.def.h
  #define NO_TRANSPARENT_BORDERS_PATCH 1
#+end_src

*** On Empty Keys

Port of InstantVM's on_empty_keys functionality allowing keybindings that apply only when a tag is empty. An example use case is being able to launch applications with first hand keys like "f" to launch firefox.

https://github.com/instantOS/instantWM/

https://github.com/bakkeby/dwm-flexipatch/issues/51

#+begin_src c :tangle patches.def.h
  #define ON_EMPTY_KEYS_PATCH 0
#+end_src

*** Only One Rule Match

Minor patch that prevents more than one rule being matched for a given client.

#+begin_src c :tangle patches.def.h
  #define ONLY_ONE_RULE_MATCH_PATCH 0
#+end_src

*** Only Quit On Empty

This patch makes it so dwm will only exit via quit() if no windows are open.

This is to prevent you accidentally losing all your work.

https://dwm.suckless.org/patches/onlyquitonempty/

#+begin_src c :tangle patches.def.h
  #define ONLYQUITONEMPTY_PATCH 0
#+end_src

*** Per Tag

**** Main

The pertag patch adds nmaster, mfacts and layouts per tag rather than per monitor (default).

https://dwm.suckless.org/patches/pertag/

#+begin_src c :tangle patches.def.h
  #define PERTAG_PATCH 1
#+end_src

**** Vanity Gaps

Option to store gaps on a per tag basis rather than on a per monitor basis.

Depends on both pertag and vanitygaps patches being enabled.

#+begin_src c :tangle patches.def.h
  #define PERTAG_VANITYGAPS_PATCH 0
#+end_src

**** Bar

This controls whether or not to also store bar position on a per tag basis, or leave it as one bar per monitor.

#+begin_src c :tangle patches.def.h
  #define PERTAGBAR_PATCH 0
#+end_src

*** Place Mouse

This patch lets you change the position of a client in the stack using the mouse.

https://github.com/bakkeby/patches/wiki/placemouse

#+begin_src c :tangle patches.def.h
  #define PLACEMOUSE_PATCH 1
#+end_src

*** Push

**** Main

This patch provides a way to move clients up and down inside the client list.

https://dwm.suckless.org/patches/push/

#+begin_src c :tangle patches.def.h
  #define PUSH_PATCH 0
#+end_src

**** No Master

This patch provides a way to move clients up and down inside the client list, but does not push up or down into the master area (except that it does not take nmaster into account).

This takes precedence over the push patch above.

https://dwm.suckless.org/patches/push/

#+begin_src c :tangle patches.def.h
  #define PUSH_NO_MASTER_PATCH 0
#+end_src

*** Re-Organize Tags

Shifts all clients per tag to leftmost unoccupied tags.

For example, if clients A, B, C are tagged on tags 1, 5, 9 respectively, when this function is called, they will now be on 1, 2, and 3. The focused client will also remain focused.

Clients on multiple tags will be treated as if they only were only on their leftmost tag, and will be reduced to one tag after the operation is complete.

https://dwm.suckless.org/patches/reorganizetags/

#+begin_src c :tangle patches.def.h
  #define REORGANIZETAGS_PATCH 0
#+end_src

*** Resize Corners

By default, windows only resize from the bottom right corner. With this patch the mouse is warped to the nearest corner and you resize from there.

https://dwm.suckless.org/patches/resizecorners/

#+begin_src c :tangle patches.def.h
  #define RESIZECORNERS_PATCH 1
#+end_src

*** Resize Point

Practically the same as resizecorners, but the cursor does not warp to corners.

This takes precedence over the resizecorners patch.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-resizepoint-6.2.diff

#+begin_src c :tangle patches.def.h
  #define RESIZEPOINT_PATCH 0
#+end_src

*** Restart SIG

Adds a keyboard shortcut to restart dwm or alternatively by using kill -HUP dwmpid.

Additionally dwm can quit cleanly by using kill -TERM dwmpid.

https://dwm.suckless.org/patches/restartsig/

#+begin_src c :tangle patches.def.h
  #define RESTARTSIG_PATCH 1
#+end_src

*** Rio Draw

Adds rio-like drawing to resize the selected client.

This depends on an external tool slop being installed.

This patch was backported from instantWM.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-riodraw-6.2.diff

#+begin_src c :tangle patches.def.h
  #define RIODRAW_PATCH 0
#+end_src

*** Rotate Stack

This patch let's you rotate through the stack using keyboard shortcuts.

https://dwm.suckless.org/patches/rotatestack/

#+begin_src c :tangle patches.def.h
  #define ROTATESTACK_PATCH 0
#+end_src

*** Rounded Corners

This patch adds rounded corners to client windows in dwm.

You need to uncomment the corresponding line in config.mk to use the -lXext library when including this patch. You will also want to set "borderpx = 0;" in your config.h.

https://github.com/mitchweaver/suckless/blob/master/dwm/patches/mitch-06-rounded_corners-f04cac6d6e39cd9e3fc4fae526e3d1e8df5e34b2.patch

#+begin_src c :tangle patches.def.h
  #define ROUNDED_CORNERS_PATCH 0
#+end_src

*** Save Floats

This patch saves size and position of every floating window before it is forced into tiled mode. If the window is made floating again then the old dimensions will be restored.

https://dwm.suckless.org/patches/save_floats/

#+begin_src c :tangle patches.def.h
  #define SAVEFLOATS_PATCH 0
#+end_src

*** Scratch Pads

**** Main

The scratchpad patch allows you to spawn or restore floating terminal windows.

It is typically useful when one need to do some short typing.

Note that this patch changes TAGMASK to make room for special scratchpad tags, so ~0 does more than select all tags with this patch. Code that relies on ~0 to represent all tags should use ~SPTAGMASK instead.

Upgraded to Christian Tenllado's multiple scratchpad version.

https://lists.suckless.org/hackers/2004/17205.html

https://dwm.suckless.org/patches/scratchpads/

#+begin_src c :tangle patches.def.h
  #define SCRATCHPADS_PATCH 0
#+end_src

**** Keep Position And Size

Minor alteration of the above allowing clients to keep their size and position when shown.

#+begin_src c :tangle patches.def.h
  #define SCRATCHPADS_KEEP_POSITION_AND_SIZE_PATCH 0
#+end_src

**** Alternative

This alternative patch enables a scratchpad feature in dwm similar to the scratchpad feature in i3wm.

https://github.com/GasparVardanyan/dwm-scratchpad

#+begin_src c :tangle patches.def.h
  #define SCRATCHPAD_ALT_1_PATCH 0
#+end_src

*** Selective Fake Fullscreen

As opposed to the original patch this only adds a rule option allowing fake fullscreen to be enabled for applications when they start. This is intended to be used in combination with the fakefullscreenclient patch and offers no practical functionality without it.

https://dwm.suckless.org/patches/selectivefakefullscreen/

#+begin_src c :tangle patches.def.h
  #define SELECTIVEFAKEFULLSCREEN_PATCH 0
#+end_src

*** Self Restart

Allows restarting dwm without the dependency of an external script.

https://dwm.suckless.org/patches/selfrestart/

#+begin_src c :tangle patches.def.h
  #define SELFRESTART_PATCH 0
#+end_src

*** Send Monitor Keep Focus

This patch allow clients to keep focus when being sent to another monitor.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-sendmon_keepfocus-6.2.diff

#+begin_src c :tangle patches.def.h
  #define SENDMON_KEEPFOCUS_PATCH 0
#+end_src

*** Set Border Pixels

This patch allows border pixels to be changed during runtime.

https://dwm.suckless.org/patches/setborderpx/

#+begin_src c :tangle patches.def.h
  #define SETBORDERPX_PATCH 0
#+end_src

*** Shift View

**** Main

This patch adds keybindings for left and right circular shift through tags.

https://github.com/chau-bao-long/dotfiles/blob/master/suckless/dwm/shiftview.diff

#+begin_src c :tangle patches.def.h
  #define SHIFTVIEW_PATCH 0
#+end_src

**** Clients

This variant of the shiftview patch adds left and right circular shift through tags, but skips tags where there are no clients.

#+begin_src c :tangle patches.def.h
  #define SHIFTVIEW_CLIENTS_PATCH 0
#+end_src

*** Size Hints

**** Main

This patch makes dwm obey even "soft" sizehints for new clients. Any window that requests a specific initial size will be floated and set to that size.

Unlike with "fixed size" windows, you are able to resize and/or unfloat these windows freely - only the initial state is affected.

This version of the patch is honestly of limited utility since there are many clients that will abuse it.

https://dwm.suckless.org/patches/sizehints/

#+begin_src c :tangle patches.def.h
  #define SIZEHINTS_PATCH 0
#+end_src

**** Ruled

This patch makes dwm obey even "soft" sizehints for new clients. This ruled version is essentially the same patch except it obeys the "isfloating" rule if it is available in config.h for the given client.

https://dwm.suckless.org/patches/sizehints/

#+begin_src c :tangle patches.def.h
  #define SIZEHINTS_RULED_PATCH 0
#+end_src

*** Sort Screens

In a multi-head setup monitor 0 is by default the primary screen, with the left and right screen being monitor 1 and 2 respectively. This patch sorts screens left to right (or top to bottom in a vertical layout) which aims to address some inconsistencies when it comes to focusmon, tagmon and similar functionality.

https://www.mail-archive.com/hackers@suckless.org/msg09400.html

#+begin_src c :tangle patches.def.h
  #define SORTSCREENS_PATCH 0
#+end_src

*** Spawn CMD

Spawns programs from currently focused client's working directory.

https://dwm.suckless.org/patches/spawn_cwd/

#+begin_src c :tangle patches.def.h
  #define SPAWNCMD_PATCH 0
#+end_src

*** Stacker

This patch provides comprehensive utilities for managing the client stack, providing keyboard shortcuts for focusing or placing a client at specific positions in the stack.

Note that the default keybindings for this patch have been changed in dwm-flexipatch due to the many conflicts with other patches. As it provides similar functionality to the swapfocus patch it also uses the MOD+s shortcut to focus the previously selected client, thus note a conflict between these two patches.

https://dwm.suckless.org/patches/stacker/

#+begin_src c :tangle patches.def.h
  #define STACKER_PATCH 0
#+end_src

*** Steam

Steam, and steam windows (games), trigger a ConfigureNotify request every time the window gets focus. More so, the configure event passed along from Steam tends to have the wrong x and y co-ordinates which can make the window, if floating, jump around the screen.

This patch works around this age-old issue by ignoring the x and y co-ordinates for ConfigureNotify requests relating to Steam windows.

https://github.com/bakkeby/patches/wiki/steam

#+begin_src c :tangle patches.def.h
  #define STEAM_PATCH 1
#+end_src

*** Sticky

Adds toggleable keyboard shortcut to make a client 'sticky', i.e. visible on all tags.

https://dwm.suckless.org/patches/sticky/

#+begin_src c :tangle patches.def.h
  #define STICKY_PATCH 0
#+end_src

*** Swallow

This patch adds "window swallowing" to dwm as known from Plan 9's windowing system rio.

Clients marked with isterminal in config.h swallow a window opened by any child process, e.g. running xclock in a terminal. Closing the xclock window restores the terminal window in the current position.

This patch depends on the following additional libraries:
   - libxcb
   - Xlib-libxcb
   - xcb-res

You need to uncomment the corresponding line in config.mk to use the above libraries when including this patch.

https://dwm.suckless.org/patches/swallow/

#+begin_src c :tangle patches.def.h
  #define SWALLOW_PATCH 0
#+end_src

*** Swap Focus

This patch depends on the pertag patch and makes it possible to switch focus with a single shortcut (MOD+s) instead of having to think if you should use mod-j or mod-k for reaching the previously used window.

https://dwm.suckless.org/patches/swapfocus/

#+begin_src c :tangle patches.def.h
  #define SWAPFOCUS_PATCH 1
#+end_src

*** Swap Tags

This patch allows swapping the contents of the currently selected tag with another tag using keyboard shortcuts.

https://dwm.suckless.org/patches/swaptags/

#+begin_src c :tangle patches.def.h
  #define SWAPTAGS_PATCH 0
#+end_src

*** Switch Column Focus

Switch focus between the master and stack columns using a single keybinding.

https://dwm.suckless.org/patches/switchcol/

#+begin_src c :tangle patches.def.h
  #define SWITCHCOL_PATCH 0
#+end_src

***  Switch Tag

By default dwm allow you to set application specific rules so that you can have your browser, for example, start up on tag 9 optionally on a given monitor when you open your browser it is then automatically moved to the configured tag, but you have to manually enable the tag to see the newly opened application.

This patch adds an extra configuration option for individual rules where:
  0 is default behaviour
  1 automatically moves you to the tag of the newly opened application and
  2 enables the tag of the newly opened application in addition to your existing enabled tags
  3 as 1, but closing that window reverts the view back to what it was previously (*)
  4 as 2, but closing that window reverts the view back to what it was previously (*)

(*) except if the client has been moved between tags or to another monitor

https://github.com/bakkeby/patches/blob/master/dwm/dwm-switchtag-6.2.diff

Also see https://dwm.suckless.org/patches/switchtotag

#+begin_src c :tangle patches.def.h
  #define SWITCHTAG_PATCH 0
#+end_src

*** Tab
This patch transforms the monocle layout into a "tabbed" layout if more than one window is present on the monocle view. This patch has been added for demonstration purposes only and has limited compatibility with other patches. It will conflict space-wise with a second bar.

Note that fancybar, awesomebar, bartabgroups and similar patches make the tab patch redundant.

https://dwm.suckless.org/patches/tab/

#+begin_src c :tangle patches.def.h
  #define TAB_PATCH 0
#+end_src

*** Tag All

Adds keyboard shortcuts to move all (or only floating) windows from one tag to another.

https://dwm.suckless.org/patches/tagall/

#+begin_src c :tangle patches.def.h
  #define TAGALL_PATCH 0
#+end_src

*** Tag All Monitor

This patch allows you to move all visible windows on a monitor to an adjacent monitor.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-tagallmon-6.2.diff

#+begin_src c :tangle patches.def.h
  #define TAGALLMON_PATCH 0
#+end_src

*** Tag Into Stack

**** All Master

This patch makes new clients attach into the stack area when you toggle a new tag into view. This means your master area will remain unchanged when toggling views.

The allmaster patch will cause all clients in the master area to be left alone. This patch takes precedence over the onemaster tagintostack patch.

https://dwm.suckless.org/patches/tagintostack/

#+begin_src c :tangle patches.def.h
  #define TAGINTOSTACK_ALLMASTER_PATCH 0
#+end_src

**** One Master

This patch makes new clients attach into the stack area when you toggle a new tag into view. This means your master area will remain unchanged when toggling views.

The onemaster patch will cause the first client in the master area to be left alone.

https://dwm.suckless.org/patches/tagintostack/

#+begin_src c :tangle patches.def.h
  #define TAGINTOSTACK_ONEMASTER_PATCH 0
#+end_src

*** Tag Monitor Fix Fullscreen

If you try to send a fullscreen window to an adjacent monitor using tagmon then the window is moved behind the scenes, but it remains in fullscreen on the original monitor until you exit fullscreen view (at which point it will appear on the adjacent monitor). This patch allows a fullscreen window to be moved to an adjacent monitor while remaining in fullscreen.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-tagmonfixfs-6.2.diff

#+begin_src c :tangle patches.def.h
  #define TAGMONFIXFS_PATCH 1
#+end_src

*** Tag Other Monitor

Add functions and keybindings to tag a window to a desired tag on the next (right) or previous (left) monitor from the currently selected monitor.

https://dwm.suckless.org/patches/tagothermonitor/

#+begin_src c :tangle patches.def.h
  #define TAGOTHERMONITOR_PATCH 1
#+end_src

*** Tag Swap Monitor

This patch allows you to swap all visible windows on one monitor with those of an adjacent monitor.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-tagswapmon-6.2.diff

#+begin_src c :tangle patches.def.h
  #define TAGSWAPMON_PATCH 1
#+end_src

*** Tap Resize

This patch can be useful to the touchpad users because it allows to resize windows using Mod + two-finger scroll. It is useful when two-finger scrolling is configured in libinput.

https://dwm.suckless.org/patches/tapresize/

#+begin_src c :tangle patches.def.h
  #define TAPRESIZE_PATCH 0
#+end_src

*** Toggle Fullscreen

This patch allows you to toggle fullscreen on and off using a single shortcut key.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-togglefullscreen-6.2.diff

#+begin_src c :tangle patches.def.h
  #define TOGGLEFULLSCREEN_PATCH 1
#+end_src

*** Toggle Layout

Minor patch that lets you use the same keyboard shortcut to toggle to the previous layout if the designated layout is already active.

This allows you to use e.g. MOD+m to change to the monocle layout and use the same keybinding to toggle back to what it was previously. The default behaviour in dwm forces you to use either MOD+space or MOD+t to change back to tiled layout.

https://github.com/bakkeby/patches/wiki/togglelayout


#+begin_src c :tangle patches.def.h
  #define TOGGLELAYOUT_PATCH 0
#+end_src

*** Toggle Tag

Minor patch that lets you use the same keyboard shortcut to toggle to the previous tag if the designated tag is already active.

This allows you to use e.g. MOD+4 to quickly view the 4th tag and use the same keybinding to toggle back to what it was previously. The default behaviour in dwm forces you to use either MOD+tab or MOD+1 to change back to the previous tag.

Idea ref.
https://www.reddit.com/r/suckless/comments/ik27vd/key_toggle_between_next_and_previous_tag_dwm/
https://github.com/bakkeby/patches/wiki/toggletag

#+begin_src c :tangle patches.def.h
  #define TOGGLETAG_PATCH 0
#+end_src

*** Transfer

**** Main

Lets you transfer the currently focused client between the master and stack area while increasing or decreasing the master area (nmaster) accordingly.

https://dwm.suckless.org/patches/transfer/

#+begin_src c :tangle patches.def.h
  #define TRANSFER_PATCH 0
#+end_src

**** Transfer All

Lets you transfer all clients between the master and stack area while increasing or decreasing the master area (nmaster) accordingly.

https://dwm.suckless.org/patches/transfer/

#+begin_src c :tangle patches.def.h
  #define TRANSFER_ALL_PATCH 0
#+end_src

*** Unfloat Visible

This patch resets isfloating on any visible windows that have it set.

Optionally also applies a layout.

https://dwm.suckless.org/patches/unfloatvisible/

#+begin_src c :tangle patches.def.h
  #define UNFLOATVISIBLE_PATCH 1
#+end_src

*** Vanity Gaps

**** Main

This patch adds configurable gaps between windows differentiating between outer, inner, horizontal and vertical gaps.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-vanitygaps-6.2.diff

https://github.com/bakkeby/patches/blob/master/dwm/dwm-cfacts-vanitygaps-6.2.diff

#+begin_src c :tangle patches.def.h
  #define VANITYGAPS_PATCH 1
#+end_src

**** Monocle

This patch adds outer gaps for the monocle layout.

Most gaps patches tries to avoid gaps on the monocle layout, as it is often used as a fullscreen mode, hence this is enabled separately from the main vanitygaps patch.

#+begin_src c :tangle patches.def.h
  #define VANITYGAPS_MONOCLE_PATCH 0
#+end_src

*** View On Tag

Follow a window to the tag it is being moved to.

https://dwm.suckless.org/patches/viewontag/

#+begin_src c :tangle patches.def.h
  #define VIEWONTAG_PATCH 0
#+end_src

*** Warp

This patch warps the mouse cursor to the center of the currently focused window or screen when the mouse cursor is (a) on a different screen or (b) on top of a different window.

https://dwm.suckless.org/patches/warp/

#+begin_src c :tangle patches.def.h
  #define WARP_PATCH 0
#+end_src

*** Window Role Rule

Sometimes a single application opens different windows depending on the task at hand and this is often reflected in the WM_WINDOW_ROLE(STRING) x property.

This patch adds the role field to the rule configuration so that one can differentiate between, say, Firefox "browser" vs "Preferences" vs "Manager" or Google-chrome "browser" vs "pop-up".

https://github.com/bakkeby/patches/blob/master/dwm/dwm-windowrolerule-6.2.diff

#+begin_src c :tangle patches.def.h
  #define WINDOWROLERULE_PATCH 0
#+end_src

*** Window View

The winview patch allows switching the view to that of a given client from the all-window view (Mod-0) using a keyboard shortcut.

http://dwm.suckless.org/patches/winview/

#+begin_src c :tangle patches.def.h
  #define WINVIEW_PATCH 0
#+end_src

*** X Keyboard

Remember keyboard layout per client.

It is recommended that you configure xkb before using this patch as described in https://www.x.org/archive/X11R7.5/doc/input/XKB-Config.html

https://dwm.suckless.org/patches/xkb/

#+begin_src c :tangle patches.def.h
  #define XKB_PATCH 0
#+end_src

*** XRDB

Allows dwm to read colors from xrdb (.Xresources) during runtime. Compatible with the float border color, awesomebar, urgentborder and titlecolor patches.

https://dwm.suckless.org/patches/xrdb/

#+begin_src c :tangle patches.def.h
  #define XRDB_PATCH 1
#+end_src

*** Zoom Floating

Simple patch that allows floating windows to be zoomed into the master stack position.

https://www.reddit.com/r/suckless/comments/ie5fe3/zoomfloating_my_own_simple_original_patch/

#+begin_src c :tangle patches.def.h
  #define ZOOMFLOATING_PATCH 0
#+end_src

*** Zoom Swap

The zoomswap patch allows a master and a stack window to swap places rather than every window on the screen changing position.

https://dwm.suckless.org/patches/zoomswap/

#+begin_src c :tangle patches.def.h
  #define ZOOMSWAP_PATCH 0
#+end_src

** Layouts

*** Bottomstack

**** Main

Bottomstack layout.

https://dwm.suckless.org/patches/bottomstack/

#+begin_src c :tangle patches.def.h
  #define BSTACK_LAYOUT 0
#+end_src

**** Horizontal

Bottomstack horizontal layout.

https://dwm.suckless.org/patches/bottomstack/

#+begin_src c :tangle patches.def.h
  #define BSTACKHORIZ_LAYOUT 0
#+end_src

*** Centered Master

**** Main

Centered master layout.

https://dwm.suckless.org/patches/centeredmaster/

#+begin_src c :tangle patches.def.h
  #define CENTEREDMASTER_LAYOUT 0
#+end_src

**** Floating

Centered floating master layout.

https://dwm.suckless.org/patches/centeredmaster/

#+begin_src c :tangle patches.def.h
  #define CENTEREDFLOATINGMASTER_LAYOUT 0
#+end_src

*** Columns

Same as the default tile layout except clients in the master area are arranged in columns (i.e. left to right).

https://dwm.suckless.org/patches/columns/

#+begin_src c :tangle patches.def.h
  #define COLUMNS_LAYOUT 0
#+end_src

*** Deck

Deck layout.

https://dwm.suckless.org/patches/deck/

#+begin_src c :tangle patches.def.h
  #define DECK_LAYOUT 0
#+end_src

*** Fibonacci

**** Dwindle

Fibonacci dwindle layout.

https://dwm.suckless.org/patches/fibonacci/

#+begin_src c :tangle patches.def.h
  #define FIBONACCI_DWINDLE_LAYOUT 0
#+end_src

**** Spiral

Fibonacci spiral layout.

https://dwm.suckless.org/patches/fibonacci/

#+begin_src c :tangle patches.def.h
  #define FIBONACCI_SPIRAL_LAYOUT 0
#+end_src

*** Flextile

Flextile deluxe layout.

A revamped, more flexible, and over-the-top version of the original flextile layout.

https://dwm.suckless.org/patches/flextile/ (original)

#+begin_src c :tangle patches.def.h
  #define FLEXTILE_DELUXE_LAYOUT 0
#+end_src

*** Grid

**** Main

Gridmode (grid) layout.

https://dwm.suckless.org/patches/gridmode/

#+begin_src c :tangle patches.def.h
  #define GRIDMODE_LAYOUT 1
#+end_src

**** Gapless

Gappless grid layout.

https://dwm.suckless.org/patches/gaplessgrid/

#+begin_src c :tangle patches.def.h
  #define GAPPLESSGRID_LAYOUT 0
#+end_src

**** Horizontal

Horizontal grid (horizgrid) layout.

https://dwm.suckless.org/patches/horizgrid/

#+begin_src c :tangle patches.def.h
  #define HORIZGRID_LAYOUT 0
#+end_src

**** N Row

Grid layout where nmaster controls the number of rows.

https://dwm.suckless.org/patches/nrowgrid/

#+begin_src c :tangle patches.def.h
  #define NROWGRID_LAYOUT 0
#+end_src

*** Tile

The default tile layout.

This can be optionally disabled in favour of other layouts.

#+begin_src c :tangle patches.def.h
  #define TILE_LAYOUT 1
#+end_src

*** Monocle

Monocle layout (default).

This can be optionally disabled in favour of other layouts.

#+begin_src c :tangle patches.def.h
  #define MONOCLE_LAYOUT 1
#+end_src

* Build System Settings

** Make Config

#+begin_src makefile :tangle config.jk
  # dwm version
  VERSION = 6.2

  # Customize below to fit your system

  # paths
  PREFIX = /usr/local
  MANPREFIX = ${PREFIX}/share/man

  X11INC = /usr/X11R6/include
  X11LIB = /usr/X11R6/lib

  # FreeBSD (uncomment)
  #X11INC = /usr/local/include
  #X11LIB = /usr/local/lib

  # Xinerama, comment if you don't want it
  XINERAMALIBS  = -lXinerama
  XINERAMAFLAGS = -DXINERAMA

  # freetype
  FREETYPELIBS = -lfontconfig -lXft
  FREETYPEINC = /usr/include/freetype2
  # FreeBSD (uncomment)
  #FREETYPEINC = /usr/local/include/freetype2
  # OpenBSD (uncomment)
  #FREETYPEINC = ${X11INC}/freetype2
  # OpenBSD - Uncomment this for the swallow patch / SWALLOW_PATCH
  #KVMLIB = -lkvm

  # Uncomment this for the alpha patch / BAR_ALPHA_PATCH
  #XRENDER = -lXrender

  # Uncomment this for the mdpcontrol patch / MDPCONTROL_PATCH
  #MPDCLIENT = -lmpdclient

  # Uncomment for the pango patch / BAR_PANGO_PATCH
  #PANGOINC = `pkg-config --cflags xft pango pangoxft`
  #PANGOLIB = `pkg-config --libs xft pango pangoxft`

  # Uncomment for the ipc patch / IPC_PATCH
  YAJLLIBS = -lyajl
  YAJLINC = -I/usr/include/yajl

  # Uncomment this for the rounded corners patch / ROUNDED_CORNERS_PATCH
  #XEXTLIB = -lXext

  # Uncomment this for the swallow patch / SWALLOW_PATCH
  # XCBLIBS = -lX11-xcb -lxcb -lxcb-res

  # includes and libs
  INCS = -I${X11INC} -I${FREETYPEINC} ${YAJLINC} ${PANGOINC}
  LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}  ${XRENDER} ${MPDCLIENT} ${XEXTLIB} ${XCBLIBS} ${KVMLIB} ${PANGOLIB} ${YAJLLIBS}

  # flags
  CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_POSIX_C_SOURCE=200809L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
  #CFLAGS   = -g -std=c99 -pedantic -Wall -O0 ${INCS} ${CPPFLAGS}
  CFLAGS   = -std=c99 -pedantic -Wall -Wno-deprecated-declarations -Os ${INCS} ${CPPFLAGS}
  LDFLAGS  = ${LIBS}

  # Solaris
  #CFLAGS = -fast ${INCS} -DVERSION=\"${VERSION}\"
  #LDFLAGS = ${LIBS}

  # compiler and linker
  CC = cc
#+end_src

** Makefile

#+begin_src makefile :tangle Makefile
  # dwm - dynamic window manager
  # See LICENSE file for copyright and license details.

  include config.mk

  SRC = drw.c dwm.c util.c
  OBJ = ${SRC:.c=.o}

  # FreeBSD users, prefix all ifdef, else and endif statements with a . for this to work (e.g. .ifdef)

  ifdef YAJLLIBS
  all: options dwm dwm-msg
  else
  all: options dwm
  endif

  options:
	  @echo dwm build options:
	  @echo "CFLAGS	= ${CFLAGS}"
	  @echo "LDFLAGS	= ${LDFLAGS}"
	  @echo "CC	= ${CC}"

  .c.o:
	  ${CC} -c ${CFLAGS} $<

  ${OBJ}: config.h config.mk patches.h

  config.h:
	  cp config.def.h $@

  patches.h:
	  cp patches.def.h $@

  dwm: ${OBJ}
	  ${CC} -o $@ ${OBJ} ${LDFLAGS}

  ifdef YAJLLIBS
  dwm-msg:
	  ${CC} -o $@ patch/ipc/dwm-msg.c ${LDFLAGS}
  endif

  clean:
	  rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz
	  rm -f dwm-msg
	  rm -f config.h
	  rm -f patches.h

  dist: clean
	  mkdir -p dwm-${VERSION}
	  cp -R LICENSE Makefile README config.def.h config.mk\
		  dwm.1 drw.h util.h ${SRC} dwm.png transient.c dwm-${VERSION}
	  tar -cf dwm-${VERSION}.tar dwm-${VERSION}
	  gzip dwm-${VERSION}.tar
	  rm -rf dwm-${VERSION}

  install: all
	  mkdir -p ${DESTDIR}${PREFIX}/bin
	  cp -f dwm ${DESTDIR}${PREFIX}/bin
  ifdef YAJLLIBS
	  cp -f dwm-msg ${DESTDIR}${PREFIX}/bin
  endif
	  cp -f patch/dwmc ${DESTDIR}${PREFIX}/bin
	  chmod 755 ${DESTDIR}${PREFIX}/bin/dwm
  ifdef YAJLLIBS
	  chmod 755 ${DESTDIR}${PREFIX}/bin/dwm-msg
  endif
	  mkdir -p ${DESTDIR}${MANPREFIX}/man1
	  sed "s/VERSION/${VERSION}/g" < dwm.1 > ${DESTDIR}${MANPREFIX}/man1/dwm.1
	  chmod 644 ${DESTDIR}${MANPREFIX}/man1/dwm.1

  uninstall:
	  rm -f ${DESTDIR}${PREFIX}/bin/dwm\
		  ${DESTDIR}${MANPREFIX}/man1/dwm.1

  .PHONY: all options clean dist install uninstall
#+end_src

* DWM Configuration

** Appearance

#+begin_src c :tangle config.def.h
  #if ROUNDED_CORNERS_PATCH
  static const unsigned int borderpx       = 0;   /* border pixel of windows */
  static const int corner_radius           = 10;
  #else
  static const unsigned int borderpx       = 2;   /* border pixel of windows */
  #endif // ROUNDED_CORNERS_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  static const unsigned int snap           = 10;  /* snap pixel */
#+end_src

#+begin_src c :tangle config.def.h
  #if SWALLOW_PATCH
  static const int swallowfloating         = 0;   /* 1 means swallow floating windows by default */
  #endif // SWALLOW_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if NO_MOD_BUTTONS_PATCH
  static int nomodbuttons                  = 1;   /* allow client mouse button bindings that have no modifier */
  #endif // NO_MOD_BUTTONS_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if VANITYGAPS_PATCH
  static const unsigned int gappih         = 20;  /* horiz inner gap between windows */
  static const unsigned int gappiv         = 20;  /* vert inner gap between windows */
  static const unsigned int gappoh         = 30;  /* horiz outer gap between windows and screen edge */
  static const unsigned int gappov         = 30;  /* vert outer gap between windows and screen edge */
  static const int smartgaps_fact          = 1;   /* gap factor when there is only one client; 0 = no gaps, 3 = 3x outer gaps */
  #endif // VANITYGAPS_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if AUTOSTART_PATCH
  static const char autostartblocksh[]     = "autostart_blocking.sh";
  static const char autostartsh[]          = "autostart.sh";
  static const char dwmdir[]               = "dwm";
  static const char localshare[]           = ".local/share";
  #endif // AUTOSTART_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_ANYBAR_PATCH
  static const int usealtbar               = 1;        /* 1 means use non-dwm status bar */
  static const char *altbarclass           = "Polybar"; /* Alternate bar class name */
  static const char *altbarcmd             = "/home/sravan/.config/dwm-flexipatch/polybar/launch.sh"; /* Alternate bar launch command */
  #endif // BAR_ANYBAR_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_HOLDBAR_PATCH
  static const int showbar                 = 0;   /* 0 means no bar */
  #else
  static const int showbar                 = 1;   /* 0 means no bar */
  #endif // BAR_HOLDBAR_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  static const int topbar                  = 1;   /* 0 means bottom bar */
#+end_src

#+begin_src c :tangle config.def.h
  #if TAB_PATCH
  /*  Display modes of the tab bar: never shown, always shown, shown only in  */
  /*  monocle mode in the presence of several windows.                        */
  /*  Modes after showtab_nmodes are disabled.                                */
  enum showtab_modes { showtab_never, showtab_auto, showtab_nmodes, showtab_always};
  static const int showtab                 = showtab_auto;        /* Default tab bar show mode */
  static const int toptab                  = False;               /* False means bottom tab bar */
  #endif // TAB_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_HEIGHT_PATCH
  static const int bar_height              = 0;   /* 0 means derive from font, >= 1 explicit height */
  #endif // BAR_HEIGHT_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_PADDING_PATCH
  static const int vertpad                 = 10;  /* vertical padding of bar */
  static const int sidepad                 = 10;  /* horizontal padding of bar */
  #endif // BAR_PADDING_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_WINICON_PATCH
  #define ICONSIZE 20    /* icon size */
  #define ICONSPACING 5  /* space between icon and title */
  #endif // BAR_WINICON_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if FOCUSONCLICK_PATCH
  static const int focusonwheel            = 0;
  #endif // FOCUSONCLICK_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if FLOATPOS_PATCH
  static int floatposgrid_x                = 5;  /* float grid columns */
  static int floatposgrid_y                = 5;  /* float grid rows */
  #endif // FLOATPOS_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if RIODRAW_PATCH
  static const char slopspawnstyle[]       = "-t 0 -c 0.92,0.85,0.69,0.3 -o"; /* do NOT define -f (format) here */
  static const char slopresizestyle[]      = "-t 0 -c 0.92,0.85,0.69,0.3"; /* do NOT define -f (format) here */
  static const int riodraw_borders         = 0;  /* 0 or 1, indicates whether the area drawn using slop includes the window borders */
  #if SWALLOW_PATCH
  static const int riodraw_matchpid        = 1;  /* 0 or 1, indicates whether to match the PID of the client that was spawned with riospawn */
  #endif // SWALLOW_PATCH
  #endif // RIODRAW_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_STATUSPADDING_PATCH
  static const int horizpadbar             = 2;   /* horizontal padding for statusbar */
  static const int vertpadbar              = 0;   /* vertical padding for statusbar */
  #endif // BAR_STATUSPADDING_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_STATUSBUTTON_PATCH
  static const char buttonbar[]            = "<O>";
  #endif // BAR_STATUSBUTTON_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_SYSTRAY_PATCH
  static const unsigned int systrayspacing = 2;   /* systray spacing */
  static const int showsystray             = 1;   /* 0 means no systray */
  #endif // BAR_SYSTRAY_PATCH
#+end_src

** Indicators

See patch/bar_indicators.h for options

#+begin_src c :tangle config.def.h
  static int tagindicatortype              = INDICATOR_TOP_LEFT_SQUARE;
  static int tiledindicatortype            = INDICATOR_NONE;
  static int floatindicatortype            = INDICATOR_TOP_LEFT_SQUARE;
#+end_src

#+begin_src c :tangle config.def.h
  #if FAKEFULLSCREEN_CLIENT_PATCH && !FAKEFULLSCREEN_PATCH
  static int fakefsindicatortype           = INDICATOR_PLUS;
  static int floatfakefsindicatortype      = INDICATOR_PLUS_AND_LARGER_SQUARE;
  #endif // FAKEFULLSCREEN_CLIENT_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if ONLYQUITONEMPTY_PATCH
  static const int quit_empty_window_count = 2;   /* only allow dwm to quit if no windows are open, value here represents number of deamons */
  #endif // ONLYQUITONEMPTY_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_EXTRASTATUS_PATCH
  static const char statussep              = ';'; /* separator between status bars */
  #endif // BAR_EXTRASTATUS_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_TABGROUPS_PATCH
  #if MONOCLE_LAYOUT
  static void (*bartabmonfns[])(Monitor *) = { monocle /* , customlayoutfn */ };
  #else
  static void (*bartabmonfns[])(Monitor *) = { NULL /* , customlayoutfn */ };
  #endif // MONOCLE_LAYOUT
  #endif // BAR_TABGROUPS_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_PANGO_PATCH
  static const char font[]                 = "monospace 10";
  #else
  static const char *fonts[]               = { "monospace:size=10" };
  #endif // BAR_PANGO_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  static const char dmenufont[]            = "monospace:size=10";
#+end_src

#+begin_src c :tangle config.def.h
  static char c000000[]                    = "#000000"; // placeholder value
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_FLEXWINTITLE_PATCH
  #endif // BAR_FLEXWINTITLE_PATCH
#+end_src

** Colors

*** Define Colors

#+begin_src c :tangle config.def.h
  static char normfgcolor[]                = "#F8F8F2";
  static char normbgcolor[]                = "#282A36";
  static char normbordercolor[]            = "#4D4D4D";
  static char normfloatcolor[]             = "#6272A4";

  static char selfgcolor[]                 = "#282A36";
  static char selbgcolor[]                 = "#BD93F9";
  static char selbordercolor[]             = "#BD93F9";
  static char selfloatcolor[]              = "#FF79C6";

  static char titlenormfgcolor[]           = "#bbbbbb";
  static char titlenormbgcolor[]           = "#222222";
  static char titlenormbordercolor[]       = "#444444";
  static char titlenormfloatcolor[]        = "#db8fd9";

  static char titleselfgcolor[]            = "#eeeeee";
  static char titleselbgcolor[]            = "#005577";
  static char titleselbordercolor[]        = "#005577";
  static char titleselfloatcolor[]         = "#005577";

  static char tagsnormfgcolor[]            = "#bbbbbb";
  static char tagsnormbgcolor[]            = "#222222";
  static char tagsnormbordercolor[]        = "#444444";
  static char tagsnormfloatcolor[]         = "#db8fd9";

  static char tagsselfgcolor[]             = "#eeeeee";
  static char tagsselbgcolor[]             = "#005577";
  static char tagsselbordercolor[]         = "#005577";
  static char tagsselfloatcolor[]          = "#005577";

  static char hidnormfgcolor[]             = "#005577";
  static char hidselfgcolor[]              = "#227799";
  static char hidnormbgcolor[]             = "#222222";
  static char hidselbgcolor[]              = "#222222";

  static char urgfgcolor[]                 = "#F8F8F2";
  static char urgbgcolor[]                 = "#282A36";
  static char urgbordercolor[]             = "#FF5555";
  static char urgfloatcolor[]              = "#FF5555";
#+end_src

*** Bar Flex Win Title

#+begin_src c :tangle config.def.h
  #if BAR_FLEXWINTITLE_PATCH
  static char normTTBbgcolor[]             = "#330000";
  static char normLTRbgcolor[]             = "#330033";
  static char normMONObgcolor[]            = "#000033";
  static char normGRIDbgcolor[]            = "#003300";
  static char normGRD1bgcolor[]            = "#003300";
  static char normGRD2bgcolor[]            = "#003300";
  static char normGRDMbgcolor[]            = "#506600";
  static char normHGRDbgcolor[]            = "#b96600";
  static char normDWDLbgcolor[]            = "#003333";
  static char normSPRLbgcolor[]            = "#333300";
  static char normfloatbgcolor[]           = "#115577";
  static char actTTBbgcolor[]              = "#440000";
  static char actLTRbgcolor[]              = "#440044";
  static char actMONObgcolor[]             = "#000044";
  static char actGRIDbgcolor[]             = "#004400";
  static char actGRD1bgcolor[]             = "#004400";
  static char actGRD2bgcolor[]             = "#004400";
  static char actGRDMbgcolor[]             = "#507711";
  static char actHGRDbgcolor[]             = "#b97711";
  static char actDWDLbgcolor[]             = "#004444";
  static char actSPRLbgcolor[]             = "#444400";
  static char actfloatbgcolor[]            = "#116688";
  static char selTTBbgcolor[]              = "#550000";
  static char selLTRbgcolor[]              = "#550055";
  static char selMONObgcolor[]             = "#212171";
  static char selGRIDbgcolor[]             = "#005500";
  static char selGRD1bgcolor[]             = "#005500";
  static char selGRD2bgcolor[]             = "#005500";
  static char selGRDMbgcolor[]             = "#508822";
  static char selHGRDbgcolor[]             = "#b98822";
  static char selDWDLbgcolor[]             = "#005555";
  static char selSPRLbgcolor[]             = "#555500";
  static char selfloatbgcolor[]            = "#117799";
  #endif // BAR_FLEXWINTITLE_PATCH
#+end_src

*** Bar Alpha

#+begin_src c :tangle config.def.h
  #if BAR_ALPHA_PATCH
  static const unsigned int baralpha = 0xd0;
  static const unsigned int borderalpha = OPAQUE;
  static const unsigned int alphas[][3] = {
          /*                       fg      bg        border     */
          [SchemeNorm]         = { OPAQUE, baralpha, borderalpha },
          [SchemeSel]          = { OPAQUE, baralpha, borderalpha },
          [SchemeTitleNorm]    = { OPAQUE, baralpha, borderalpha },
          [SchemeTitleSel]     = { OPAQUE, baralpha, borderalpha },
          [SchemeTagsNorm]     = { OPAQUE, baralpha, borderalpha },
          [SchemeTagsSel]      = { OPAQUE, baralpha, borderalpha },
          [SchemeHidNorm]      = { OPAQUE, baralpha, borderalpha },
          [SchemeHidSel]       = { OPAQUE, baralpha, borderalpha },
          [SchemeUrg]          = { OPAQUE, baralpha, borderalpha },
          #if BAR_FLEXWINTITLE_PATCH
          [SchemeFlexActTTB]   = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexActLTR]   = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexActMONO]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexActGRID]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexActGRD1]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexActGRD2]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexActGRDM]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexActHGRD]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexActDWDL]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexActSPRL]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexActFloat] = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexInaTTB]   = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexInaLTR]   = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexInaMONO]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexInaGRID]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexInaGRD1]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexInaGRD2]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexInaGRDM]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexInaHGRD]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexInaDWDL]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexInaSPRL]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexInaFloat] = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexSelTTB]   = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexSelLTR]   = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexSelMONO]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexSelGRID]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexSelGRD1]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexSelGRD2]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexSelGRDM]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexSelHGRD]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexSelDWDL]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexSelSPRL]  = { OPAQUE, baralpha, borderalpha },
          [SchemeFlexSelFloat] = { OPAQUE, baralpha, borderalpha },
          #endif // BAR_FLEXWINTITLE_PATCH
  };
  #endif // BAR_ALPHA_PATCH
#+end_src

*** VT Colors

#+begin_src c :tangle config.def.h
  #if BAR_VTCOLORS_PATCH
  static const char title_bg_dark[]   = "#303030";
  static const char title_bg_light[]  = "#fdfdfd";
  static const int color_ptrs[][ColCount] = {
          /*                       fg      bg      border  float */
          [SchemeNorm]         = { -1,     -1,     5,      12 },
          [SchemeSel]          = { -1,     -1,     11,     13 },
          [SchemeTitleNorm]    = { 6,      -1,     -1,     -1 },
          [SchemeTitleSel]     = { 6,      -1,     -1,     -1 },
          [SchemeTagsNorm]     = { 2,      0,      0,      -1 },
          [SchemeTagsSel]      = { 6,      5,      5,      -1 },
          [SchemeHidNorm]      = { 5,      0,      0,      -1 },
          [SchemeHidSel]       = { 6,      -1,     -1,     -1 },
          [SchemeUrg]          = { 7,      9,      9,      15 },
  };
  #endif // BAR_VTCOLORS_PATCH
#+end_src

*** Set Colors

#+begin_src c :tangle config.def.h
  static char *colors[][ColCount] = {
          /*                       fg                bg                border                float */
          [SchemeNorm]         = { normfgcolor,      normbgcolor,      normbordercolor,      normfloatcolor },
          [SchemeSel]          = { selfgcolor,       selbgcolor,       selbordercolor,       selfloatcolor },
          [SchemeTitleNorm]    = { titlenormfgcolor, titlenormbgcolor, titlenormbordercolor, titlenormfloatcolor },
          [SchemeTitleSel]     = { titleselfgcolor,  titleselbgcolor,  titleselbordercolor,  titleselfloatcolor },
          [SchemeTagsNorm]     = { tagsnormfgcolor,  tagsnormbgcolor,  tagsnormbordercolor,  tagsnormfloatcolor },
          [SchemeTagsSel]      = { tagsselfgcolor,   tagsselbgcolor,   tagsselbordercolor,   tagsselfloatcolor },
          [SchemeHidNorm]      = { hidnormfgcolor,   hidnormbgcolor,   c000000,              c000000 },
          [SchemeHidSel]       = { hidselfgcolor,    hidselbgcolor,    c000000,              c000000 },
          [SchemeUrg]          = { urgfgcolor,       urgbgcolor,       urgbordercolor,       urgfloatcolor },
          #if BAR_FLEXWINTITLE_PATCH
          [SchemeFlexActTTB]   = { titleselfgcolor,  actTTBbgcolor,    actTTBbgcolor,        c000000 },
          [SchemeFlexActLTR]   = { titleselfgcolor,  actLTRbgcolor,    actLTRbgcolor,        c000000 },
          [SchemeFlexActMONO]  = { titleselfgcolor,  actMONObgcolor,   actMONObgcolor,       c000000 },
          [SchemeFlexActGRID]  = { titleselfgcolor,  actGRIDbgcolor,   actGRIDbgcolor,       c000000 },
          [SchemeFlexActGRD1]  = { titleselfgcolor,  actGRD1bgcolor,   actGRD1bgcolor,       c000000 },
          [SchemeFlexActGRD2]  = { titleselfgcolor,  actGRD2bgcolor,   actGRD2bgcolor,       c000000 },
          [SchemeFlexActGRDM]  = { titleselfgcolor,  actGRDMbgcolor,   actGRDMbgcolor,       c000000 },
          [SchemeFlexActHGRD]  = { titleselfgcolor,  actHGRDbgcolor,   actHGRDbgcolor,       c000000 },
          [SchemeFlexActDWDL]  = { titleselfgcolor,  actDWDLbgcolor,   actDWDLbgcolor,       c000000 },
          [SchemeFlexActSPRL]  = { titleselfgcolor,  actSPRLbgcolor,   actSPRLbgcolor,       c000000 },
          [SchemeFlexActFloat] = { titleselfgcolor,  actfloatbgcolor,  actfloatbgcolor,      c000000 },
          [SchemeFlexInaTTB]   = { titlenormfgcolor, normTTBbgcolor,   normTTBbgcolor,       c000000 },
          [SchemeFlexInaLTR]   = { titlenormfgcolor, normLTRbgcolor,   normLTRbgcolor,       c000000 },
          [SchemeFlexInaMONO]  = { titlenormfgcolor, normMONObgcolor,  normMONObgcolor,      c000000 },
          [SchemeFlexInaGRID]  = { titlenormfgcolor, normGRIDbgcolor,  normGRIDbgcolor,      c000000 },
          [SchemeFlexInaGRD1]  = { titlenormfgcolor, normGRD1bgcolor,  normGRD1bgcolor,      c000000 },
          [SchemeFlexInaGRD2]  = { titlenormfgcolor, normGRD2bgcolor,  normGRD2bgcolor,      c000000 },
          [SchemeFlexInaGRDM]  = { titlenormfgcolor, normGRDMbgcolor,  normGRDMbgcolor,      c000000 },
          [SchemeFlexInaHGRD]  = { titlenormfgcolor, normHGRDbgcolor,  normHGRDbgcolor,      c000000 },
          [SchemeFlexInaDWDL]  = { titlenormfgcolor, normDWDLbgcolor,  normDWDLbgcolor,      c000000 },
          [SchemeFlexInaSPRL]  = { titlenormfgcolor, normSPRLbgcolor,  normSPRLbgcolor,      c000000 },
          [SchemeFlexInaFloat] = { titlenormfgcolor, normfloatbgcolor, normfloatbgcolor,     c000000 },
          [SchemeFlexSelTTB]   = { titleselfgcolor,  selTTBbgcolor,    selTTBbgcolor,        c000000 },
          [SchemeFlexSelLTR]   = { titleselfgcolor,  selLTRbgcolor,    selLTRbgcolor,        c000000 },
          [SchemeFlexSelMONO]  = { titleselfgcolor,  selMONObgcolor,   selMONObgcolor,       c000000 },
          [SchemeFlexSelGRID]  = { titleselfgcolor,  selGRIDbgcolor,   selGRIDbgcolor,       c000000 },
          [SchemeFlexSelGRD1]  = { titleselfgcolor,  selGRD1bgcolor,   selGRD1bgcolor,       c000000 },
          [SchemeFlexSelGRD2]  = { titleselfgcolor,  selGRD2bgcolor,   selGRD2bgcolor,       c000000 },
          [SchemeFlexSelGRDM]  = { titleselfgcolor,  selGRDMbgcolor,   selGRDMbgcolor,       c000000 },
          [SchemeFlexSelHGRD]  = { titleselfgcolor,  selHGRDbgcolor,   selHGRDbgcolor,       c000000 },
          [SchemeFlexSelDWDL]  = { titleselfgcolor,  selDWDLbgcolor,   selDWDLbgcolor,       c000000 },
          [SchemeFlexSelSPRL]  = { titleselfgcolor,  selSPRLbgcolor,   selSPRLbgcolor,       c000000 },
          [SchemeFlexSelFloat] = { titleselfgcolor,  selfloatbgcolor,  selfloatbgcolor,      c000000 },
          #endif // BAR_FLEXWINTITLE_PATCH
  };
#+end_src

*** Powerline

#+begin_src c :tangle config.def.h
  #if BAR_POWERLINE_STATUS_PATCH
  static char *statuscolors[][ColCount] = {
          /*                       fg                bg                border                float */
          [SchemeNorm]         = { normfgcolor,      normbgcolor,      normbordercolor,      normfloatcolor },
          [SchemeSel]          = { selfgcolor,       selbgcolor,       selbordercolor,       selfloatcolor },
          [SchemeTitleNorm]    = { titlenormfgcolor, titlenormbgcolor, titlenormbordercolor, titlenormfloatcolor },
          [SchemeTitleSel]     = { titleselfgcolor,  titleselbgcolor,  titleselbordercolor,  titleselfloatcolor },
          [SchemeTagsNorm]     = { tagsnormfgcolor,  tagsnormbgcolor,  tagsnormbordercolor,  tagsnormfloatcolor },
          [SchemeTagsSel]      = { tagsselfgcolor,   tagsselbgcolor,   tagsselbordercolor,   tagsselfloatcolor },
          [SchemeHidNorm]      = { hidnormfgcolor,   hidnormbgcolor,   c000000,              c000000 },
          [SchemeHidSel]       = { hidselfgcolor,    hidselbgcolor,    c000000,              c000000 },
          [SchemeUrg]          = { urgfgcolor,       urgbgcolor,       urgbordercolor,       urgfloatcolor },
  };
  #endif // BAR_POWERLINE_STATUS_PATCH
#+end_src

** Layout Menu

#+begin_src c :tangle config.def.h
  #if BAR_LAYOUTMENU_PATCH
  static const char *layoutmenu_cmd = "layoutmenu.sh";
  #endif
#+end_src

** Autostart

#+begin_src c :tangle config.def.h
  #if COOL_AUTOSTART_PATCH
  static const char *const autostart[] = {
          "st", NULL,
          NULL /* terminate */
  };
  #endif // COOL_AUTOSTART_PATCH
#+end_src

** Scratchpads

#+begin_src c :tangle config.def.h
  #if SCRATCHPADS_PATCH
  const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
  static Sp scratchpads[] = {
     /* name          cmd  */
     {"spterm",      spcmd1},
  };
  #endif // SCRATCHPADS_PATCH
#+end_src

** Tags

In a traditional dwm the number of tags in use can be changed simply by changing the number of strings in the tags array. This build does things a bit different which has some added benefits. If you need to change the number of tags here then change the NUMTAGS macro in dwm.c.

Examples:

#+begin_example
  1) static char *tagicons[][NUMTAGS*2] = {
         [DEFAULT_TAGS] = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I" },
     }

  2) static char *tagicons[][1] = {
         [DEFAULT_TAGS] = { "" },
     }
#+end_example

The first example would result in the tags on the first monitor to be 1 through 9, while the tags for the second monitor would be named A through I. A third monitor would start again at 1 through 9 while the tags on a fourth monitor would also be named A through I. Note the tags count of NUMTAGS*2 in the array initialiser which defines how many tag text / icon exists in the array. This can be changed to *3 to add separate icons for a third monitor.

For the second example each tag would be represented as a bullet point. Both cases work the same from a technical standpoint - the icon index is derived from the tag index and the monitor index. If the icon index is is greater than the number of tag icons then it will wrap around until it an icon matches. Similarly if there are two tag icons then it would alternate between them. This works seamlessly with alternative tags and alttagsdecoration patches.

#+begin_src c :tangle config.def.h
  static char *tagicons[][NUMTAGS] = {
          /* [DEFAULT_TAGS]        = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }, */
          [DEFAULT_TAGS]        = { " ", " ", " ", " ", " ", " ", " ", " ", " " },
          [ALTERNATIVE_TAGS]    = { "A", "B", "C", "D", "E", "F", "G", "H", "I" },
          [ALT_TAGS_DECORATION] = { "<1>", "<2>", "<3>", "<4>", "<5>", "<6>", "<7>", "<8>", "<9>" },
  };
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_TAGGRID_PATCH
  /* grid of tags */
  #define SWITCHTAG_UP                1 << 0
  #define SWITCHTAG_DOWN              1 << 1
  #define SWITCHTAG_LEFT              1 << 2
  #define SWITCHTAG_RIGHT             1 << 3
  #define SWITCHTAG_TOGGLETAG         1 << 4
  #define SWITCHTAG_TAG               1 << 5
  #define SWITCHTAG_VIEW              1 << 6
  #define SWITCHTAG_TOGGLEVIEW        1 << 7

  static const int tagrows = 2;
  #endif // BAR_TAGGRID_PATCH
#+end_src

** Rules

*** Window Rules

There are two options when it comes to per-client rules:
  - a typical struct table or
  - using the RULE macro

A traditional struct table looks like this:

#+begin_example
  // class      instance  title  wintype  tags mask  isfloating  monitor
  { "Gimp",     NULL,     NULL,  NULL,    1 << 4,    0,          -1 },
  { "Firefox",  NULL,     NULL,  NULL,    1 << 7,    0,          -1 },
#+end_example

The RULE macro has the default values set for each field allowing you to only specify the values that are relevant for your rule, e.g.

#+begin_example
  RULE(.class = "Gimp", .tags = 1 << 4)
  RULE(.class = "Firefox", .tags = 1 << 7)
#+end_example

Refer to the Rule struct definition for the list of available fields depending on the patches you enable.

#+begin_example
  xprop(1):
          WM_CLASS(STRING) = instance, class
          WM_NAME(STRING) = title
          WM_WINDOW_ROLE(STRING) = role
          _NET_WM_WINDOW_TYPE(ATOM) = wintype
#+end_example

#+begin_src c :tangle config.def.h
  static const Rule rules[] = {
          RULE(.wintype = WTYPE "DIALOG", .isfloating = 1)
          RULE(.wintype = WTYPE "UTILITY", .isfloating = 1)
          RULE(.wintype = WTYPE "TOOLBAR", .isfloating = 1)
          RULE(.wintype = WTYPE "SPLASH", .isfloating = 1)
          RULE(.title = "Origin", .isfloating = 1)
          RULE(.title = "Picture in picture", .isfloating = 1)
          #if SCRATCHPADS_PATCH
          RULE(.instance = "spterm", .tags = SPTAG(0), .isfloating = 1)
          #endif // SCRATCHPADS_PATCH
  };
#+end_src

*** Monitor & Tag Rules

#+begin_src c :tangle config.def.h
  #if MONITOR_RULES_PATCH
  #if PERTAG_PATCH
  static const MonitorRule monrules[] = {
          /* monitor  tag   layout  mfact  nmaster  showbar  topbar */
          {  1,       -1,   2,      -1,    -1,      -1,      -1     }, // use a different layout for the second monitor
          {  -1,      -1,   0,      -1,    -1,      -1,      -1     }, // default
  };
  #else
  static const MonitorRule monrules[] = {
          /* monitor  layout  mfact  nmaster  showbar  topbar */
          {  1,       2,      -1,    -1,      -1,      -1     }, // use a different layout for the second monitor
          {  -1,      0,      -1,    -1,      -1,      -1     }, // default
  };
  #endif // PERTAG_PATCH
  #endif // MONITOR_RULES_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if INSETS_PATCH
  static const Inset default_inset = {
          .x = 0,
          .y = 30,
          .w = 0,
          .h = 0,
  };
  #endif // INSETS_PATCH
#+end_src

*** Bar Rules

Bar rules allow you to configure what is shown where on the bar, as well as introducing your own bar modules.

monitor:
  -1  show on all monitors
   0  show on monitor 0
  'A' show on active monitor (i.e. focused / selected) (or just -1 for active?)

bar - bar index, 0 is default, 1 is extrabar

alignment - how the module is aligned compared to other modules

widthfunc, drawfunc, clickfunc - providing bar module width, draw and click functions

name - does nothing, intended for visual clue and for logging / debugging

#+begin_src c :tangle config.def.h
  static const BarRule barrules[] = {
          /* monitor  bar    alignment         widthfunc                drawfunc                clickfunc                name */
          { -2 },
          #if BAR_STATUSBUTTON_PATCH
          { -1,       0,     BAR_ALIGN_LEFT,   width_stbutton,          draw_stbutton,          click_stbutton,          "statusbutton" },
          #endif // BAR_STATUSBUTTON_PATCH
          #if BAR_POWERLINE_TAGS_PATCH
          {  0,       0,     BAR_ALIGN_LEFT,   width_pwrl_tags,         draw_pwrl_tags,         click_pwrl_tags,         "powerline_tags" },
          #endif // BAR_POWERLINE_TAGS_PATCH
          #if BAR_TAGS_PATCH
          { -1,       0,     BAR_ALIGN_LEFT,   width_tags,              draw_tags,              click_tags,              "tags" },
          #endif // BAR_TAGS_PATCH
          #if BAR_TAGGRID_PATCH
          { -1,       0,     BAR_ALIGN_LEFT,   width_taggrid,           draw_taggrid,           click_taggrid,           "taggrid" },
          #endif // BAR_TAGGRID_PATCH
          #if BAR_SYSTRAY_PATCH
          {  0,       0,     BAR_ALIGN_RIGHT,  width_systray,           draw_systray,           click_systray,           "systray" },
          #endif // BAR_SYSTRAY_PATCH
          #if BAR_LTSYMBOL_PATCH
          { -1,       0,     BAR_ALIGN_LEFT,   width_ltsymbol,          draw_ltsymbol,          click_ltsymbol,          "layout" },
          #endif // BAR_LTSYMBOL_PATCH
          #if BAR_STATUSCOLORS_PATCH && BAR_STATUSCMD_PATCH
          { 'A',      0,     BAR_ALIGN_RIGHT,  width_statuscolors,      draw_statuscolors,      click_statuscmd,         "statuscolors" },
          #elif BAR_STATUSCOLORS_PATCH
          { 'A',      0,     BAR_ALIGN_RIGHT,  width_statuscolors,      draw_statuscolors,      click_statuscolors,      "statuscolors" },
          #elif BAR_STATUS2D_PATCH && BAR_STATUSCMD_PATCH
          { 'A',      0,     BAR_ALIGN_RIGHT,  width_status2d,          draw_status2d,          click_statuscmd,         "status2d" },
          #elif BAR_STATUS2D_PATCH
          { 'A',      0,     BAR_ALIGN_RIGHT,  width_status2d,          draw_status2d,          click_status2d,          "status2d" },
          #elif BAR_POWERLINE_STATUS_PATCH
          {  0,       0,     BAR_ALIGN_RIGHT,  width_pwrl_status,       draw_pwrl_status,       click_pwrl_status,       "powerline_status" },
          #elif BAR_STATUS_PATCH && BAR_STATUSCMD_PATCH
          {  0,       0,     BAR_ALIGN_RIGHT,  width_status,            draw_status,            click_statuscmd,         "status" },
          #elif BAR_STATUS_PATCH
          { 'A',      0,     BAR_ALIGN_RIGHT,  width_status,            draw_status,            click_status,            "status" },
          #endif // BAR_STATUS2D_PATCH | BAR_STATUSCMD_PATCH
          #if XKB_PATCH
          {  0,       0,     BAR_ALIGN_RIGHT,  width_xkb,               draw_xkb,               click_xkb,               "xkb" },
          #endif // XKB_PATCH
          #if BAR_FLEXWINTITLE_PATCH
          { -1,       0,     BAR_ALIGN_NONE,   width_flexwintitle,      draw_flexwintitle,      click_flexwintitle,      "flexwintitle" },
          #elif BAR_TABGROUPS_PATCH
          { -1,       0,     BAR_ALIGN_NONE,   width_bartabgroups,      draw_bartabgroups,      click_bartabgroups,      "bartabgroups" },
          #elif BAR_AWESOMEBAR_PATCH
          { -1,       0,     BAR_ALIGN_NONE,   width_awesomebar,        draw_awesomebar,        click_awesomebar,        "awesomebar" },
          #elif BAR_FANCYBAR_PATCH
          { -1,       0,     BAR_ALIGN_NONE,   width_fancybar,          draw_fancybar,          click_fancybar,          "fancybar" },
          #elif BAR_WINTITLE_PATCH
          { -1,       0,     BAR_ALIGN_NONE,   width_wintitle,          draw_wintitle,          click_wintitle,          "wintitle" },
          #endif // BAR_TABGROUPS_PATCH | BAR_AWESOMEBAR_PATCH | BAR_FANCYBAR_PATCH | BAR_WINTITLE_PATCH
          #if BAR_EXTRASTATUS_PATCH
          #if BAR_STATUSCOLORS_PATCH && BAR_STATUSCMD_PATCH
          { 'A',      1,     BAR_ALIGN_CENTER, width_statuscolors_es,   draw_statuscolors_es,   click_statuscmd_es,      "statuscolors_es" },
          #elif BAR_STATUSCOLORS_PATCH
          { 'A',      1,     BAR_ALIGN_CENTER, width_statuscolors_es,   draw_statuscolors_es,   click_statuscolors,      "statuscolors_es" },
          #elif BAR_STATUS2D_PATCH && BAR_STATUSCMD_PATCH
          { 'A',      1,     BAR_ALIGN_CENTER, width_status2d_es,       draw_status2d_es,       click_statuscmd_es,      "status2d_es" },
          #elif BAR_STATUS2D_PATCH
          { 'A',      1,     BAR_ALIGN_CENTER, width_status2d_es,       draw_status2d_es,       click_status2d,          "status2d_es" },
          #elif BAR_POWERLINE_STATUS_PATCH
          {  0,       1,     BAR_ALIGN_RIGHT,  width_pwrl_status_es,    draw_pwrl_status_es,    click_pwrl_status,       "powerline_status" },
          #elif BAR_STATUSCMD_PATCH && BAR_STATUS_PATCH
          { 'A',      1,     BAR_ALIGN_CENTER, width_status_es,         draw_status_es,         click_statuscmd_es,      "status_es" },
          #elif BAR_STATUS_PATCH
          { 'A',      1,     BAR_ALIGN_CENTER, width_status_es,         draw_status_es,         click_status,            "status_es" },
          #endif // BAR_STATUS2D_PATCH | BAR_STATUSCMD_PATCH
          #endif // BAR_EXTRASTATUS_PATCH
          #if BAR_FLEXWINTITLE_PATCH
          #if BAR_WINTITLE_HIDDEN_PATCH
          { -1,       1,  BAR_ALIGN_RIGHT_RIGHT, width_wintitle_hidden, draw_wintitle_hidden,   click_wintitle_hidden,   "wintitle_hidden" },
          #endif
          #if BAR_WINTITLE_FLOATING_PATCH
          { -1,       1,     BAR_ALIGN_LEFT,   width_wintitle_floating, draw_wintitle_floating, click_wintitle_floating, "wintitle_floating" },
          #endif // BAR_WINTITLE_FLOATING_PATCH
          #endif // BAR_FLEXWINTITLE_PATCH
  };
#+end_src

** Layouts

#+begin_src c :tangle config.def.h
  static const float mfact     = 0.50; /* factor of master area size [0.05..0.95] */
  static const int nmaster     = 1;    /* number of clients in master area */
#+end_src

#+begin_src c :tangle config.def.h
  #if FLEXTILE_DELUXE_LAYOUT
  static const int nstack      = 0;    /* number of clients in primary stack area */
  #endif // FLEXTILE_DELUXE_LAYOUT
#+end_src

#+begin_src c :tangle config.def.h
  static const int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
#+end_src

#+begin_src c :tangle config.def.h
  #if DECORATION_HINTS_PATCH
  static const int decorhints  = 1;    /* 1 means respect decoration hints */
  #endif // DECORATION_HINTS_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if NROWGRID_LAYOUT
  #define FORCE_VSPLIT 1
  #endif
#+end_src

#+begin_src c :tangle config.def.h
  #if TAPRESIZE_PATCH
  /* mouse scroll resize */
  static const int scrollsensetivity = 30; /* 1 means resize window by 1 pixel for each scroll event */
  /* resizemousescroll direction argument list */
  static const int scrollargs[][2] = {
          /* width change         height change */
          { +scrollsensetivity,	0 },
          { -scrollsensetivity,	0 },
          { 0, 				  	+scrollsensetivity },
          { 0, 					-scrollsensetivity },
  };
  #endif // TAPRESIZE_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if FLEXTILE_DELUXE_LAYOUT
  static const Layout layouts[] = {
          /* symbol     arrange function, { nmaster, nstack, layout, master axis, stack axis, secondary stack axis, symbol func } */
          { "[]=",      flextile,         { -1, -1, SPLIT_VERTICAL, TOP_TO_BOTTOM, TOP_TO_BOTTOM, 0, NULL } }, // default tile layout
          { "><>",      NULL,             {0} },    /* no layout function means floating behavior */
          { "[M]",      flextile,         { -1, -1, NO_SPLIT, MONOCLE, MONOCLE, 0, NULL } }, // monocle
          { "|||",      flextile,         { -1, -1, SPLIT_VERTICAL, LEFT_TO_RIGHT, TOP_TO_BOTTOM, 0, NULL } }, // columns (col) layout
          { ">M>",      flextile,         { -1, -1, FLOATING_MASTER, LEFT_TO_RIGHT, LEFT_TO_RIGHT, 0, NULL } }, // floating master
          { "[D]",      flextile,         { -1, -1, SPLIT_VERTICAL, TOP_TO_BOTTOM, MONOCLE, 0, NULL } }, // deck
          { "TTT",      flextile,         { -1, -1, SPLIT_HORIZONTAL, LEFT_TO_RIGHT, LEFT_TO_RIGHT, 0, NULL } }, // bstack
          { "===",      flextile,         { -1, -1, SPLIT_HORIZONTAL, LEFT_TO_RIGHT, TOP_TO_BOTTOM, 0, NULL } }, // bstackhoriz
          { "|M|",      flextile,         { -1, -1, SPLIT_CENTERED_VERTICAL, LEFT_TO_RIGHT, TOP_TO_BOTTOM, TOP_TO_BOTTOM, NULL } }, // centeredmaster
          { "-M-",      flextile,         { -1, -1, SPLIT_CENTERED_HORIZONTAL, TOP_TO_BOTTOM, LEFT_TO_RIGHT, LEFT_TO_RIGHT, NULL } }, // centeredmaster horiz
          { ":::",      flextile,         { -1, -1, NO_SPLIT, GAPPLESSGRID, GAPPLESSGRID, 0, NULL } }, // gappless grid
          { "[\\]",     flextile,         { -1, -1, NO_SPLIT, DWINDLE, DWINDLE, 0, NULL } }, // fibonacci dwindle
          { "(@)",      flextile,         { -1, -1, NO_SPLIT, SPIRAL, SPIRAL, 0, NULL } }, // fibonacci spiral
          { "[T]",      flextile,         { -1, -1, SPLIT_VERTICAL, LEFT_TO_RIGHT, TATAMI, 0, NULL } }, // tatami mats
          #if TILE_LAYOUT
          { "[]=",      tile,             {0} },
          #endif
          #if MONOCLE_LAYOUT
          { "[M]",      monocle,          {0} },
          #endif
          #if BSTACK_LAYOUT
          { "TTT",      bstack,           {0} },
          #endif
          #if BSTACKHORIZ_LAYOUT
          { "===",      bstackhoriz,      {0} },
          #endif
          #if CENTEREDMASTER_LAYOUT
          { "|M|",      centeredmaster,   {0} },
          #endif
          #if CENTEREDFLOATINGMASTER_LAYOUT
          { ">M>",      centeredfloatingmaster, {0} },
          #endif
          #if COLUMNS_LAYOUT
          { "|||",      col,              {0} },
          #endif
          #if DECK_LAYOUT
          { "[D]",      deck,             {0} },
          #endif
          #if FIBONACCI_SPIRAL_LAYOUT
          { "(@)",      spiral,           {0} },
          #endif
          #if FIBONACCI_DWINDLE_LAYOUT
          { "[\\]",     dwindle,          {0} },
          #endif
          #if GRIDMODE_LAYOUT
          { "HHH",      grid,             {0} },
          #endif
          #if HORIZGRID_LAYOUT
          { "---",      horizgrid,        {0} },
          #endif
          #if GAPPLESSGRID_LAYOUT
          { ":::",      gaplessgrid,      {0} },
          #endif
          #if NROWGRID_LAYOUT
          { "###",      nrowgrid,         {0} },
          #endif
          #if CYCLELAYOUTS_PATCH
          { NULL,       NULL,             {0} },
          #endif
  };
  #else
  static const Layout layouts[] = {
          /* symbol     arrange function */
          #if TILE_LAYOUT
          { "[]=",      tile },    /* first entry is default */
          #endif
          { "><>",      NULL },    /* no layout function means floating behavior */
          #if MONOCLE_LAYOUT
          { "[M]",      monocle },
          #endif
          #if BSTACK_LAYOUT
          { "TTT",      bstack },
          #endif
          #if BSTACKHORIZ_LAYOUT
          { "===",      bstackhoriz },
          #endif
          #if CENTEREDMASTER_LAYOUT
          { "|M|",      centeredmaster },
          #endif
          #if CENTEREDFLOATINGMASTER_LAYOUT
          { ">M>",      centeredfloatingmaster },
          #endif
          #if COLUMNS_LAYOUT
          { "|||",      col },
          #endif
          #if DECK_LAYOUT
          { "[D]",      deck },
          #endif
          #if FIBONACCI_SPIRAL_LAYOUT
          { "(@)",      spiral },
          #endif
          #if FIBONACCI_DWINDLE_LAYOUT
          { "[\\]",     dwindle },
          #endif
          #if GRIDMODE_LAYOUT
          { "HHH",      grid },
          #endif
          #if HORIZGRID_LAYOUT
          { "---",      horizgrid },
          #endif
          #if GAPPLESSGRID_LAYOUT
          { ":::",      gaplessgrid },
          #endif
          #if NROWGRID_LAYOUT
          { "###",      nrowgrid },
          #endif
          #if CYCLELAYOUTS_PATCH
          { NULL,       NULL },
          #endif
  };
  #endif // FLEXTILE_DELUXE_LAYOUT
#+end_src

#+begin_src c :tangle config.def.h
  #if XKB_PATCH
  /* xkb frontend */
  static const char *xkb_layouts[]  = {
          "en",
          "ru",
  };
  #endif // XKB_PATCH
#+end_src

** Keybindings

#+begin_src c :tangle config.def.h
  #define MODKEY Mod4Mask
#+end_src

#+begin_src c :tangle config.def.h
  #if COMBO_PATCH && SWAPTAGS_PATCH && TAGOTHERMONITOR_PATCH
  #define TAGKEYS(KEY,TAG) \
          { MODKEY,                       KEY,      comboview,      {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
          { MODKEY|ShiftMask,             KEY,      combotag,       {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} }, \
          { MODKEY|Mod1Mask|ShiftMask,    KEY,      swaptags,       {.ui = 1 << TAG} }, \
          { MODKEY|Mod1Mask,              KEY,      tagnextmon,     {.ui = 1 << TAG} }, \
          { MODKEY|Mod1Mask|ControlMask,  KEY,      tagprevmon,     {.ui = 1 << TAG} },
  #elif COMBO_PATCH && SWAPTAGS_PATCH
  #define TAGKEYS(KEY,TAG) \
          { MODKEY,                       KEY,      comboview,      {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
          { MODKEY|ShiftMask,             KEY,      combotag,       {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} }, \
          { MODKEY|Mod1Mask|ShiftMask,    KEY,      swaptags,       {.ui = 1 << TAG} },
  #elif COMBO_PATCH && TAGOTHERMONITOR_PATCH
  #define TAGKEYS(KEY,TAG) \
          { MODKEY,                       KEY,      comboview,      {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
          { MODKEY|ShiftMask,             KEY,      combotag,       {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} }, \
          { MODKEY|Mod1Mask,              KEY,      tagnextmon,     {.ui = 1 << TAG} }, \
          { MODKEY|Mod1Mask|ControlMask,  KEY,      tagprevmon,     {.ui = 1 << TAG} },
  #elif COMBO_PATCH
  #define TAGKEYS(KEY,TAG) \
          { MODKEY,                       KEY,      comboview,      {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
          { MODKEY|ShiftMask,             KEY,      combotag,       {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
  #elif SWAPTAGS_PATCH && TAGOTHERMONITOR_PATCH
  #define TAGKEYS(KEY,TAG) \
          { MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
          { MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} }, \
          { MODKEY|Mod1Mask|ShiftMask,    KEY,      swaptags,       {.ui = 1 << TAG} }, \
          { MODKEY|Mod1Mask,              KEY,      tagnextmon,     {.ui = 1 << TAG} }, \
          { MODKEY|Mod1Mask|ControlMask,  KEY,      tagprevmon,     {.ui = 1 << TAG} },
  #elif SWAPTAGS_PATCH
  #define TAGKEYS(KEY,TAG) \
          { MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
          { MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} }, \
          { MODKEY|Mod1Mask|ShiftMask,    KEY,      swaptags,       {.ui = 1 << TAG} },
  #elif TAGOTHERMONITOR_PATCH
  #define TAGKEYS(KEY,TAG) \
          { MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
          { MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} }, \
          { MODKEY|Mod1Mask,              KEY,      tagnextmon,     {.ui = 1 << TAG} }, \
          { MODKEY|Mod1Mask|ControlMask,  KEY,      tagprevmon,     {.ui = 1 << TAG} },
  #else
  #define TAGKEYS(KEY,TAG) \
          { MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
          { MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
          { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
  #endif // COMBO_PATCH / SWAPTAGS_PATCH / TAGOTHERMONITOR_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if STACKER_PATCH
  #define STACKKEYS(MOD,ACTION) \
          { MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
          { MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
          { MOD, XK_s,     ACTION##stack, {.i = PREVSEL } }, \
          { MOD, XK_w,     ACTION##stack, {.i = 0 } }, \
          { MOD, XK_e,     ACTION##stack, {.i = 1 } }, \
          { MOD, XK_a,     ACTION##stack, {.i = 2 } }, \
          { MOD, XK_z,     ACTION##stack, {.i = -1 } },
  #endif // STACKER_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_HOLDBAR_PATCH
  #define HOLDKEY 0 // replace 0 with the keysym to activate holdbar
  #endif // BAR_HOLDBAR_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  /* helper for spawning shell commands in the pre dwm-5.0 fashion */
  #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
#+end_src

#+begin_src c :tangle config.def.h
  #if !NODMENU_PATCH
  static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
  #endif // NODMENU_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  static const char *dmenucmd[] = {
          "dmenu_run",
          #if !NODMENU_PATCH
          "-m", dmenumon,
          #endif // NODMENU_PATCH
          "-fn", dmenufont,
          "-nb", normbgcolor,
          "-nf", normfgcolor,
          "-sb", selbgcolor,
          "-sf", selfgcolor,
          #if BAR_DMENUMATCHTOP_PATCH
          topbar ? NULL : "-b",
          #endif // BAR_DMENUMATCHTOP_PATCH
          NULL
  };
  static const char *termcmd[]             = { "kitty", NULL };
  static const char *roficmd[]             = { "rofi", "-show", "combi", NULL };
  static const char *controlcentercmd[]    = { "/home/sravan/.scripts/control-center.sh", "--rofi", NULL };
  static const char *clipboardcmd[]        = { "rofi", "-show", "clipboard", NULL };
  static const char *rbwcmd[]              = { "rofi-rbw", NULL };
  static const char *volumecmd[]           = { "/home/sravan/.scripts/pactl.sh", "--rofi", NULL };
  static const char *mediacmd[]            = { "/home/sravan/.scripts/playerctl.sh", "--rofi", NULL };
  static const char *notificationcmd[]     = { "/home/sravan/.scripts/deadd.sh", "--rofi", NULL };
  static const char *sessioncmd[]          = { "/home/sravan/.scripts/session.sh", "--rofi", NULL };
  static const char *compositorcmd[]       = { "/home/sravan/.scripts/picom.sh", "--rofi", NULL };
  static const char *lowervolumecmd[]      = { "/home/sravan/.scripts/pactl.sh", "--lower", NULL };
  static const char *mutevolumecmd[]       = { "/home/sravan/.scripts/pactl.sh", "--mute", NULL };
  static const char *raisevolumecmd[]      = { "/home/sravan/.scripts/pactl.sh", "--raise", NULL };
  static const char *playerplaypausecmd[]  = { "/home/sravan/.scripts/playerctl.sh", "--play-pause", NULL };
  static const char *playernextcmd[]       = { "/home/sravan/.scripts/playerctl.sh", "--next", NULL };
  static const char *playerprevcmd[]       = { "/home/sravan/.scripts/playerctl.sh", "--prev", NULL };
  static const char *flameshotcmd[]        = { "flameshot", "gui", NULL };
  static const char *forceclosewindowcmd[] = { "xkill", NULL };
  static const char *trackpadtogglecmd[]   = { "/home/sravan/.scripts/trackpad.sh", NULL };
#+end_src

#+begin_src c :tangle config.def.h
  #if BAR_STATUSCMD_PATCH
  #if BAR_DWMBLOCKS_PATCH
  /* This defines the name of the executable that handles the bar (used for signalling purposes) */
  #define STATUSBAR "dwmblocks"
  #else
  /* commands spawned when clicking statusbar, the mouse button pressed is exported as BUTTON */
  static const StatusCmd statuscmds[] = {
          { "notify-send Volume$BUTTON", 1 },
          { "notify-send CPU$BUTTON", 2 },
          { "notify-send Battery$BUTTON", 3 },
  };
  /* test the above with: xsetroot -name "$(printf '\x01Volume |\x02 CPU |\x03 Battery')" */
  static const char *statuscmd[] = { "/bin/sh", "-c", NULL, NULL };
  #endif // BAR_DWMBLOCKS_PATCH
  #endif // BAR_STATUSCMD_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if ON_EMPTY_KEYS_PATCH
  static const char* firefoxcmd[] = {"firefox", NULL};
  static Key on_empty_keys[] = {
          /* modifier key            function                argument */
          { 0,        XK_f,          spawn,                  {.v = firefoxcmd } },
  };
  #endif // ON_EMPTY_KEYS_PATCH
#+end_src

See [[https://cgit.freedesktop.org/xorg/proto/x11proto/tree/XF86keysym.h][X11 protocol header]] for list of key symbols.

#+begin_src c :tangle config.def.h
  #include <X11/XF86keysym.h>
  static Key keys[] = {
          /* modifier                     key            function                argument */
          #if KEYMODES_PATCH
          { MODKEY,                       XK_Escape,     setkeymode,             {.ui = COMMANDMODE} },
          #endif // KEYMODES_PATCH

          { MODKEY,                       XK_p,          spawn,                  {.v = roficmd } },
          { MODKEY|ControlMask,           XK_p,          spawn,                  {.v = controlcentercmd } },
          { MODKEY|ShiftMask,             XK_Return,     spawn,                  {.v = termcmd } },
          { MODKEY|ControlMask,           XK_c,          spawn,                  {.v = clipboardcmd} },
          { MODKEY|ControlMask,           XK_b,          spawn,                  {.v = rbwcmd} },
          { MODKEY|ControlMask,           XK_v,          spawn,                  {.v = volumecmd} },
          { MODKEY|ControlMask,           XK_m,          spawn,                  {.v = mediacmd} },
          { MODKEY|ControlMask,           XK_n,          spawn,                  {.v = notificationcmd} },
          { MODKEY|ControlMask,           XK_q,          spawn,                  {.v = sessioncmd} },
          { MODKEY|ControlMask,           XK_Escape,     spawn,                  {.v = compositorcmd} },

          { 0,                            XF86XK_AudioLowerVolume, spawn,        {.v = lowervolumecmd} },
          { 0,                            XF86XK_AudioMute,        spawn,        {.v = mutevolumecmd} },
          { 0,                            XF86XK_AudioRaiseVolume, spawn,        {.v = raisevolumecmd} },
          { 0,                            XF86XK_AudioPlay,        spawn,        {.v = playerplaypausecmd} },
          { 0,                            XF86XK_AudioNext,        spawn,        {.v = playernextcmd} },
          { 0,                            XF86XK_AudioPrev,        spawn,        {.v = playerprevcmd} },
          { 0,                            XF86XK_TouchpadToggle,   spawn,        {.v = trackpadtogglecmd} },
          { 0,                            XK_Print,                spawn,        {.v = flameshotcmd} },

          #if RIODRAW_PATCH
          { MODKEY|ControlMask,           XK_p,          riospawnsync,           {.v = dmenucmd } },
          { MODKEY|ControlMask,           XK_Return,     riospawn,               {.v = termcmd } },
          { MODKEY,                       XK_s,          rioresize,              {0} },
          #endif // RIODRAW_PATCH

          { MODKEY,                       XK_s,          togglebar,              {0} },

          #if TAB_PATCH
          { MODKEY|ControlMask,           XK_b,          tabmode,                {-1} },
          #endif // TAB_PATCH

          #if FOCUSMASTER_PATCH
          { MODKEY|ControlMask,           XK_space,      focusmaster,            {0} },
          #endif // FOCUSMASTER_PATCH

          #if STACKER_PATCH
          STACKKEYS(MODKEY,                              focus)
          STACKKEYS(MODKEY|ShiftMask,                    push)
          #else
          { MODKEY,                       XK_j,          focusstack,             {.i = +1 } },
          { MODKEY,                       XK_k,          focusstack,             {.i = -1 } },
          #endif // STACKER_PATCH

          #if FOCUSDIR_PATCH
          { MODKEY,                       XK_Left,       focusdir,               {.i = 0 } }, // left
          { MODKEY,                       XK_Right,      focusdir,               {.i = 1 } }, // right
          { MODKEY,                       XK_Up,         focusdir,               {.i = 2 } }, // up
          { MODKEY,                       XK_Down,       focusdir,               {.i = 3 } }, // down
          #endif // FOCUSDIR_PATCH

          #if SWAPFOCUS_PATCH && PERTAG_PATCH
          { MODKEY,                       XK_s,          swapfocus,              {.i = -1 } },
          #endif // SWAPFOCUS_PATCH

          #if SWITCHCOL_PATCH
          { MODKEY,                       XK_v,          switchcol,              {0} },
          #endif // SWITCHCOL_PATCH

          #if ROTATESTACK_PATCH
          { MODKEY|Mod1Mask,              XK_j,          rotatestack,            {.i = +1 } },
          { MODKEY|Mod1Mask,              XK_k,          rotatestack,            {.i = -1 } },
          #endif // ROTATESTACK_PATCH

          #if INPLACEROTATE_PATCH
          { MODKEY|Mod1Mask,              XK_j,          inplacerotate,          {.i = +2 } }, // same as rotatestack
          { MODKEY|Mod1Mask,              XK_k,          inplacerotate,          {.i = -2 } }, // same as reotatestack
          { MODKEY|Mod1Mask|ShiftMask,    XK_j,          inplacerotate,          {.i = +1} },
          { MODKEY|Mod1Mask|ShiftMask,    XK_k,          inplacerotate,          {.i = -1} },
          #endif // INPLACEROTATE_PATCH

          #if PUSH_PATCH || PUSH_NO_MASTER_PATCH
          { MODKEY|ControlMask,           XK_j,          pushdown,               {0} },
          { MODKEY|ControlMask,           XK_k,          pushup,                 {0} },
          #endif // PUSH_PATCH / PUSH_NO_MASTER_PATCH

          { MODKEY,                       XK_i,          incnmaster,             {.i = +1 } },
          { MODKEY,                       XK_d,          incnmaster,             {.i = -1 } },

          #if FLEXTILE_DELUXE_LAYOUT
          { MODKEY|ControlMask,           XK_i,          incnstack,              {.i = +1 } },
          { MODKEY|ControlMask,           XK_u,          incnstack,              {.i = -1 } },
          #endif // FLEXTILE_DELUXE_LAYOUT

          { MODKEY,                       XK_h,          setmfact,               {.f = -0.05} },
          { MODKEY,                       XK_l,          setmfact,               {.f = +0.05} },

          #if CFACTS_PATCH
          { MODKEY|ShiftMask,             XK_h,          setcfact,               {.f = +0.25} },
          { MODKEY|ShiftMask,             XK_l,          setcfact,               {.f = -0.25} },
          { MODKEY|ShiftMask,             XK_o,          setcfact,               {0} },
          #endif // CFACTS_PATCH

          #if ASPECTRESIZE_PATCH
          { MODKEY|ControlMask|ShiftMask, XK_e,          aspectresize,           {.i = +24} },
          { MODKEY|ControlMask|ShiftMask, XK_r,          aspectresize,           {.i = -24} },
          #endif // ASPECTRESIZE_PATCH

          #if MOVERESIZE_PATCH
          { MODKEY|Mod1Mask,              XK_Down,       moveresize,             {.v = "0x 25y 0w 0h" } },
          { MODKEY|Mod1Mask,              XK_Up,         moveresize,             {.v = "0x -25y 0w 0h" } },
          { MODKEY|Mod1Mask,              XK_Right,      moveresize,             {.v = "25x 0y 0w 0h" } },
          { MODKEY|Mod1Mask,              XK_Left,       moveresize,             {.v = "-25x 0y 0w 0h" } },
          { MODKEY|Mod1Mask|ShiftMask,    XK_Down,       moveresize,             {.v = "0x 0y 0w 25h" } },
          { MODKEY|Mod1Mask|ShiftMask,    XK_Up,         moveresize,             {.v = "0x 0y 0w -25h" } },
          { MODKEY|Mod1Mask|ShiftMask,    XK_Right,      moveresize,             {.v = "0x 0y 25w 0h" } },
          { MODKEY|Mod1Mask|ShiftMask,    XK_Left,       moveresize,             {.v = "0x 0y -25w 0h" } },
          #endif // MOVERESIZE_PATCH

          #if MOVESTACK_PATCH
          { MODKEY|ShiftMask,             XK_j,          movestack,              {.i = +1 } },
          { MODKEY|ShiftMask,             XK_k,          movestack,              {.i = -1 } },
          #endif // MOVESTACK_PATCH

          #if TRANSFER_PATCH
          { MODKEY,                       XK_x,          transfer,               {0} },
          #endif // TRANSFER_PATCH

          #if TRANSFER_ALL_PATCH
          { MODKEY|ControlMask,           XK_x,          transferall,            {0} },
          #endif // TRANSFER_ALL_PATCH

          #if REORGANIZETAGS_PATCH
          { MODKEY|ControlMask,           XK_r,          reorganizetags,         {0} },
          #endif // REORGANIZETAGS_PATCH

          #if DISTRIBUTETAGS_PATCH
          { MODKEY|ControlMask,           XK_d,          distributetags,         {0} },
          #endif // DISTRIBUTETAGS_PATCH

          #if INSETS_PATCH
          { MODKEY|ShiftMask|ControlMask, XK_a,          updateinset,            {.v = &default_inset } },
          #endif // INSETS_PATCH

          { MODKEY,                       XK_Return,     zoom,                   {0} },
          #if VANITYGAPS_PATCH
          { MODKEY|Mod1Mask,              XK_u,          incrgaps,               {.i = +1 } },
          { MODKEY|Mod1Mask|ShiftMask,    XK_u,          incrgaps,               {.i = -1 } },
          { MODKEY|Mod1Mask,              XK_i,          incrigaps,              {.i = +1 } },
          { MODKEY|Mod1Mask|ShiftMask,    XK_i,          incrigaps,              {.i = -1 } },
          { MODKEY|Mod1Mask,              XK_o,          incrogaps,              {.i = +1 } },
          { MODKEY|Mod1Mask|ShiftMask,    XK_o,          incrogaps,              {.i = -1 } },
          { MODKEY|Mod1Mask,              XK_6,          incrihgaps,             {.i = +1 } },
          { MODKEY|Mod1Mask|ShiftMask,    XK_6,          incrihgaps,             {.i = -1 } },
          { MODKEY|Mod1Mask,              XK_7,          incrivgaps,             {.i = +1 } },
          { MODKEY|Mod1Mask|ShiftMask,    XK_7,          incrivgaps,             {.i = -1 } },
          { MODKEY|Mod1Mask,              XK_8,          incrohgaps,             {.i = +1 } },
          { MODKEY|Mod1Mask|ShiftMask,    XK_8,          incrohgaps,             {.i = -1 } },
          { MODKEY|Mod1Mask,              XK_9,          incrovgaps,             {.i = +1 } },
          { MODKEY|Mod1Mask|ShiftMask,    XK_9,          incrovgaps,             {.i = -1 } },
          { MODKEY|Mod1Mask,              XK_0,          togglegaps,             {0} },
          { MODKEY|Mod1Mask|ShiftMask,    XK_0,          defaultgaps,            {0} },
          #endif // VANITYGAPS_PATCH

          { MODKEY,                       XK_Tab,        view,                   {0} },

          #if SHIFTVIEW_PATCH
          { MODKEY|ShiftMask,             XK_Tab,        shiftview,              { .i = -1 } },
          { MODKEY|ShiftMask,             XK_backslash,  shiftview,              { .i = +1 } },
          #endif // SHIFTVIEW_PATCH

          #if SHIFTVIEW_CLIENTS_PATCH
          { MODKEY|Mod1Mask,              XK_Tab,        shiftviewclients,       { .i = -1 } },
          { MODKEY|Mod1Mask,              XK_backslash,  shiftviewclients,       { .i = +1 } },
          #endif // SHIFTVIEW_CLIENTS_PATCH

          #if BAR_WINTITLEACTIONS_PATCH
          { MODKEY|ControlMask,           XK_z,          showhideclient,         {0} },
          #endif // BAR_WINTITLEACTIONS_PATCH

          { MODKEY|ShiftMask,             XK_c,          killclient,             {0} },
          { MODKEY|ControlMask|ShiftMask, XK_c,          spawn,                  {.v = forceclosewindowcmd} },

          #if KILLUNSEL_PATCH
          { MODKEY|ShiftMask,             XK_x,          killunsel,              {0} },
          #endif // KILLUNSEL_PATCH

          #if SELFRESTART_PATCH
          { MODKEY|ShiftMask,             XK_r,          self_restart,           {0} },
          #endif // SELFRESTART_PATCH

          { MODKEY|ShiftMask,             XK_q,          quit,                   {0} },

          #if RESTARTSIG_PATCH
          { MODKEY|ControlMask|ShiftMask, XK_q,          quit,                   {1} },
          #endif // RESTARTSIG_PATCH

          #if FOCUSURGENT_PATCH
          { MODKEY,                       XK_u,          focusurgent,            {0} },
          #endif // FOCUSURGENT_PATCH

          #if BAR_HOLDBAR_PATCH
          { 0,                            HOLDKEY,       holdbar,                {0} },
          #endif // BAR_HOLDBAR_PATCH

          #if WINVIEW_PATCH
          { MODKEY,                       XK_o,          winview,                {0} },
          #endif // WINVIEW_PATCH

          #if XRDB_PATCH && !BAR_VTCOLORS_PATCH
          { MODKEY|ShiftMask,             XK_F5,         xrdb,                   {.v = NULL } },
          #endif // XRDB_PATCH

          { MODKEY,                       XK_t,          setlayout,              {.v = &layouts[0]} },
          { MODKEY,                       XK_f,          setlayout,              {.v = &layouts[1]} },
          { MODKEY,                       XK_m,          setlayout,              {.v = &layouts[2]} },
          { MODKEY,                       XK_g,          setlayout,              {.v = &layouts[3]} },

          #if COLUMNS_LAYOUT
          { MODKEY,                       XK_c,          setlayout,              {.v = &layouts[3]} },
          #endif // COLUMNS_LAYOUT

          #if FLEXTILE_DELUXE_LAYOUT
          { MODKEY|ControlMask,           XK_t,          rotatelayoutaxis,       {.i = +1 } },   /* flextile, 1 = layout axis */
          { MODKEY|ControlMask,           XK_Tab,        rotatelayoutaxis,       {.i = +2 } },   /* flextile, 2 = master axis */
          { MODKEY|ControlMask|ShiftMask, XK_Tab,        rotatelayoutaxis,       {.i = +3 } },   /* flextile, 3 = stack axis */
          { MODKEY|ControlMask|Mod1Mask,  XK_Tab,        rotatelayoutaxis,       {.i = +4 } },   /* flextile, 4 = secondary stack axis */
          { MODKEY|Mod5Mask,              XK_t,          rotatelayoutaxis,       {.i = -1 } },   /* flextile, 1 = layout axis */
          { MODKEY|Mod5Mask,              XK_Tab,        rotatelayoutaxis,       {.i = -2 } },   /* flextile, 2 = master axis */
          { MODKEY|Mod5Mask|ShiftMask,    XK_Tab,        rotatelayoutaxis,       {.i = -3 } },   /* flextile, 3 = stack axis */
          { MODKEY|Mod5Mask|Mod1Mask,     XK_Tab,        rotatelayoutaxis,       {.i = -4 } },   /* flextile, 4 = secondary stack axis */
          { MODKEY|ControlMask,           XK_Return,     mirrorlayout,           {0} },          /* flextile, flip master and stack areas */
          #endif // FLEXTILE_DELUXE_LAYOUT

          { MODKEY,                       XK_space,      setlayout,              {0} },
          { MODKEY|ShiftMask,             XK_space,      togglefloating,         {0} },

          #if MAXIMIZE_PATCH
          { MODKEY|ControlMask|ShiftMask, XK_h,          togglehorizontalmax,    {0} },
          { MODKEY|ControlMask|ShiftMask, XK_l,          togglehorizontalmax,    {0} },
          { MODKEY|ControlMask|ShiftMask, XK_j,          toggleverticalmax,      {0} },
          { MODKEY|ControlMask|ShiftMask, XK_k,          toggleverticalmax,      {0} },
          { MODKEY|ControlMask,           XK_m,          togglemax,              {0} },
          #endif // MAXIMIZE_PATCH

          #if NO_MOD_BUTTONS_PATCH
          { MODKEY|ShiftMask,             XK_Escape,     togglenomodbuttons,     {0} },
          #endif // NO_MOD_BUTTONS_PATCH

          #if SCRATCHPADS_PATCH
          { MODKEY,                       XK_grave,      togglescratch,          {.ui = 0 } },
          { MODKEY|ControlMask,           XK_grave,      setscratch,             {.ui = 0 } },
          { MODKEY|ShiftMask,             XK_grave,      removescratch,          {.ui = 0 } },
          #endif // SCRATCHPADS_PATCH

          #if UNFLOATVISIBLE_PATCH
          { MODKEY|Mod1Mask,              XK_space,      unfloatvisible,         {0} },
          { MODKEY|ShiftMask,             XK_t,          unfloatvisible,         {.v = &layouts[0]} },
          { MODKEY|ShiftMask,             XK_m,          unfloatvisible,         {.v = &layouts[2]} },
          { MODKEY|ShiftMask,             XK_g,          unfloatvisible,         {.v = &layouts[3]} },
          #endif // UNFLOATVISIBLE_PATCH

          #if TOGGLEFULLSCREEN_PATCH
          { MODKEY|ShiftMask,             XK_f,          togglefullscreen,       {0} },
          #endif // TOGGLEFULLSCREEN_PATCH

          #if !FAKEFULLSCREEN_PATCH && FAKEFULLSCREEN_CLIENT_PATCH
          { MODKEY|ShiftMask,             XK_y,          togglefakefullscreen,   {0} },
          #endif // FAKEFULLSCREEN_CLIENT_PATCH

          #if FULLSCREEN_PATCH
          { MODKEY|ShiftMask,             XK_f,          fullscreen,             {0} },
          #endif // FULLSCREEN_PATCH

          #if STICKY_PATCH
          { MODKEY|ShiftMask,             XK_s,          togglesticky,           {0} },
          #endif // STICKY_PATCH

          #if SCRATCHPAD_ALT_1_PATCH
          { MODKEY,                       XK_minus,      scratchpad_show,        {0} },
          { MODKEY|ShiftMask,             XK_minus,      scratchpad_hide,        {0} },
          { MODKEY,                       XK_equal,      scratchpad_remove,      {0} },
          #elif SCRATCHPADS_PATCH
          { MODKEY,                       XK_0,          view,                   {.ui = ~SPTAGMASK } },
          { MODKEY|ShiftMask,             XK_0,          tag,                    {.ui = ~SPTAGMASK } },
          #else
          { MODKEY,                       XK_0,          view,                   {.ui = ~0 } },
          { MODKEY|ShiftMask,             XK_0,          tag,                    {.ui = ~0 } },
          #endif // SCRATCHPAD_ALT_1_PATCH

          { MODKEY,                       XK_comma,      focusmon,               {.i = -1 } },
          { MODKEY,                       XK_period,     focusmon,               {.i = +1 } },
          { MODKEY|ShiftMask,             XK_comma,      tagmon,                 {.i = -1 } },
          { MODKEY|ShiftMask,             XK_period,     tagmon,                 {.i = +1 } },

          #if FOCUSADJACENTTAG_PATCH
          { MODKEY,                       XK_Left,       viewtoleft,             {0} }, // note keybinding conflict with focusdir
          { MODKEY,                       XK_Right,      viewtoright,            {0} }, // note keybinding conflict with focusdir
          { MODKEY|ShiftMask,             XK_Left,       tagtoleft,              {0} },
          { MODKEY|ShiftMask,             XK_Right,      tagtoright,             {0} },
          { MODKEY|ControlMask,           XK_Left,       tagandviewtoleft,       {0} },
          { MODKEY|ControlMask,           XK_Right,      tagandviewtoright,      {0} },
          #endif // FOCUSADJACENTTAG_PATCH

          #if TAGALL_PATCH
          { MODKEY|ShiftMask,             XK_F1,         tagall,                 {.v = "F1"} },
          { MODKEY|ShiftMask,             XK_F2,         tagall,                 {.v = "F2"} },
          { MODKEY|ShiftMask,             XK_F3,         tagall,                 {.v = "F3"} },
          { MODKEY|ShiftMask,             XK_F4,         tagall,                 {.v = "F4"} },
          { MODKEY|ShiftMask,             XK_F5,         tagall,                 {.v = "F5"} },
          { MODKEY|ShiftMask,             XK_F6,         tagall,                 {.v = "F6"} },
          { MODKEY|ShiftMask,             XK_F7,         tagall,                 {.v = "F7"} },
          { MODKEY|ShiftMask,             XK_F8,         tagall,                 {.v = "F8"} },
          { MODKEY|ShiftMask,             XK_F9,         tagall,                 {.v = "F9"} },
          { MODKEY|ControlMask,           XK_F1,         tagall,                 {.v = "1"} },
          { MODKEY|ControlMask,           XK_F2,         tagall,                 {.v = "2"} },
          { MODKEY|ControlMask,           XK_F3,         tagall,                 {.v = "3"} },
          { MODKEY|ControlMask,           XK_F4,         tagall,                 {.v = "4"} },
          { MODKEY|ControlMask,           XK_F5,         tagall,                 {.v = "5"} },
          { MODKEY|ControlMask,           XK_F6,         tagall,                 {.v = "6"} },
          { MODKEY|ControlMask,           XK_F7,         tagall,                 {.v = "7"} },
          { MODKEY|ControlMask,           XK_F8,         tagall,                 {.v = "8"} },
          { MODKEY|ControlMask,           XK_F9,         tagall,                 {.v = "9"} },
          #endif // TAGALL_PATCH

          #if TAGALLMON_PATCH
          { MODKEY|Mod1Mask|ShiftMask,    XK_comma,      tagallmon,              {.i = +1 } },
          { MODKEY|Mod1Mask|ShiftMask,    XK_period,     tagallmon,              {.i = -1 } },
          #endif // TAGALLMON_PATCH

          #if TAGSWAPMON_PATCH
          { MODKEY|Mod1Mask|ControlMask,  XK_comma,      tagswapmon,             {.i = +1 } },
          { MODKEY|Mod1Mask|ControlMask,  XK_period,     tagswapmon,             {.i = -1 } },
          #endif // TAGSWAPMON_PATCH

          #if BAR_ALTERNATIVE_TAGS_PATCH
          { MODKEY,                       XK_n,          togglealttag,           {0} },
          #endif // BAR_ALTERNATIVE_TAGS_PATCH

          #if BAR_TAGGRID_PATCH
          { MODKEY|ControlMask,           XK_Up,         switchtag,              { .ui = SWITCHTAG_UP    | SWITCHTAG_VIEW } },
          { MODKEY|ControlMask,           XK_Down,       switchtag,              { .ui = SWITCHTAG_DOWN  | SWITCHTAG_VIEW } },
          { MODKEY|ControlMask,           XK_Right,      switchtag,              { .ui = SWITCHTAG_RIGHT | SWITCHTAG_VIEW } },
          { MODKEY|ControlMask,           XK_Left,       switchtag,              { .ui = SWITCHTAG_LEFT  | SWITCHTAG_VIEW } },
          { MODKEY|Mod1Mask,              XK_Up,         switchtag,              { .ui = SWITCHTAG_UP    | SWITCHTAG_TAG | SWITCHTAG_VIEW } },
          { MODKEY|Mod1Mask,              XK_Down,       switchtag,              { .ui = SWITCHTAG_DOWN  | SWITCHTAG_TAG | SWITCHTAG_VIEW } },
          { MODKEY|Mod1Mask,              XK_Right,      switchtag,              { .ui = SWITCHTAG_RIGHT | SWITCHTAG_TAG | SWITCHTAG_VIEW } },
          { MODKEY|Mod1Mask,              XK_Left,       switchtag,              { .ui = SWITCHTAG_LEFT  | SWITCHTAG_TAG | SWITCHTAG_VIEW } },
          #endif // BAR_TAGGRID_PATCH

          #if MOVEPLACE_PATCH
          { MODKEY,                       XK_KP_7,       moveplace,              {.ui = WIN_NW }},   /* XK_KP_Home,  */
          { MODKEY,                       XK_KP_8,       moveplace,              {.ui = WIN_N  }},   /* XK_KP_Up,    */
          { MODKEY,                       XK_KP_9,       moveplace,              {.ui = WIN_NE }},   /* XK_KP_Prior, */
          { MODKEY,                       XK_KP_4,       moveplace,              {.ui = WIN_W  }},   /* XK_KP_Left,  */
          { MODKEY,                       XK_KP_5,       moveplace,              {.ui = WIN_C  }},   /* XK_KP_Begin, */
          { MODKEY,                       XK_KP_6,       moveplace,              {.ui = WIN_E  }},   /* XK_KP_Right, */
          { MODKEY,                       XK_KP_1,       moveplace,              {.ui = WIN_SW }},   /* XK_KP_End,   */
          { MODKEY,                       XK_KP_2,       moveplace,              {.ui = WIN_S  }},   /* XK_KP_Down,  */
          { MODKEY,                       XK_KP_3,       moveplace,              {.ui = WIN_SE }},   /* XK_KP_Next,  */
          #endif // MOVEPLACE_PATCH

          #if EXRESIZE_PATCH
          { MODKEY,                       XK_KP_7,       explace,                {.ui = EX_NW }},   /* XK_KP_Home,  */
          { MODKEY,                       XK_KP_8,       explace,                {.ui = EX_N  }},   /* XK_KP_Up,    */
          { MODKEY,                       XK_KP_9,       explace,                {.ui = EX_NE }},   /* XK_KP_Prior, */
          { MODKEY,                       XK_KP_4,       explace,                {.ui = EX_W  }},   /* XK_KP_Left,  */
          { MODKEY,                       XK_KP_5,       explace,                {.ui = EX_C  }},   /* XK_KP_Begin, */
          { MODKEY,                       XK_KP_6,       explace,                {.ui = EX_E  }},   /* XK_KP_Right, */
          { MODKEY,                       XK_KP_1,       explace,                {.ui = EX_SW }},   /* XK_KP_End,   */
          { MODKEY,                       XK_KP_2,       explace,                {.ui = EX_S  }},   /* XK_KP_Down,  */
          { MODKEY,                       XK_KP_3,       explace,                {.ui = EX_SE }},   /* XK_KP_Next,  */
          { MODKEY|ShiftMask,             XK_KP_8,       exresize,               {.v = (int []){   0,  25 }}},  /* XK_KP_Up,    */
          { MODKEY|ShiftMask,             XK_KP_2,       exresize,               {.v = (int []){   0, -25 }}},  /* XK_KP_Down,  */
          { MODKEY|ShiftMask,             XK_KP_6,       exresize,               {.v = (int []){  25,   0 }}},  /* XK_KP_Right, */
          { MODKEY|ShiftMask,             XK_KP_4,       exresize,               {.v = (int []){ -25,   0 }}},  /* XK_KP_Left,  */
          { MODKEY|ShiftMask,             XK_KP_5,       exresize,               {.v = (int []){  25,  25 }}},  /* XK_KP_Begin, */
          { MODKEY|ShiftMask|ControlMask, XK_KP_5,       exresize,               {.v = (int []){ -25, -25 }}},  /* XK_KP_Begin, */
          { MODKEY|ControlMask,           XK_KP_6,       togglehorizontalexpand, {.i = +1} },  /* XK_KP_Right, */
          { MODKEY|ControlMask,           XK_KP_3,       togglehorizontalexpand, {.i =  0} },  /* XK_KP_Next,  */
          { MODKEY|ControlMask,           XK_KP_4,       togglehorizontalexpand, {.i = -1} },  /* XK_KP_Left,  */
          { MODKEY|ControlMask,           XK_KP_8,       toggleverticalexpand,   {.i = +1} },  /* XK_KP_Up,    */
          { MODKEY|ControlMask,           XK_KP_1,       toggleverticalexpand,   {.i =  0} },  /* XK_KP_End,   */
          { MODKEY|ControlMask,           XK_KP_2,       toggleverticalexpand,   {.i = -1} },  /* XK_KP_Down,  */
          { MODKEY|ControlMask,           XK_KP_9,       togglemaximize,         {.i = -1} },  /* XK_KP_Prior, */
          { MODKEY|ControlMask,           XK_KP_7,       togglemaximize,         {.i = +1} },  /* XK_KP_Home,  */
          { MODKEY|ControlMask,           XK_KP_5,       togglemaximize,         {.i =  0} },  /* XK_KP_Begin, */
          #endif // EXRESIZE_PATCH

          #if FLOATPOS_PATCH
          /* Note that due to key limitations the below example kybindings are defined with a Mod3Mask,
           ,* which is not always readily available. Refer to the patch wiki for more details. */
          /* Client position is limited to monitor window area */
          { Mod3Mask,                     XK_u,            floatpos,               {.v = "-26x -26y" } }, // 
          { Mod3Mask,                     XK_i,            floatpos,               {.v = "  0x -26y" } }, // 
          { Mod3Mask,                     XK_o,            floatpos,               {.v = " 26x -26y" } }, // 
          { Mod3Mask,                     XK_j,            floatpos,               {.v = "-26x   0y" } }, // 
          { Mod3Mask,                     XK_l,            floatpos,               {.v = " 26x   0y" } }, // 
          { Mod3Mask,                     XK_m,            floatpos,               {.v = "-26x  26y" } }, // 
          { Mod3Mask,                     XK_comma,        floatpos,               {.v = "  0x  26y" } }, // 
          { Mod3Mask,                     XK_period,       floatpos,               {.v = " 26x  26y" } }, // 
          /* Absolute positioning (allows moving windows between monitors) */
          { Mod3Mask|ControlMask,         XK_u,            floatpos,               {.v = "-26a -26a" } }, // 
          { Mod3Mask|ControlMask,         XK_i,            floatpos,               {.v = "  0a -26a" } }, // 
          { Mod3Mask|ControlMask,         XK_o,            floatpos,               {.v = " 26a -26a" } }, // 
          { Mod3Mask|ControlMask,         XK_j,            floatpos,               {.v = "-26a   0a" } }, // 
          { Mod3Mask|ControlMask,         XK_l,            floatpos,               {.v = " 26a   0a" } }, // 
          { Mod3Mask|ControlMask,         XK_m,            floatpos,               {.v = "-26a  26a" } }, // 
          { Mod3Mask|ControlMask,         XK_comma,        floatpos,               {.v = "  0a  26a" } }, // 
          { Mod3Mask|ControlMask,         XK_period,       floatpos,               {.v = " 26a  26a" } }, // 
          /* Resize client, client center position is fixed which means that client expands in all directions */
          { Mod3Mask|ShiftMask,           XK_u,            floatpos,               {.v = "-26w -26h" } }, // 
          { Mod3Mask|ShiftMask,           XK_i,            floatpos,               {.v = "  0w -26h" } }, // 
          { Mod3Mask|ShiftMask,           XK_o,            floatpos,               {.v = " 26w -26h" } }, // 
          { Mod3Mask|ShiftMask,           XK_j,            floatpos,               {.v = "-26w   0h" } }, // 
          { Mod3Mask|ShiftMask,           XK_k,            floatpos,               {.v = "800W 800H" } }, // 
          { Mod3Mask|ShiftMask,           XK_l,            floatpos,               {.v = " 26w   0h" } }, // 
          { Mod3Mask|ShiftMask,           XK_m,            floatpos,               {.v = "-26w  26h" } }, // 
          { Mod3Mask|ShiftMask,           XK_comma,        floatpos,               {.v = "  0w  26h" } }, // 
          { Mod3Mask|ShiftMask,           XK_period,       floatpos,               {.v = " 26w  26h" } }, // 
          /* Client is positioned in a floating grid, movement is relative to client's current position */
          { Mod3Mask|Mod1Mask,            XK_u,            floatpos,               {.v = "-1p -1p" } }, // 
          { Mod3Mask|Mod1Mask,            XK_i,            floatpos,               {.v = " 0p -1p" } }, // 
          { Mod3Mask|Mod1Mask,            XK_o,            floatpos,               {.v = " 1p -1p" } }, // 
          { Mod3Mask|Mod1Mask,            XK_j,            floatpos,               {.v = "-1p  0p" } }, // 
          { Mod3Mask|Mod1Mask,            XK_k,            floatpos,               {.v = " 0p  0p" } }, // 
          { Mod3Mask|Mod1Mask,            XK_l,            floatpos,               {.v = " 1p  0p" } }, // 
          { Mod3Mask|Mod1Mask,            XK_m,            floatpos,               {.v = "-1p  1p" } }, // 
          { Mod3Mask|Mod1Mask,            XK_comma,        floatpos,               {.v = " 0p  1p" } }, // 
          { Mod3Mask|Mod1Mask,            XK_period,       floatpos,               {.v = " 1p  1p" } }, // 
          #endif // FLOATPOS_PATCH

          #if SETBORDERPX_PATCH
          { MODKEY|ControlMask,           XK_minus,      setborderpx,            {.i = -1 } },
          { MODKEY|ControlMask,           XK_plus,       setborderpx,            {.i = +1 } },
          { MODKEY|ControlMask,           XK_numbersign, setborderpx,            {.i = 0 } },
          #endif // SETBORDERPX_PATCH

          #if CYCLELAYOUTS_PATCH
          { MODKEY|ControlMask,           XK_comma,      cyclelayout,            {.i = -1 } },
          { MODKEY|ControlMask,           XK_period,     cyclelayout,            {.i = +1 } },
          #endif // CYCLELAYOUTS_PATCH

          #if MPDCONTROL_PATCH
          { MODKEY,                       XK_F1,         mpdchange,              {.i = -1} },
          { MODKEY,                       XK_F2,         mpdchange,              {.i = +1} },
          { MODKEY,                       XK_Escape,     mpdcontrol,             {0} },
          #endif // MPDCONTROL_PATCH

          TAGKEYS(                        XK_1,                                  0)
          TAGKEYS(                        XK_2,                                  1)
          TAGKEYS(                        XK_3,                                  2)
          TAGKEYS(                        XK_4,                                  3)
          TAGKEYS(                        XK_5,                                  4)
          TAGKEYS(                        XK_6,                                  5)
          TAGKEYS(                        XK_7,                                  6)
          TAGKEYS(                        XK_8,                                  7)
          TAGKEYS(                        XK_9,                                  8)
  };
#+end_src

#+begin_src c :tangle config.def.h
  #if KEYMODES_PATCH
  static Key cmdkeys[] = {
          /* modifier                    keys                     function         argument */
          { 0,                           XK_Escape,               clearcmd,        {0} },
          { ControlMask,                 XK_c,                    clearcmd,        {0} },
          { 0,                           XK_i,                    setkeymode,      {.ui = INSERTMODE} },
  };

  static Command commands[] = {
          /* modifier (4 keys)                          keysyms (4 keys)                              function         argument */
          { {ControlMask, ShiftMask, 0,         0},    {XK_w,      XK_h,    0,         0},            setlayout,       {.v = &layouts[0]} },
          { {ControlMask, 0,         0,         0},    {XK_w,      XK_o,    0,         0},            setlayout,       {.v = &layouts[2]} },
          { {ControlMask, ShiftMask, 0,         0},    {XK_w,      XK_o,    0,         0},            onlyclient,      {0} },
          { {ControlMask, 0,         0,         0},    {XK_w,      XK_v,    0,         0},            setlayout,       {.v = &layouts[0]} },
          { {ControlMask, 0,         0,         0},    {XK_w,      XK_less, 0,         0},            setmfact,        {.f = -0.05} },
          { {ControlMask, ShiftMask, 0,         0},    {XK_w,      XK_less, 0,         0},            setmfact,        {.f = +0.05} },
          { {ControlMask, ShiftMask, 0,         0},    {XK_w,      XK_0,    0,         0},            setmfact,        {.f = +1.50} },
          { {ShiftMask,   0,         0,         0},    {XK_period, XK_e,    0,         0},            spawn,           {.v = dmenucmd} },
          { {ShiftMask,   0,         0,         0},    {XK_period, XK_o,    0,         0},            spawn,           {.v = dmenucmd} },
          { {ShiftMask,   0,         0,         0},    {XK_period, XK_q,    XK_Return, 0},            quit,            {0} },
          { {ShiftMask,   0,         0,         0},    {XK_period, XK_b,    XK_d,      XK_Return},    killclient,      {0} },
          { {ShiftMask,   0,         0,         0},    {XK_period, XK_b,    XK_n,      XK_Return},    focusstack,      {.i = +1} },
          { {ShiftMask,   0,         ShiftMask, 0},    {XK_period, XK_b,    XK_n,      XK_Return},    focusstack,      {.i = -1} },
  };
  #endif // KEYMODES_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  /* button definitions */
  #if STATUSBUTTON_PATCH
  /* click can be ClkButton, ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
  #else
  /* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
  #endif //
  static Button buttons[] = {
          /* click                event mask           button          function        argument */
          #if BAR_STATUSBUTTON_PATCH
          { ClkButton,            0,                   Button1,        spawn,          {.v = dmenucmd } },
          #endif // BAR_STATUSBUTTON_PATCH
          { ClkLtSymbol,          0,                   Button1,        setlayout,      {0} },
          #if BAR_LAYOUTMENU_PATCH
          { ClkLtSymbol,          0,                   Button3,        layoutmenu,     {0} },
          #else
          { ClkLtSymbol,          0,                   Button3,        setlayout,      {.v = &layouts[2]} },
          #endif // BAR_LAYOUTMENU_PATCH
          #if BAR_WINTITLEACTIONS_PATCH
          { ClkWinTitle,          0,                   Button1,        togglewin,      {0} },
          { ClkWinTitle,          0,                   Button3,        showhideclient, {0} },
          #endif // BAR_WINTITLEACTIONS_PATCH
          { ClkWinTitle,          0,                   Button2,        zoom,           {0} },
          #if BAR_STATUSCMD_PATCH && BAR_DWMBLOCKS_PATCH
          { ClkStatusText,        0,                   Button1,        sigstatusbar,   {.i = 1 } },
          { ClkStatusText,        0,                   Button2,        sigstatusbar,   {.i = 2 } },
          { ClkStatusText,        0,                   Button3,        sigstatusbar,   {.i = 3 } },
          #elif BAR_STATUSCMD_PATCH
          { ClkStatusText,        0,                   Button1,        spawn,          {.v = statuscmd } },
          { ClkStatusText,        0,                   Button2,        spawn,          {.v = statuscmd } },
          { ClkStatusText,        0,                   Button3,        spawn,          {.v = statuscmd } },
          #else
          { ClkStatusText,        0,                   Button2,        spawn,          {.v = termcmd } },
          #endif // BAR_STATUSCMD_PATCH
          #if PLACEMOUSE_PATCH
          /* placemouse options, choose which feels more natural:
           ,*    0 - tiled position is relative to mouse cursor
           ,*    1 - tiled postiion is relative to window center
           ,*    2 - mouse pointer warps to window center
           ,*
           ,* The moveorplace uses movemouse or placemouse depending on the floating state
           ,* of the selected client. Set up individual keybindings for the two if you want
           ,* to control these separately (i.e. to retain the feature to move a tiled window
           ,* into a floating position).
           ,*/
          { ClkClientWin,         MODKEY,              Button1,        moveorplace,    {.i = 1} },
          #else
          { ClkClientWin,         MODKEY,              Button1,        movemouse,      {0} },
          #endif // PLACEMOUSE_PATCH
          { ClkClientWin,         MODKEY,              Button2,        togglefloating, {0} },
          { ClkClientWin,         MODKEY,              Button3,        resizemouse,    {0} },
          #if TAPRESIZE_PATCH
          { ClkClientWin,         MODKEY,              Button4,        resizemousescroll, {.v = &scrollargs[0]} },
          { ClkClientWin,         MODKEY,              Button5,        resizemousescroll, {.v = &scrollargs[1]} },
          { ClkClientWin,         MODKEY,              Button6,        resizemousescroll, {.v = &scrollargs[2]} },
          { ClkClientWin,         MODKEY,              Button7,        resizemousescroll, {.v = &scrollargs[3]} },
          #endif // TAPRESIZE_PATCH
          #if DRAGCFACT_PATCH && CFACTS_PATCH
          { ClkClientWin,         MODKEY|ShiftMask,    Button3,        dragcfact,      {0} },
          #endif // DRAGCFACT_PATCH
          #if DRAGMFACT_PATCH
          { ClkClientWin,         MODKEY|ShiftMask,    Button1,        dragmfact,      {0} },
          #endif // DRAGMFACT_PATCH
          { ClkTagBar,            0,                   Button1,        view,           {0} },
          { ClkTagBar,            0,                   Button3,        toggleview,     {0} },
          { ClkTagBar,            MODKEY,              Button1,        tag,            {0} },
          { ClkTagBar,            MODKEY,              Button3,        toggletag,      {0} },
          #if TAB_PATCH
          { ClkTabBar,            0,                   Button1,        focuswin,       {0} },
          #endif // TAB_PATCH
  };
#+end_src

#+begin_src c :tangle config.def.h
  #if DWMC_PATCH
  /* signal definitions */
  /* signum must be greater than 0 */
  /* trigger signals using `xsetroot -name "fsignal:<signame> [<type> <value>]"` */
  static Signal signals[] = {
          /* signum                    function */
          { "focusstack",              focusstack },
          { "setmfact",                setmfact },
          { "togglebar",               togglebar },
          { "incnmaster",              incnmaster },
          { "togglefloating",          togglefloating },
          { "focusmon",                focusmon },
          #if STACKER_PATCH
          { "pushstack",               pushstack },
          #endif // STACKER_PATCH
          #if FOCUSURGENT_PATCH
          { "focusurgent",             focusurgent },
          #endif // FOCUSURGENT_PATCH
          #if FOCUSADJACENTTAG_PATCH
          { "viewtoleft",              viewtoleft },
          { "viewtoright",             viewtoright },
          { "tagtoleft",               tagtoleft },
          { "tagtoright",              tagtoright},
          { "tagandviewtoleft",        tagandviewtoleft },
          { "tagandviewtoright",       tagandviewtoright },
          #endif // FOCUSADJACENTTAG_PATCH
          #if SWAPFOCUS_PATCH && PERTAG_PATCH
          { "swapfocus",               swapfocus },
          #endif // SWAPFOCUS_PATCH
          #if SWITCHCOL_PATCH
          { "switchcol",               switchcol },
          #endif // SWITCHCOL_PATCH
          #if ROTATESTACK_PATCH
          { "rotatestack",             rotatestack },
          #endif // ROTATESTACK_PATCH
          #if INPLACEROTATE_PATCH
          { "inplacerotate",           inplacerotate },
          #endif // INPLACEROTATE_PATCH
          #if PUSH_PATCH || PUSH_NO_MASTER_PATCH
          { "pushdown",                pushdown },
          { "pushup",                  pushup },
          #endif // PUSH_PATCH / PUSH_NO_MASTER_PATCH
          #if FLEXTILE_DELUXE_LAYOUT
          { "incnstack",               incnstack },
          { "rotatelayoutaxis",        rotatelayoutaxis },
          { "setlayoutaxisex",         setlayoutaxisex },
          { "mirrorlayout",            mirrorlayout },
          #endif // FLEXTILE_DELUXE_LAYOUT
          #if CFACTS_PATCH
          { "setcfact",                setcfact },
          #endif // CFACTS_PATCH
          #if MOVEPLACE_PATCH
          { "moveplace",               moveplace },
          #endif // MOVEPLACE_PATCH
          #if EXRESIZE_PATCH
          { "explace",                 explace },
          { "togglehorizontalexpand",  togglehorizontalexpand },
          { "toggleverticalexpand",    toggleverticalexpand },
          { "togglemaximize",          togglemaximize },
          #endif // EXRESIZE_PATCH
          #if KEYMODES_PATCH
          { "setkeymode",              setkeymode },
          #endif // KEYMODES_PATCH
          #if TRANSFER_PATCH
          { "transfer",                transfer },
          #endif // TRANSFER_PATCH
          #if TRANSFER_ALL_PATCH
          { "transferall",             transferall },
          #endif // TRANSFER_ALL_PATCH
          { "tagmon",                  tagmon },
          { "zoom",                    zoom },
          #if VANITYGAPS_PATCH
          { "incrgaps",                incrgaps },
          { "incrigaps",               incrigaps },
          { "incrogaps",               incrogaps },
          { "incrihgaps",              incrihgaps },
          { "incrivgaps",              incrivgaps },
          { "incrohgaps",              incrohgaps },
          { "incrovgaps",              incrovgaps },
          { "togglegaps",              togglegaps },
          { "defaultgaps",             defaultgaps },
          { "setgaps",                 setgapsex },
          #endif // VANITYGAPS_PATCH
          { "view",                    view },
          { "viewall",                 viewallex },
          { "viewex",                  viewex },
          { "toggleview",              toggleview },
          #if SHIFTVIEW_PATCH
          { "shiftview",               shiftview },
          #endif // SHIFTVIEW_PATCH
          #if SHIFTVIEW_CLIENTS_PATCH
          { "shiftviewclients",        shiftviewclients },
          #endif // SHIFTVIEW_CLIENTS_PATCH
          #if SELFRESTART_PATCH
          { "self_restart",            self_restart },
          #endif // SELFRESTART_PATCH
          #if BAR_TAGGRID_PATCH
          { "switchtag",               switchtag },
          #endif // BAR_TAGGRID_PATCH
          #if STICKY_PATCH
          { "togglesticky",            togglesticky },
          #endif // STICKY_PATCH
          #if SETBORDERPX_PATCH
          { "setborderpx",             setborderpx },
          #endif // SETBORDERPX_PATCH
          #if CYCLELAYOUTS_PATCH
          { "cyclelayout",             cyclelayout },
          #endif // CYCLELAYOUTS_PATCH
          #if MPDCONTROL_PATCH
          { "mpdchange",               mpdchange },
          { "mpdcontrol",              mpdcontrol },
          #endif // MPDCONTROL_PATCH
          { "toggleviewex",            toggleviewex },
          { "tag",                     tag },
          { "tagall",                  tagallex },
          { "tagex",                   tagex },
          { "toggletag",               toggletag },
          { "toggletagex",             toggletagex },
          #if TAGALLMON_PATCH
          { "tagallmon",               tagallmon },
          #endif // TAGALLMON_PATCH
          #if TAGSWAPMON_PATCH
          { "tagswapmon",              tagswapmon},
          #endif // TAGSWAPMON_PATCH
          #if BAR_ALTERNATIVE_TAGS_PATCH
          { "togglealttag",            togglealttag },
          #endif // BAR_ALTERNATIVE_TAGS_PATCH
          #if TOGGLEFULLSCREEN_PATCH
          { "togglefullscreen",        togglefullscreen },
          #endif // TOGGLEFULLSCREEN_PATCH
          #if !FAKEFULLSCREEN_PATCH && FAKEFULLSCREEN_CLIENT_PATCH
          { "togglefakefullscreen",    togglefakefullscreen },
          #endif // FAKEFULLSCREEN_CLIENT_PATCH
          #if FULLSCREEN_PATCH
          { "fullscreen",              fullscreen },
          #endif // FULLSCREEN_PATCH
          #if MAXIMIZE_PATCH
          { "togglehorizontalmax",     togglehorizontalmax },
          { "toggleverticalmax",       toggleverticalmax },
          { "togglemax",               togglemax },
          #endif // MAXIMIZE_PATCH
          #if SCRATCHPADS_PATCH
          { "togglescratch",           togglescratch },
          #endif // SCRATCHPADS_PATCH
          #if UNFLOATVISIBLE_PATCH
          { "unfloatvisible",          unfloatvisible },
          #endif // UNFLOATVISIBLE_PATCH
          { "killclient",              killclient },
          #if WINVIEW_PATCH
          { "winview",                 winview },
          #endif // WINVIEW_PATCH
          #if XRDB_PATCH && !BAR_VTCOLORS_PATCH
          { "xrdb",                    xrdb },
          #endif // XRDB_PATCH
          #if TAGOTHERMONITOR_PATCH
          { "tagnextmonex",            tagnextmonex },
          { "tagprevmonex",            tagprevmonex },
          #endif // TAGOTHERMONITOR_PATCH
          { "quit",                    quit },
          { "setlayout",               setlayout },
          { "setlayoutex",             setlayoutex },
  };
  #elif FSIGNAL_PATCH
  /* signal definitions */
  /* signum must be greater than 0 */
  /* trigger signals using `xsetroot -name "fsignal:<signum>"` */
  static Signal signals[] = {
          /* signum       function        argument  */
          { 1,            setlayout,      {.v = 0} },
  };
  #endif // DWMC_PATCH
#+end_src

#+begin_src c :tangle config.def.h
  #if IPC_PATCH
  static const char *ipcsockpath = "/tmp/dwm.sock";
  static IPCCommand ipccommands[] = {
          IPCCOMMAND( focusmon, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( focusstack, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( incnmaster, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( killclient, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( quit, 1, {ARG_TYPE_NONE} ),
          IPCCOMMAND( setlayoutsafe, 1, {ARG_TYPE_PTR} ),
          IPCCOMMAND( setmfact, 1, {ARG_TYPE_FLOAT} ),
          IPCCOMMAND( setstatus, 1, {ARG_TYPE_STR} ),
          IPCCOMMAND( tag, 1, {ARG_TYPE_UINT} ),
          IPCCOMMAND( tagmon, 1, {ARG_TYPE_UINT} ),
          IPCCOMMAND( togglebar, 1, {ARG_TYPE_NONE} ),
          IPCCOMMAND( togglefloating, 1, {ARG_TYPE_NONE} ),
          IPCCOMMAND( toggletag, 1, {ARG_TYPE_UINT} ),
          IPCCOMMAND( toggleview, 1, {ARG_TYPE_UINT} ),
          IPCCOMMAND( view, 1, {ARG_TYPE_UINT} ),
          IPCCOMMAND( zoom, 1, {ARG_TYPE_NONE} ),
          #if BAR_ALTERNATIVE_TAGS_PATCH
          IPCCOMMAND( togglealttag, 1, {ARG_TYPE_NONE} ),
          #endif // BAR_ALTERNATIVE_TAGS_PATCH
          #if BAR_TAGGRID_PATCH
          IPCCOMMAND( switchtag, 1, {ARG_TYPE_UINT} ),
          #endif // BAR_TAGGRID_PATCH
          #if CFACTS_PATCH
          IPCCOMMAND( setcfact, 1, {ARG_TYPE_FLOAT} ),
          #endif // CFACTS_PATCH
          #if CYCLELAYOUTS_PATCH
          IPCCOMMAND( cyclelayout, 1, {ARG_TYPE_SINT} ),
          #endif // CYCLELAYOUTS_PATCH
          #if EXRESIZE_PATCH
          IPCCOMMAND( explace, 1, {ARG_TYPE_UINT} ),
          IPCCOMMAND( togglehorizontalexpand, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( toggleverticalexpand, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( togglemaximize, 1, {ARG_TYPE_SINT} ),
          #endif // EXRESIZE_PATCH
          #if !FAKEFULLSCREEN_PATCH && FAKEFULLSCREEN_CLIENT_PATCH
          IPCCOMMAND( togglefakefullscreen, 1, {ARG_TYPE_NONE} ),
          #endif // FAKEFULLSCREEN_CLIENT_PATCH
          #if FLOATPOS_PATCH
          IPCCOMMAND( floatpos, 1, {ARG_TYPE_STR} ),
          #endif // FLOATPOS_PATCH
          #if FULLSCREEN_PATCH
          IPCCOMMAND( fullscreen, 1, {ARG_TYPE_NONE} ),
          #endif // FULLSCREEN_PATCH
          #if FLEXTILE_DELUXE_LAYOUT
          IPCCOMMAND( incnstack, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( rotatelayoutaxis, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( setlayoutaxisex, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( mirrorlayout, 1, {ARG_TYPE_NONE} ),
          #endif // FLEXTILE_DELUXE_LAYOUT
          #if FOCUSURGENT_PATCH
          IPCCOMMAND( focusurgent, 1, {ARG_TYPE_NONE} ),
          #endif // FOCUSURGENT_PATCH
          #if FOCUSADJACENTTAG_PATCH
          IPCCOMMAND( viewtoleft, 1, {ARG_TYPE_NONE} ),
          IPCCOMMAND( viewtoright, 1, {ARG_TYPE_NONE} ),
          IPCCOMMAND( tagtoleft, 1, {ARG_TYPE_NONE} ),
          IPCCOMMAND( tagtoright, 1, {ARG_TYPE_NONE} ),
          IPCCOMMAND( tagandviewtoleft, 1, {ARG_TYPE_NONE} ),
          IPCCOMMAND( tagandviewtoright, 1, {ARG_TYPE_NONE} ),
          #endif // FOCUSADJACENTTAG_PATCH
          #if INPLACEROTATE_PATCH
          IPCCOMMAND( inplacerotate, 1, {ARG_TYPE_SINT} ),
          #endif // INPLACEROTATE_PATCH
          #if KEYMODES_PATCH
          IPCCOMMAND( setkeymode, 1, {ARG_TYPE_UINT} ),
          #endif // KEYMODES_PATCH
          #if MAXIMIZE_PATCH
          IPCCOMMAND( togglehorizontalmax, 1, {ARG_TYPE_NONE} ),
          IPCCOMMAND( toggleverticalmax, 1, {ARG_TYPE_NONE} ),
          IPCCOMMAND( togglemax, 1, {ARG_TYPE_NONE} ),
          #endif // MAXIMIZE_PATCH
          #if MPDCONTROL_PATCH
          IPCCOMMAND( mpdchange, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( mpdcontrol, 1, {ARG_TYPE_NONE} ),
          #endif // MPDCONTROL_PATCH
          #if MOVEPLACE_PATCH
          IPCCOMMAND( moveplace, 1, {ARG_TYPE_UINT} ),
          #endif // MOVEPLACE_PATCH
          #if MOVERESIZE_PATCH
          IPCCOMMAND( moveresize, 1, {ARG_TYPE_STR} ),
          #endif // MOVERESIZE_PATCH
          #if RIODRAW_PATCH
          IPCCOMMAND( rioresize, 1, {ARG_TYPE_NONE} ),
          #endif // RIODRAW_PATCH
          #if PUSH_PATCH || PUSH_NO_MASTER_PATCH
          IPCCOMMAND( pushdown, 1, {ARG_TYPE_NONE} ),
          IPCCOMMAND( pushup, 1, {ARG_TYPE_NONE} ),
          #endif // PUSH_PATCH / PUSH_NO_MASTER_PATCH
          #if ROTATESTACK_PATCH
          IPCCOMMAND( rotatestack, 1, {ARG_TYPE_SINT} ),
          #endif // ROTATESTACK_PATCH
          #if SCRATCHPADS_PATCH
          IPCCOMMAND( togglescratch, 1, {ARG_TYPE_UINT} ),
          #endif // SCRATCHPADS_PATCH
          #if SELFRESTART_PATCH
          IPCCOMMAND( self_restart, 1, {ARG_TYPE_NONE} ),
          #endif // SELFRESTART_PATCH
          #if SETBORDERPX_PATCH
          IPCCOMMAND( setborderpx, 1, {ARG_TYPE_SINT} ),
          #endif // SETBORDERPX_PATCH
          #if SHIFTVIEW_PATCH
          IPCCOMMAND( shiftview, 1, {ARG_TYPE_SINT} ),
          #endif // SHIFTVIEW_PATCH
          #if SHIFTVIEW_CLIENTS_PATCH
          IPCCOMMAND( shiftviewclients, 1, {ARG_TYPE_SINT} ),
          #endif // SHIFTVIEW_CLIENTS_PATCH
          #if STACKER_PATCH
          IPCCOMMAND( pushstack, 1, {ARG_TYPE_SINT} ),
          #endif // STACKER_PATCH
          #if STICKY_PATCH
          IPCCOMMAND( togglesticky, 1, {ARG_TYPE_NONE} ),
          #endif // STICKY_PATCH
          #if SWAPFOCUS_PATCH && PERTAG_PATCH
          IPCCOMMAND( swapfocus, 1, {ARG_TYPE_SINT} ),
          #endif // SWAPFOCUS_PATCH
          #if SWITCHCOL_PATCH
          IPCCOMMAND( switchcol, 1, {ARG_TYPE_NONE} ),
          #endif // SWITCHCOL_PATCH
          #if TAGALLMON_PATCH
          IPCCOMMAND( tagallmon, 1, {ARG_TYPE_SINT} ),
          #endif // TAGALLMON_PATCH
          #if TAGOTHERMONITOR_PATCH
          IPCCOMMAND( tagnextmonex, 1, {ARG_TYPE_UINT} ),
          IPCCOMMAND( tagprevmonex, 1, {ARG_TYPE_UINT} ),
          #endif // TAGOTHERMONITOR_PATCH
          #if TAGSWAPMON_PATCH
          IPCCOMMAND( tagswapmon, 1, {ARG_TYPE_SINT} ),
          #endif // TAGSWAPMON_PATCH
          #if TOGGLEFULLSCREEN_PATCH
          IPCCOMMAND( togglefullscreen, 1, {ARG_TYPE_NONE} ),
          #endif // TOGGLEFULLSCREEN_PATCH
          #if TRANSFER_PATCH
          IPCCOMMAND( transfer, 1, {ARG_TYPE_NONE} ),
          #endif // TRANSFER_PATCH
          #if TRANSFER_ALL_PATCH
          IPCCOMMAND( transferall, 1, {ARG_TYPE_NONE} ),
          #endif // TRANSFER_ALL_PATCH
          #if UNFLOATVISIBLE_PATCH
          IPCCOMMAND( unfloatvisible, 1, {ARG_TYPE_NONE} ),
          #endif // UNFLOATVISIBLE_PATCH
          #if VANITYGAPS_PATCH
          IPCCOMMAND( incrgaps, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( incrigaps, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( incrogaps, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( incrihgaps, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( incrivgaps, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( incrohgaps, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( incrovgaps, 1, {ARG_TYPE_SINT} ),
          IPCCOMMAND( togglegaps, 1, {ARG_TYPE_NONE} ),
          IPCCOMMAND( defaultgaps, 1, {ARG_TYPE_NONE} ),
          IPCCOMMAND( setgapsex, 1, {ARG_TYPE_SINT} ),
          #endif // VANITYGAPS_PATCH
          #if WINVIEW_PATCH
          IPCCOMMAND( winview, 1, {ARG_TYPE_NONE} ),
          #endif // WINVIEW_PATCH
          #if XRDB_PATCH && !BAR_VTCOLORS_PATCH
          IPCCOMMAND( xrdb, 1, {ARG_TYPE_NONE} ),
          #endif // XRDB_PATCH
  };
  #endif // IPC_PATCH
#+end_src

* Status Bar
** Polybar

To learn more about how to configure Polybar go to https://github.com/polybar/polybar

*** General

**** Colors

#+begin_src conf :tangle polybar/config.ini
  [colors]
  dark-gray                 = ${xrdb:background:#282A36}
  light-gray                = ${xrdb:color8:#4D4D4D}
  lighter-gray              = ${xrdb:color7:#BFBFBF}
  white                     = ${xrdb:foreground:#F8F8F2}
  purple                    = ${xrdb:color4:#BD93F9}
  blue                      = ${xrdb:color6:#8BE9FD}
  red                       = ${xrdb:color1:#FF5555}
  pink                      = ${xrdb:color5:#FF79C6}
  yellow                    = ${xrdb:color3:#F1FA8C}
  green                     = ${xrdb:color2:#50FA7B}
  orange                    = ${xrdb:color16:#FFB86C}

  background                = ${self.dark-gray}
  background-alt            = ${self.light-gray}
  foreground                = ${self.white}
  foreground-alt            = ${self.lighter-gray}
  primary                   = ${self.purple}
  secondary                 = ${self.blue}
  alert                     = ${self.red}

  ; left
  powermenu                 = ${self.blue}
  date                      = ${self.yellow}
  time                      = ${self.purple}
  media-playing             = ${self.green}

  ; center
  dwm-focused-foreground    = ${self.primary}
  dwm-focused-background    = ${self.background}
  dwm-unfocused-foreground  = ${self.pink}
  dwm-unfocused-background  = ${self.background}
  dwm-visible-foreground    = ${self.secondary}
  dwm-visible-background    = ${self.background}
  dwm-urgent-foreground     = ${self.alert}
  dwm-urgent-background     = ${self.background}
  dwm-empty-foreground      = ${self.foreground}
  dwm-empty-background      = ${self.background}

  ; right
  kernel                    = ${self.orange}
  cpu                       = ${self.blue}
  memory                    = ${self.red}
  filesystem                = ${self.green}
  dunst-notification-status = ${self.yellow}
#+end_src

**** Sizes

#+begin_src conf :tangle polybar/config.ini
  [sizes]
  bar-height     = ${xrdb:polybar.bar-height:25}
  module-margin  = ${xrdb:polybar.module-margin:2}
  module-padding = ${xrdb:polybar.module-padding:2}
  tray-maxsize   = ${xrdb:polybar.tray-maxsize:15}
  tray-scale     = ${xrdb:polybar.tray-scale:1}
  maxlen         = ${xrdb:polybar.maxlen:50}
#+end_src

**** Intervals

Define module update intervals in seconds.

| Seconds | Minutes | Hours |
|---------+---------+-------|
|     900 |      15 |  0.25 |
|   86400 |    1440 |    24 |

#+begin_src conf :tangle polybar/config.ini
  [intervals]
  cpu                       = 1
  date                      = 1
  time                      = 1
  filesystem                = 900
  memory                    = 1
  media-playing             = 1
  dunst-notification-status = 1
  kernel                    = 86400
#+end_src

**** Global Window Manager

#+begin_src conf :tangle polybar/config.ini
  [global/wm]
  ; Adjust the _NET_WM_STRUT_PARTIAL top value
  ;   Used for top aligned bars
  margin-bottom = 0

  ; Adjust the _NET_WM_STRUT_PARTIAL bottom value
  ;   Used for bottom aligned bars
  margin-top = 0
#+end_src

*** Bars

#+begin_src conf :tangle polybar/config.ini
  [bar/mybar]
  ; Use either of the following command to list available outputs:
  ; If unspecified, the application will pick the first one it finds.
  ; $ polybar -m | cut -d ':' -f 1
  ; $ xrandr -q | grep " connected" | cut -d ' ' -f1
  ; If no monitor is given, the primary monitor is used if it exists
  monitor = ${env:MONITOR}

  ; Use the specified monitor as a fallback if the main one is not found.
  ; monitor-fallback =

  ; Require the monitor to be in connected state
  ; XRandR sometimes reports my monitor as being disconnected (when in use)
  monitor-strict = false

  ; Use fuzzy matching for monitors (only ignores dashes -)
  ; Useful when monitors are named differently with different drivers.
  monitor-exact = true

  ; Tell the Window Manager not to configure the window.
  ; Use this to detach the bar if your WM is locking its size/position.
  ; Note: With this most WMs will no longer reserve space for 
  ; the bar and it will overlap other windows. You need to configure
  ; your WM to add a gap where the bar will be placed.
  override-redirect = false

  ; Put the bar at the bottom of the screen
  bottom = false

  ; Prefer fixed center position for the `modules-center` block. 
  ; The center block will stay in the middle of the bar whenever
  ; possible. It can still be pushed around if other blocks need
  ; more space.
  ; When false, the center block is centered in the space between 
  ; the left and right block.
  fixed-center = true

  ; Dimension defined as pixel value (e.g. 35) or percentage (e.g. 50%),
  ; the percentage can optionally be extended with a pixel offset like so:
  ; 50%:-10, this will result in a width or height of 50% minus 10 pixels
  width = 100%
  height = ${sizes.bar-height}

  ; Offset defined as pixel value (e.g. 35) or percentage (e.g. 50%)
  ; the percentage can optionally be extended with a pixel offset like so:
  ; 50%:-10, this will result in an offset in the x or y direction 
  ; of 50% minus 10 pixels
  offset-x = 0
  offset-y = 0

  ; Background ARGB color (e.g. #f00, #ff992a, #ddff1023)
  background = ${colors.background}

  ; Foreground ARGB color (e.g. #f00, #ff992a, #ddff1023)
  foreground = ${colors.foreground}

  ; Background gradient (vertical steps)
  ;   background-[0-9]+ = #aarrggbb
  ; background-0 = 

  ; Value used for drawing rounded corners
  ; Note: This shouldn't be used together with border-size because the border 
  ; doesn't get rounded. For this to work you may also need to enable 
  ; pseudo-transparency or use a compositor like compton.
  ; Individual top/bottom values can be defined using:
  ;   radius-{top,bottom}
  radius = 0.0

  ; Under-/overline pixel size and argb color
  ; Individual values can be defined using:
  ;   {overline,underline}-size
  ;   {overline,underline}-color
  line-size = 0
  line-color = #f00

  ; Values applied to all borders
  ; Individual side values can be defined using:
  ;   border-{left,top,right,bottom}-size
  ;   border-{left,top,right,bottom}-color
  ; The top and bottom borders are added to the bar height, so the effective
  ; window height is:
  ;   height + border-top-size + border-bottom-size
  ; Meanwhile the effective window width is defined entirely by the width key and
  ; the border is placed within this area. So you effectively only have the
  ; following horizontal space on the bar:
  ;   width - border-right-size - border-left-size
  ; border-size can be defined as pixel value (e.g. 35) or percentage (e.g. 50%),
  ; the percentage can optionally be extended with a pixel offset like so:
  ; 50%:-10, this will result in 50% minus 10 pixels. The percentage is relative
  ; to the monitor width or height depending on the border direction. 
  ; border-size = 
  ; border-color = 

  ; Number of spaces to add at the beginning/end of the bar
  ; Individual side values can be defined using:
  ;   padding-{left,right}
  padding-right = ${self.module-margin}

  ; Number of spaces to add before/after each module
  ; Individual side values can be defined using:
  ;   module-margin-{left,right}
  module-margin = ${sizes.module-margin}

  ; Fonts are defined using <font-name>;<vertical-offset>
  ; Font names are specified using a fontconfig pattern.
  ;   font-0 = NotoSans-Regular:size=8;2
  ;   font-1 = MaterialIcons:size=10
  ;   font-2 = Termsynu:size=8;-1
  ;   font-3 = FontAwesome:size=10
  ; See the Fonts wiki page for more details
  font-0 = "NotoSansDisplay Nerd Font:size=11;3"
  font-1 = "FiraCode Nerd Font:size=11;3"
  font-2 = "Droid Sans Mono:size=11;3"
  font-3 = "IPAPGothic:size=11;3"

  ; Modules are added to one of the available blocks
  ;   modules-left = cpu ram
  ;   modules-center = xwindow xbacklight
  ;   modules-right = ipc clock
  modules-left   = powermenu date time media-playing
  modules-center = dwm
  modules-right  = kernel cpu memory filesystem

  ; The separator will be inserted between the output of each module
  separator = ""

  ; This value is used to add extra spacing between elements
  ; @deprecated: This parameter will be removed in an upcoming version
  ; spacing = 0

  ; Opacity value between 0.0 and 1.0 used on fade in/out
  dim-value = 1.0

  ; Value to be used to set the WM_NAME atom
  ; If the value is empty or undefined, the atom value
  ; will be created from the following template: polybar-[BAR]_[MONITOR]
  ; NOTE: The placeholders are not available for custom values
  ; wm-name =

  ; Locale used to localize various module data (e.g. date)
  ; Expects a valid libc locale, for example: sv_SE.UTF-8
  locale = en_US.utf8

  ; Position of the system tray window
  ; If empty or undefined, tray support will be disabled
  ; NOTE: A center aligned tray will cover center aligned modules
  ;
  ; Available positions:
  ;   left
  ;   center
  ;   right
  ;   none
  tray-position = ${env:TRAY_POS}

  ; If true, the bar will not shift its
  ; contents when the tray changes
  tray-detached = false

  ; Tray icon max size
  tray-maxsize = ${sizes.tray-maxsize}

  ; DEPRECATED! Since 3.3.0 the tray always uses pseudo-transparency
  ; Enable pseudo transparency
  ; Will automatically be enabled if a fully transparent
  ; background color is defined using `tray-background`
  ; tray-transparent = false

  ; Background color for the tray container 
  ; ARGB color (e.g. #f00, #ff992a, #ddff1023)
  ; By default the tray container will use the bar
  ; background color.
  tray-background = ${colors.background}

  ; Tray offset defined as pixel value (e.g. 35) or percentage (e.g. 50%)
  tray-offset-x = 0
  tray-offset-y = 0

  ; Pad the sides of each tray icon
  tray-padding = ${self.module-margin}

  ; Scale factor for tray clients
  tray-scale = ${sizes.tray-scale}

  ; Restack the bar window. Fixes the issue where the
  ; bar is being drawn on top of fullscreen windows.
  ;
  ; Currently supported options:
  ;   generic (works in xmonad, may work with other WMs)
  ;   bspwm
  ;   i3 (requires: `override-redirect = true`)
  ; wm-restack = generic

  ; Set a DPI values used when rendering text
  ; This only affects scalable fonts
  ; Set this to 0 to let polybar calculate the dpi from the screen size.
  ; dpi = 
  dpi-x = ${xrdb:dpi}
  dpi-y = ${xrdb:dpi}

  ; Enable support for inter-process messaging
  ; See the Messaging wiki page for more details.
  enable-ipc = true

  ; Fallback click handlers that will be called if
  ; there's no matching module handler found.
  ; click-left = 
  ; click-middle = 
  ; click-right =
  ; scroll-up =
  ; scroll-down =
  ; double-click-left =
  ; double-click-middle =
  ; double-click-right =

  ; Requires polybar to be built with xcursor support (xcb-util-cursor)
  ; Possible values are:
  ; - default   : The default pointer as before, can also be an empty string (default)
  ; - pointer   : Typically in the form of a hand
  ; - ns-resize : Up and down arrows, can be used to indicate scrolling
  cursor-click = pointer
  cursor-scroll = ns-resize
#+end_src

*** Modules

**** Power Menu

#+begin_src conf :tangle polybar/config.ini
  [module/powermenu]
  type = custom/text
  content = "  "

  ; "content" has the same properties as "format-NAME"
  ; content-background = #000
  content-foreground = ${colors.powermenu}
  content-padding = ${bar/mybar.module-margin}

  ; "click-(left|middle|right)" will be executed using "/bin/sh -c $COMMAND"
  ; click-left = notify-send left
  ; click-middle = notify-send middle
  ; click-right = notify-send right
  click-left = "rofi -show combi"
  click-right = "/home/sravan/.scripts/control-center.sh --rofi"

  ; "scroll-(up|down)" will be executed using "/bin/sh -c $COMMAND"
  ; scroll-up = notify-send scroll up
  ; scroll-down = notify-send scroll down
#+end_src

**** DWM

#+begin_src conf :tangle polybar/config.ini
  [module/dwm]
  type = internal/dwm
  ; format = <label-tags> <label-layout> <label-floating> <label-title>
  format = <label-tags>
  ; Path to dwm socket (default: /tmp/dwm.sock)
  ; socket-path = /tmp/dwm.sock

  ; Left-click to view tag, right-click to toggle tag view
  enable-tags-click = true
  ; Scroll to cycle between available tags
  enable-tags-scroll = true
  ; If true and enable-tags-scroll = true, scrolling will view all tags regardless if occupied
  tags-scroll-empty = true
  ; If true and enable-tags-scroll = true, scrolling will cycle through tags backwards
  tags-scroll-reverse = false
  ; If true and enable-tags-scroll = true, wrap active tag when scrolling
  tags-scroll-wrap = true
  ; Left-click to set secondary layout, right-click to switch to previous layout
  enable-layout-click = true
  ; Scroll to cycle between available layouts
  enable-layout-scroll = false
  ; Wrap when scrolling and reaching beginning/end of layouts
  layout-scroll-wrap = true
  ; Reverse scroll direction
  layout-scroll-reverse = false

  ; If enable-layout-click = true, clicking the layout symbol will switch to this layout
  secondary-layout-symbol = [M]

  ; Separator in between shown tags
  ; label-separator = |

  ; Title of currently focused window
  ; Available tokens:
  ;   %title%
  label-title = %title%
  label-title-padding = ${sizes.module-padding}
  label-title-foreground = ${colors.dwm-focused-background}
  label-title-maxlen = ${sizes.maxlen}

  ; Symbol of current layout
  ; Available tokens:
  ;   %symbol%
  label-layout = %symbol%
  label-layout-foreground = ${colors.green}
  label-layout-background = ${colors.background}
  label-layout-underline = ${colors.background}
  label-layout-padding = ${sizes.module-padding}

  ; Text to show when currently focused window is floating
  label-floating = "(F)"

  ; States: focused, unfocused, visible, urgent, empty
  ; Available tokens:
  ;   %name%

  ; focused = Selected tag on focused monitor
  label-focused = %name%
  label-focused-foreground = ${colors.dwm-focused-foreground}
  label-focused-background = ${colors.dwm-focused-background}
  label-focused-underline = ${colors.dwm-focused-background}
  label-focused-padding = ${sizes.module-padding}

  ; unfocused = Unselected tag on unselected monitor
  label-unfocused = %name%
  label-unfocused-foreground = ${colors.dwm-unfocused-foreground}
  label-unfocused-background = ${colors.dwm-unfocused-background}
  label-unfocused-underline = ${colors.dwm-unfocused-background}
  label-unfocused-padding = ${sizes.module-padding}

  ; visible = Unselected tag, but occupied tag on any monitor
  label-visible = %name%
  label-visible-foreground = ${colors.dwm-visible-foreground}
  label-visible-background = ${colors.dwm-visible-background}
  label-visible-underline = ${colors.dwm-visible-background}
  label-visible-padding = ${sizes.module-padding}

  ; urgent = Unselected tag with window that has urgency hint set
  label-urgent = %name%
  label-urgent-foreground = ${colors.dwm-urgent-foreground}
  label-urgent-background = ${colors.dwm-urgent-background}
  label-urgent-underline = ${colors.dwm-urgent-background}
  label-urgent-padding = ${sizes.module-padding}

  ; empty = Unselected and unoccupied tag
  ; This can be set to an empty string to hide empty tags
  label-empty = %name%
  label-empty-foreground = ${colors.dwm-empty-foreground}
  label-empty-background = ${colors.dwm-empty-background}
  label-empty-underline = ${colors.dwm-empty-background}
  label-empty-padding = ${sizes.module-padding}
#+end_src

**** Media Playing (Playerctl)

***** Module

#+begin_src conf :tangle polybar/config.ini
  [module/media-playing]
  type = custom/script

  ; Available tokens:
  ;   %counter%
  ; Command to be executed (using "/bin/sh -c [command]")
  exec = ~/.config/dwm-flexipatch/polybar/scripts/get-media-playing.sh

  ; Conditional command that, if defined, needs to exit successfully
  ; before the main exec command is invoked.
  ; Default: ""
  ; exec-if = pgrep -x myservice

  ; Will the script output continous content?
  ; Default: false
  tail = false

  ; Seconds to sleep between updates
  ; Default: 5 (0 if `tail = true`)
  interval = ${intervals.media-playing}

  ; Available tags:
  ;   <output> - deprecated
  ;   <label> (default)
  format = <label>
  ; format-background = ${colors.background}
  ; format-foreground =
  ; format-padding = 4

  ; Available tokens:
  ;   %output%
  ; Default: %output%
  label = %output%
  label-foreground = ${colors.media-playing}
  label-maxlen = ${sizes.maxlen}

  ; Available tokens:
  ;   %counter%
  ;   %pid%
  ;
  ; "click-(left|middle|right)" will be executed using "/bin/sh -c [command]"
  click-left = "/home/sravan/.scripts/playerctl.sh --play-pause"
  ; click-middle = echo middle %counter%
  click-right = "/home/sravan/.scripts/playerctl.sh --change"
  ; double-click-left = echo double left %counter%
  ; double-click-middle = echo double middle %counter%
  ; double-click-right = echo double right %counter%

  ; Available tokens:
  ;   %counter%
  ;   %pid%
  ;
  ; "scroll-(up|down)" will be executed using "/bin/sh -c [command]"
  scroll-up = "/home/sravan/.scripts/playerctl.sh --next"
  scroll-down = "/home/sravan/.scripts/playerctl.sh --prev"
#+end_src

***** Script

#+begin_src shell :shebang #!/bin/bash :tangle polybar/scripts/get-media-playing.sh
  mediaStatus=$(playerctl --player=playerctld metadata 2>&1)

  if [[ "$mediaStatus" == "No player could handle this command" ]]; then
          echo "  N/A"
  else
          artist=$(playerctl --player=playerctld metadata --format '{{ artist }}')
          title=$(playerctl --player=playerctld metadata --format '{{ title }}')
          status=$(playerctl --player=playerctld metadata --format '{{ status }}')

          if [[ $status == "Paused" ]]; then
                  status_icon=" "
          elif [[ $status == "Playing" ]]; then
                  status_icon=" "
          fi

          echo "$status_icon $artist - $title"
  fi
#+end_src

**** Date

#+begin_src conf :tangle polybar/config.ini
  [module/date]
  type = internal/date

  ; Seconds to sleep between updates
  ; Default: 1.0
  interval = ${intervals.date}

  ; See "https://en.cppreference.com/w/cpp/io/manip/put_time" for details on how to format the date string
  ; NOTE: if you want to use syntax tags here you need to use %%{...}
  date = %a %D

  ; Optional time format
  ; time = %X

  ; if `date-alt` or `time-alt` is defined, clicking
  ; the module will toggle between formats
  date-alt = %A, %B %d, %Y
  ; time-alt = %H:%M:%S

  ; Available tags:
  ;   <label> (default)
  format = <label>

  ; Available tokens:
  ;   %date%
  ;   %time%
  ; Default: %date%
  label = " %date%"
  ; label-font = 3
  label-foreground = ${colors.date}
#+end_src

**** Time

#+begin_src conf :tangle polybar/config.ini
  [module/time]
  type = internal/date

  ; Seconds to sleep between updates
  ; Default: 1.0
  interval = ${intervals.time}

  ; See "https://en.cppreference.com/w/cpp/io/manip/put_time" for details on how to format the date string
  ; NOTE: if you want to use syntax tags here you need to use %%{...}
  ; date = %a %x

  ; Optional time format
  time = %X

  ; if `date-alt` or `time-alt` is defined, clicking
  ; the module will toggle between formats
  ; date-alt = %A, %B %d, %Y
  time-alt = UTC%z (%Z)

  ; Available tags:
  ;   <label> (default)
  format = <label>

  ; Available tokens:
  ;   %date%
  ;   %time%
  ; Default: %date%
  label = " %time%"
  ; label-font = 3
  label-foreground = ${colors.time}
#+end_src

**** Kernel

#+begin_src conf :tangle polybar/config.ini
  [module/kernel]
  type = custom/script

  ; Available tokens:
  ;   %counter%
  ; Command to be executed (using "/bin/sh -c [command]")
  exec = echo " $(uname -r)"

  ; Conditional command that, if defined, needs to exit successfully
  ; before the main exec command is invoked.
  ; Default: ""
  ; exec-if = pgrep -x myservice

  ; Will the script output continous content?
  ; Default: false
  tail = false

  ; Seconds to sleep between updates
  ; Default: 5 (0 if `tail = true`)
  interval = ${intervals.kernel}

  ; Available tags:
  ;   <output> - deprecated
  ;   <label> (default)
  format = <label>
  format-background = ${colors.background}
  format-foreground = ${colors.kernel}
  ; format-padding = 4

  ; Available tokens:
  ;   %output%
  ; Default: %output%
  label = %output%

  ; Available tokens:
  ;   %counter%
  ;   %pid%
  ;
  ; "click-(left|middle|right)" will be executed using "/bin/sh -c [command]"
  ; click-left = echo left %counter%
  ; click-middle = echo middle %counter%
  ; click-right = echo right %counter%
  ; double-click-left = echo double left %counter%
  ; double-click-middle = echo double middle %counter%
  ; double-click-right = echo double right %counter%

  ; Available tokens:
  ;   %counter%
  ;   %pid%
  ;
  ; "scroll-(up|down)" will be executed using "/bin/sh -c [command]"
  ; scroll-up = echo scroll up %counter%
  ; scroll-down = echo scroll down %counter%
#+end_src

**** CPU

#+begin_src conf :tangle polybar/config.ini
  [module/cpu]
  type = internal/cpu

  ; Seconds to sleep between updates
  ; Default: 1
  interval = ${intervals.cpu}

  ; Available tags:
  ;   <label> (default)
  ;   <bar-load>
  ;   <ramp-load>
  ;   <ramp-coreload>
  format = %{A3:kitty -e bpytop &:} <label> %{A}

  ; Available tokens:
  ;   %percentage% (default) - total cpu load averaged over all cores
  ;   %percentage-sum% - Cumulative load on all cores
  ;   %percentage-cores% - load percentage for each core
  ;   %percentage-core[1-9]% - load percentage for specific core
  label =  %percentage%%
  label-foreground = ${colors.cpu}

  ; Spacing between individual per-core ramps
  ramp-coreload-spacing = 1
  ramp-coreload-0 = 
  ramp-coreload-1 = 
  ramp-coreload-2 = 
  ramp-coreload-3 = 
  ramp-coreload-4 = 
  ramp-coreload-5 = 
  ramp-coreload-6 = 
  ramp-coreload-7 = 
  ramp-coreload-foreground = ${colors.cpu}
#+end_src

**** Memory

#+begin_src conf :tangle polybar/config.ini
  [module/memory]
  type = internal/memory

  ; Seconds to sleep between updates
  ; Default: 1
  interval = ${intervals.memory}

  ; Available tags:
  ;   <label> (default)
  ;   <bar-used>
  ;   <bar-free>
  ;   <ramp-used>
  ;   <ramp-free>
  ;   <bar-swap-used>
  ;   <bar-swap-free>
  ;   <ramp-swap-used>
  ;   <ramp-swap-free>
  format = %{A3:kitty -e bpytop &:} <label> %{A}

  ; Available tokens:
  ;   %percentage_used% (default)
  ;   %percentage_free%
  ;   %gb_used%
  ;   %gb_free%
  ;   %gb_total%
  ;   %mb_used%
  ;   %mb_free%
  ;   %mb_total%
  ;   %percentage_swap_used%
  ;   %percentage_swap_free%
  ;   %mb_swap_total%
  ;   %mb_swap_free%
  ;   %mb_swap_used%
  ;   %gb_swap_total%
  ;   %gb_swap_free%
  ;   %gb_swap_used%

  label =  %percentage_used%%
  label-foreground = ${colors.memory}

  ; Only applies if <bar-used> is used
  bar-used-indicator =
  bar-used-width = 50
  bar-used-foreground-0 = #55aa55
  bar-used-foreground-1 = #557755
  bar-used-foreground-2 = #f5a70a
  bar-used-foreground-3 = #ff5555
  bar-used-fill = 
  bar-used-empty = 
  bar-used-empty-foreground = #444444

  ; Only applies if <ramp-used> is used
  ramp-used-0 = 
  ramp-used-1 = 
  ramp-used-2 = 
  ramp-used-3 = 
  ramp-used-4 = 
  ramp-used-5 = 
  ramp-used-6 = 
  ramp-used-7 = 
  ramp-used-foreground = ${colors.memory}

  ; Only applies if <ramp-free> is used
  ramp-free-0 = 
  ramp-free-1 = 
  ramp-free-2 = 
  ramp-free-3 = 
  ramp-free-4 = 
  ramp-free-5 = 
  ramp-free-6 = 
  ramp-free-7 = 
  ramp-free-foreground = ${colors.memory}
#+end_src

**** Filesystem

#+begin_src conf :tangle polybar/config.ini
  [module/filesystem]
  type = internal/fs

  ; Mountpoints to display
  mount-0 = /home

  ; Seconds to sleep between updates
  ; Default: 30
  interval = ${intervals.filesystem}

  ; Display fixed precision values
  ; Default: false
  fixed-values = true

  ; Spacing between entries
  ; Default: 2
  spacing = ${bar/mybar.module-margin}

  ; Available tags:
  ;   <label-mounted> (default)
  ;   <bar-free>
  ;   <bar-used>
  ;   <ramp-capacity>
  format-mounted = %{A3:filelight &:} <label-mounted> %{A}

  ; Available tags:
  ;   <label-unmounted> (default)
  format-unmounted = %{A3:gnome-disks &:} <label-unmounted> %{A}

  ; Available tokens:
  ;   %mountpoint%
  ;   %type%
  ;   %fsname%
  ;   %percentage_free%
  ;   %percentage_used%
  ;   %total%
  ;   %free%
  ;   %used%
  ; Default: %mountpoint% %percentage_free%%
  label-mounted =  %percentage_used%%
  label-mounted-foreground = ${colors.filesystem}

  ; Available tokens:
  ;   %mountpoint%
  ; Default: %mountpoint% is not mounted
  label-unmounted = %mountpoint% is not mounted
  label-unmounted-foreground = ${colors.filesystem}
#+end_src

**** Dunst Notification Status

***** Module

#+begin_src conf :tangle polybar/config.ini
  [module/dunst-notification-status]
  type = custom/script

  ; Available tokens:
  ;   %counter%
  ; Command to be executed (using "/bin/sh -c [command]")
  exec = ~/.config/dwm-flexipatch/polybar/scripts/dunst-notification-status.sh

  ; Conditional command that, if defined, needs to exit successfully
  ; before the main exec command is invoked.
  ; Default: ""
  ; exec-if = pgrep -x myservice

  ; Will the script output continous content?
  ; Default: false
  tail = false

  ; Seconds to sleep between updates
  ; Default: 5 (0 if `tail = true`)
  interval = ${intervals.dunst-notification-status}

  ; Available tags:
  ;   <output> - deprecated
  ;   <label> (default)
  format = <label>
  ; format-background = ${colors.background}
  ; format-foreground =
  ; format-padding = 4

  ; Available tokens:
  ;   %output%
  ; Default: %output%
  label = %output%
  label-foreground = ${colors.dunst-notification-status}
  ; label-maxlen =

  ; Available tokens:
  ;   %counter%
  ;   %pid%
  ;
  ; "click-(left|middle|right)" will be executed using "/bin/sh -c [command]"
  click-left = "/home/sravan/.scripts/dunst.sh --dnd"
  ; click-middle = echo middle %counter%
  click-right = "/home/sravan/.scripts/dunst.sh --history"
  ; double-click-left = echo double left %counter%
  ; double-click-middle = echo double middle %counter%
  ; double-click-right = echo double right %counter%

  ; Available tokens:
  ;   %counter%
  ;   %pid%
  ;
  ; "scroll-(up|down)" will be executed using "/bin/sh -c [command]"
  ; scroll-up =
  ; scroll-down =
#+end_src

***** Script

#+begin_src shell :shebang #!/bin/bash :tangle polybar/scripts/dunst-notification-status.sh
  # Check if dunst is running
  if pgrep -x "dunst" > /dev/null
  then
      is_paused=$(dunstctl is-paused)
    
      if [[ $is_paused == 'false' ]]; then
          status_icon=" on"
      elif [[ $is_paused == 'true' ]]; then
          status_icon=" off"
      fi
  else
      status_icon=" off"
  fi

  echo $status_icon
#+end_src

*** Launch Script

#+begin_src shell :shebang #!/bin/bash :tangle polybar/launch.sh
  BAR="mybar"
  CONFIG="~/.config/dwm-flexipatch/polybar/config.ini"
  NUM_MONITORS=0
  CONNECTED_MONITORS=$(xrandr --query | grep " connected" | cut -d" " -f1)
  TRAY_POS="right"

  killall -q polybar
  while pgrep -u $UID -x polybar >/dev/null; do sleep 1; done

  rm /tmp/polybar.pids
  sleep 1

  for m in $CONNECTED_MONITORS; do
      let "NUM_MONITORS+=1"
  done

  if [ $NUM_MONITORS == 1 ]; then
      # Launch on only monitor w/ systray
      MONITOR=$CONNECTED_MONITORS TRAY_POS=$TRAY_POS polybar --reload -c $CONFIG $BAR &
  else
      PRIMARY=$(xrandr --query | grep " connected" | grep "primary" | cut -d" " -f1)
      OTHERS=$(xrandr --query | grep " connected" | grep -v "primary" | cut -d" " -f1)

      # Launch on primary monitor w/ systray
      MONITOR=$PRIMARY TRAY_POS=$TRAY_POS polybar --reload -c $CONFIG $BAR &
      sleep 1

      # Launch on all other monitors w/o systray
      for m in $OTHERS; do
          MONITOR=$m TRAY_POS=none polybar --reload -c $CONFIG $BAR &
      done
  fi

  echo "$!" >>/tmp/polybar.pids
#+end_src
