#+TITLE: Personal DWM Configuration with Polybar
#+AUTHOR: Sravan Balaji
#+AUTO_TANGLE: t
#+STARTUP: showeverything

* Table of Contents :TOC_3:noexport:
- [[#welcome][Welcome]]
- [[#dwm---dynamic-window-manager][dwm - dynamic window manager]]
  - [[#requirements][Requirements]]
  - [[#installation][Installation]]
  - [[#running-dwm][Running dwm]]
- [[#dwm-flexipatch][dwm flexipatch]]
  - [[#changelog][Changelog]]
  - [[#patches-included][Patches Included]]
  - [[#layouts-included][Layouts Included]]
- [[#patches][Patches]]
  - [[#bar-modules][Bar Modules]]
    - [[#awesome-bar][Awesome Bar]]
    - [[#dwm-blocks][DWM Blocks]]
    - [[#fancy-bar][Fancy Bar]]
    - [[#flex-win-title][Flex Win Title]]
    - [[#layout-menu][Layout Menu]]
    - [[#layout-symbol][Layout Symbol]]
    - [[#powerline][Powerline]]
    - [[#tab-groups][Tab Groups]]
    - [[#tag-grid][Tag Grid]]
    - [[#tag-preview][Tag Preview]]
    - [[#status][Status]]
    - [[#status-button][Status Button]]
    - [[#status-cmd][Status CMD]]
    - [[#status-2d][Status 2D]]
    - [[#systray][Systray]]
    - [[#tags][Tags]]
    - [[#window-icon][Window Icon]]
    - [[#window-title][Window Title]]
    - [[#title-padding][Title Padding]]
  - [[#bar-options][Bar Options]]
    - [[#active-tag-indicator][Active Tag Indicator]]
    - [[#alpha][Alpha]]
    - [[#alternative-tags][Alternative Tags]]
    - [[#alternative-tags-decoration][Alternative Tags Decoration]]
    - [[#anybar][Anybar]]
    - [[#border][Border]]
    - [[#centered-window-name][Centered Window Name]]
    - [[#client-indicator][Client Indicator]]
    - [[#dmenu-match-top][Dmenu Match Top]]
    - [[#extra-status][Extra Status]]
    - [[#ewmh-tags][EWMH Tags]]
    - [[#height][Height]]
    - [[#hide-vacant-tags][Hide Vacant Tags]]
    - [[#holdbar][Holdbar]]
    - [[#ignore-xft-errors-when-drawing-text][Ignore Xft Errors When Drawing Text]]
    - [[#no-color-emoji][No Color Emoji]]
    - [[#padding][Padding]]
    - [[#pango][Pango]]
    - [[#static-status][Static Status]]
    - [[#status-all-monitors][Status All Monitors]]
    - [[#status-colors][Status Colors]]
    - [[#status-padding][Status Padding]]
    - [[#vt-colors][VT Colors]]
    - [[#window-title-actions][Window Title Actions]]
  - [[#other][Other]]
    - [[#alt-tab][Alt Tab]]
    - [[#always-center][Always Center]]
    - [[#aspect-resize][Aspect Resize]]
    - [[#attach-above][Attach Above]]
    - [[#attach-aside][Attach Aside]]
    - [[#attach-below][Attach Below]]
    - [[#attach-bottom][Attach Bottom]]
    - [[#auto-start][Auto Start]]
    - [[#auto-resize][Auto Resize]]
    - [[#bidi-right-to-left-languages][Bidi (Right to Left Languages)]]
    - [[#center][Center]]
    - [[#center-transient][Center Transient]]
    - [[#cfacts][CFacts]]
    - [[#cmd-customize][CMD Customize]]
    - [[#combo][Combo]]
    - [[#cool-auto-start][Cool Auto Start]]
    - [[#cycle-layouts][Cycle Layouts]]
    - [[#decoration-hints][Decoration Hints]]
    - [[#distribute-tags][Distribute Tags]]
    - [[#do-not-die-on-color-allocation-failure][Do Not Die on Color Allocation Failure]]
    - [[#drag-cfact][Drag CFact]]
    - [[#drag-mfact][Drag MFact]]
    - [[#dwmc][DWMC]]
    - [[#empty-view][Empty View]]
    - [[#extension-resize][Extension Resize]]
    - [[#fake-fullscreen][Fake Fullscreen]]
    - [[#fake-fullscreen-client][Fake Fullscreen Client]]
    - [[#float-position][Float Position]]
    - [[#focus-adjacent-tag][Focus Adjacent Tag]]
    - [[#focus-direction][Focus Direction]]
    - [[#focus-follow-mouse][Focus Follow Mouse]]
    - [[#focus-master][Focus Master]]
    - [[#focus-master-return][Focus Master Return]]
    - [[#focus-on-click][Focus On Click]]
    - [[#focus-urgent][Focus Urgent]]
    - [[#focus-on-net-active][Focus On Net Active]]
    - [[#fake-signals][Fake Signals]]
    - [[#fullscreen][Fullscreen]]
    - [[#in-place-rotate][In-Place Rotate]]
    - [[#insets][Insets]]
    - [[#ipc][IPC]]
    - [[#is-permanent][Is Permanent]]
    - [[#key-modes][Key Modes]]
    - [[#kill-unselected][Kill Unselected]]
    - [[#lg3d][LG3d]]
    - [[#lose-fullscreen][Lose Fullscreen]]
    - [[#maximize-floating-windows][Maximize Floating Windows]]
    - [[#music-player-daemon][Music Player Daemon]]
    - [[#monitor-rules][Monitor Rules]]
    - [[#monocle-symbol][Monocle Symbol]]
    - [[#move-place][Move Place]]
    - [[#move-resize][Move Resize]]
    - [[#move-stack][Move Stack]]
    - [[#name-tag][Name Tag]]
    - [[#net-client-list-stacking][Net Client List Stacking]]
    - [[#no-border][No Border]]
    - [[#no-dmenu][No Dmenu]]
    - [[#no-mod-buttons][No Mod Buttons]]
    - [[#no-transparent-borders][No Transparent Borders]]
    - [[#on-empty-keys][On Empty Keys]]
    - [[#only-one-rule-match][Only One Rule Match]]
    - [[#only-quit-on-empty][Only Quit On Empty]]
    - [[#per-tag][Per Tag]]
    - [[#per-monitor][Per Monitor]]
    - [[#place-direction][Place Direction]]
    - [[#place-mouse][Place Mouse]]
    - [[#push][Push]]
    - [[#renamed-scratchpads][Renamed Scratchpads]]
    - [[#re-organize-tags][Re-Organize Tags]]
    - [[#resize-corners][Resize Corners]]
    - [[#resize-point][Resize Point]]
    - [[#restart-sig][Restart SIG]]
    - [[#rio-draw][Rio Draw]]
    - [[#rotate-stack][Rotate Stack]]
    - [[#rounded-corners][Rounded Corners]]
    - [[#save-floats][Save Floats]]
    - [[#scratch-pads][Scratch Pads]]
    - [[#seamless-restart][Seamless Restart]]
    - [[#selective-fake-fullscreen][Selective Fake Fullscreen]]
    - [[#self-restart][Self Restart]]
    - [[#send-monitor-center][Send Monitor Center]]
    - [[#send-monitor-keep-focus][Send Monitor Keep Focus]]
    - [[#set-border-pixels][Set Border Pixels]]
    - [[#shift-both][Shift Both]]
    - [[#shift-swap-tags][Shift Swap Tags]]
    - [[#shift-tag][Shift Tag]]
    - [[#shift-tag-clients][Shift Tag Clients]]
    - [[#shift-view][Shift View]]
    - [[#size-hints][Size Hints]]
    - [[#sort-screens][Sort Screens]]
    - [[#spawn-cmd][Spawn CMD]]
    - [[#stacker][Stacker]]
    - [[#steam][Steam]]
    - [[#sticky][Sticky]]
    - [[#swallow][Swallow]]
    - [[#swap-focus][Swap Focus]]
    - [[#swap-tags][Swap Tags]]
    - [[#switch-column-focus][Switch Column Focus]]
    -  [[#switch-tag][Switch Tag]]
    - [[#tab][Tab]]
    - [[#tag-all][Tag All]]
    - [[#tag-all-monitor][Tag All Monitor]]
    - [[#tag-into-stack][Tag Into Stack]]
    - [[#tag-monitor-fix-fullscreen][Tag Monitor Fix Fullscreen]]
    - [[#tag-other-monitor][Tag Other Monitor]]
    - [[#tag-swap-monitor][Tag Swap Monitor]]
    - [[#tap-resize][Tap Resize]]
    - [[#toggle-fullscreen][Toggle Fullscreen]]
    - [[#toggle-top-bar][Toggle Top Bar]]
    - [[#toggle-layout][Toggle Layout]]
    - [[#toggle-tag][Toggle Tag]]
    - [[#transfer][Transfer]]
    - [[#unfloat-visible][Unfloat Visible]]
    - [[#unmanaged][Unmanaged]]
    - [[#vanity-gaps][Vanity Gaps]]
    - [[#view-history][View History]]
    - [[#view-on-tag][View On Tag]]
    - [[#warp][Warp]]
    - [[#window-role-rule][Window Role Rule]]
    - [[#window-view][Window View]]
    - [[#x-keyboard][X Keyboard]]
    - [[#xrdb][XRDB]]
    - [[#zoom-floating][Zoom Floating]]
    - [[#zoom-swap][Zoom Swap]]
  - [[#layouts][Layouts]]
    - [[#bottomstack][Bottomstack]]
    - [[#centered-master][Centered Master]]
    - [[#columns][Columns]]
    - [[#deck][Deck]]
    - [[#fibonacci][Fibonacci]]
    - [[#flextile][Flextile]]
    - [[#grid][Grid]]
    - [[#tile][Tile]]
    - [[#monocle][Monocle]]
- [[#build-system-settings][Build System Settings]]
  - [[#make-config][Make Config]]
  - [[#makefile][Makefile]]
- [[#dwm-configuration][DWM Configuration]]
  - [[#appearance][Appearance]]
  - [[#indicators][Indicators]]
  - [[#colors][Colors]]
    - [[#define-colors][Define Colors]]
    - [[#renamed-scratchpads-1][Renamed Scratchpads]]
    - [[#bar-flex-win-title][Bar Flex Win Title]]
    - [[#bar-alpha][Bar Alpha]]
    - [[#vt-colors-1][VT Colors]]
    - [[#set-colors][Set Colors]]
    - [[#powerline-1][Powerline]]
  - [[#layout-menu-1][Layout Menu]]
  - [[#autostart][Autostart]]
  - [[#scratchpads][Scratchpads]]
  - [[#tags-1][Tags]]
  - [[#rules][Rules]]
    - [[#window-rules][Window Rules]]
    - [[#monitor--tag-rules][Monitor & Tag Rules]]
    - [[#bar-rules][Bar Rules]]
  - [[#layouts-1][Layouts]]
  - [[#keybindings][Keybindings]]
- [[#status-bar][Status Bar]]
  - [[#polybar][Polybar]]
    - [[#general][General]]
    - [[#bars][Bars]]
    - [[#modules][Modules]]
    - [[#launch-script][Launch Script]]
- [[#justfile][Justfile]]

* Welcome

My personal configuration of dwm, written as an [[https://orgmode.org][Org Mode]] document.

Run the block below with ~C-c C-c~ to tangle code blocks to config file.

#+BEGIN_SRC emacs-lisp :tangle no
(org-mode-restart)
(org-babel-tangle)
#+END_SRC

After making changes, run the following in a terminal to recompile.

#+BEGIN_SRC bash :tangle no
sudo make clean install
#+END_SRC

* dwm - dynamic window manager

dwm is an extremely fast, small, and dynamic window manager for X.

** Requirements

In order to build dwm you need the Xlib header files.

** Installation

Edit config.mk to match your local setup (dwm is installed into the /usr/local namespace by default).

Afterwards enter the following command to build and install dwm (if necessary as root):

#+BEGIN_SRC bash :tangle no
make clean install
#+END_SRC

** Running dwm

Add the following line to your .xinitrc to start dwm using startx:

#+BEGIN_SRC bash :tangle no
exec dwm
#+END_SRC

In order to connect dwm to a specific display, make sure that the DISPLAY environment variable is set correctly, e.g.:

#+BEGIN_SRC bash :tangle no
DISPLAY=foo.bar:1 exec dwm
#+END_SRC

(This will start dwm on display :1 of the host foo.bar.)

In order to display status info in the bar, you can do something like this in your .xinitrc:

#+BEGIN_SRC bash :tangle no
while xsetroot -name "`date` `uptime | sed 's/.*,//'`"
do
    sleep 1
done &
exec dwm
#+END_SRC

* dwm flexipatch

This dwm 6.5 (061e9fe, 2024-03-19) side project has a different take on dwm patching. It uses preprocessor directives to decide whether or not to include a patch during build time. Essentially this means that this build, for better or worse, contains both the patched _and_ the original code. The aim being that you can select which patches to include and the build will contain that code and nothing more. Due to the complexity of some of the patches dwm-flexipatch has diverged from mainstream dwm by making some core patches non-optional for maintenance reasons. For the classic dwm-flexipatch build refer to branch [[https://github.com/bakkeby/dwm-flexipatch/tree/dwm-flexipatch-1.0][dwm-flexipatch-1.0]].

For example to include the ~alpha~ patch then you would only need to flip this setting from 0 to 1 in [[https://github.com/bakkeby/dwm-flexipatch/blob/master/patches.def.h][patches.h]]:

#+BEGIN_SRC c :tangle no
#define BAR_ALPHA_PATCH 1
#+END_SRC

So if you have ever been curious about trying out dwm, but have been discouraged by manual patching, then this may be a good starting point to see what a "fully fledged" dwm can look like. Want to try out the ~pertag~ patch? Just flip a config and recompile. Once you have found out what works for you and what doesn't then you should be in a better position to choose patches should you want to start patching from scratch.

Alternatively if you have found the patches you want, but don't want the rest of the flexipatch entanglement on your plate then you may want to have a look at [[https://github.com/bakkeby/flexipatch-finalizer][flexipatch-finalizer]]; a custom pre-processor tool that removes all the unused flexipatch code leaving you with a build that contains the patches you selected.

Refer to [[https://dwm.suckless.org/][https://dwm.suckless.org/]] for details on the dwm window manager, how to install it and how it works.

If you are experiencing issues then you may want to check out the [[https://github.com/bakkeby/dwm-flexipatch/discussions/categories/known-issues][Known Issues]] discussion category.

Browsing patches? There is a [[https://coggle.it/diagram/X9IiSSM6PTWOM9Wz][map of patches]] diagram which tries to organize patches into categories.

** Changelog

2024-01-31 - Added the placedir patch

2023-12-22 - Added the do-not-die-on-color-allocation-failure patch

2023-12-01 - Added the sendmoncenter patch

2023-11-12 - Added the focusmaster-return patch variant

2023-06-27 - Added the focusfollowmouse and unmanaged patches

2023-06-25 - Added the toggletopbar patch

2023-01-18 - Added the view history patch

2022-10-08 - Added the alt-tab patch

2022-08-12 - Added the nametag patch

2022-08-02 - Added the bidi patch

2022-07-05 - Added the tagpreview patch

2022-07-04 - Added the shift-tools patch(es) with individual toggles

2022-06-20 - Added the renamed scratchpads patch

2022-06-17 - Ported the seamless restart feature from dusk into dwm-flexipatch

2022-02-11 - Added the isfreesize version of the sizehints patch and the [[https://github.com/bakkeby/dwm-flexipatch/pull/219][tagsync]] patch (contributed by [[https://github.com/Bagellll][Bagelli]])

2021-11-23 - Added the taglabels and underlinetags patches

2021-09-08 - Added the alwayscenter patch

2021-07-27 - Added the winicon patch

2021-05-30 - Added togglelayout and toggletag patches

2021-04-16 - Vanitygaps: replaced smartgaps with smartgaps\_fact, allowing gaps to be disabled or increased when there is only one client.

2021-04-14 - Upgraded the dwmblocks patch for statuscmd which changes the signalling mechanism from SIGUSR1 to SIGRTMIN which is likely to cause issues for those that already have a working setup. A compatibility option has been added which changes this back to SIGUSR1. Note that configuration was also changed.

2021-04-07 - Added xkb patch

2021-04-06 - Added the distributetags patch

2021-04-04 - Added option for having different gaps on a per tag basis

2021-03-31 - Added tapresize patch (contributed by [[https://github.com/verschmelzen][verschmelzen]]

2021-03-29 - Removed alwaysfullscreen patch (merged into dwm 6.2)

2021-03-09 - Added the tab patch and the LG3D patch

2021-02-11 - Added the riodraw and focusdir patches

2021-01-22 - Added the placemouse patch

2021-01-02 - Added the Layoutmenu patch

2020-10-26 - Added the \_NET\_CLIENT\_LIST\_STACKING patch

2020-09-29 - Added the on\_empty\_keys patch (ported from InstantOS)

2020-09-28 - Added the \_IS\_FLOATING patch (embedded in the EWMHTAGS patch)

2020-09-18 - Added the nomodbuttons patch allowing for toggleable mouse button bindings that have no modifiers

2020-09-10 - Added the anybar patch (with experimental support for dwm bar(s) + anybar)

2020-09-09 - Added the bar border patch

2020-09-08 - Added ipc v1.5.5 patch

2020-09-07 - Scratchpads improvement (multi-monitor support)

2020-09-05 - Assortment of fullscreen improvements

2020-08-27 - Added aspectresize patch

2020-08-25 - Unified tag icon handling while adding support for different icons per monitor. Added alttagsdecoration patch.

2020-08-22 - Added logic to auto-hide bars if nothing is drawn on them (e.g. for standalone bars that only show certain clients). Added clientindicators patch and unified indicator code. Simplified Pango integration by settling on common function signatures.

2020-08-21 - Simplification of color configuration; settling on a set of color schemes that is shared between multiple patches (urgentborder, floatborder and titlecolor patches made non-optional)

2020-08-20 - Added experimental flexwintitle patch based on bartabgroups

2020-08-13 - Added bartabgroups patch

2020-08-11 - Added decoration hints and focusmaster patches

2020-08-10 - Added cool autostart, insets and steam patches

2020-08-02 - Added reorganizetags patch

2020-07-19 - Added barmodules patch - making extrabar, leftlayout, staticstatus and statusallmons patches redundant, added powerline patch

2020-07-18 - **Note**: Up until now building dwm-flexipath without any patches selected would have given you something more or less identical with mainstream dwm. In order to reduce complexity when it comes to maintainance future versions of dwm-flexipatch may diverge from this by making some patches non-optional. For the classic dwm-flexipatch and its many patch integration hints refer to branch [[https://github.com/bakkeby/dwm-flexipatch/tree/dwm-flexipatch-1.0][dwm-flexipatch-1.0]] which will be subject to bug fixes and mainstream dwm updates as far as feasible.

2020-07-05 - Extrabar compatibility improvements (staticstatus, status2d, dwmblocks) and fix for systray randomly causing dwm to crash when first systray application starts

2020-06-24 - Added resizepoint, statusbutton and sendmon_keepfocus patches

2020-06-21 - Added floatpos and bar_height patches

2020-06-19 - Added tagothermonitor patch

2020-06-15 - Added sizehints patch

2020-06-14 - Added RULE macro to replace rules setup making the default config less of an abomination and making it simpler to include new rules based patches

2020-06-11 - Added the pango patch

2020-06-10 - Added the staticstatus patch

2020-05-31 - Added the keymodes patch

2020-05-29 - Added the color emoji patch

2020-05-26 - Added the status2d patch (with alpha, systray, statuspadding and dwmblocks compatibility, no statuscolors or extrabar compatibility)

2020-05-21 - Added the moveplace and moveresize patches

2020-05-03 - Added the shiftviewclients patch and the no transparent borders patch which removes opacity from window borders when the alpha patch is not used

2020-05-02 - Added dwmblocks patch

2020-04-27 - Upgraded the tagmonfixfs patch to better support moving fullscreen windows to adjacent monitors

2020-04-26 - Expanded monitor rules patch to include nmaster, showbar and topbar options

2020-04-23 - Improved swallow and switchtag compatibility

2020-04-16 - Upgraded the scratchpad patch to the multiple scratchpads patch \[[[https://lists.suckless.org/hackers/2004/17205.html][ref]]\]. Updated the statuscolors patch with the width computation fix \[[[https://lists.suckless.org/hackers/2004/17207.html][ref]]\].

2020-04-13 - Added statuscmd patch

2020-03-31 - Added the rounded corners patch

2020-03-27 - Revamped the dragmfact patch to support both horizontal and vertical layout splits as well as centered master variants

2020-03-25 - Added dragcfact patch

2020-03-23 - Added stacker patch

2020-03-21 - Reworked a series of layouts to re-allocate remaining pixels following an even (or cfacts) split with the aim of presenting a pixel perfect layout. This affects the following layouts: tile, bstack, bstackhoriz, centered master, centered floating master, columns, deck, and corresponding flextile-deluxe layouts

2020-02-11 - Added swaptags and vtcolor patches

2020-02-09 - Added alternative scratchpad patch

2020-02-02 - Added fsignal and transferall patches

2020-01-29 - Added swapfocus and shiftview patches

2020-01-26 - Added transfer patch

2020-01-24 - Added barpadding patch (incl. statusallmons, statuspadding, statuscolors, systray, alpha, holdbar and extrabar patch compatibility). Moved patches.h to patches.def.h to mimic the config pattern of having default and personal settings.

2020-01-17 - Added inplacerotate patch

2019-12-15 - Updated dragmfact patch to include fix patch to make it work with multiple monitors

2019-11-26 - Added dmenumatchtop patch, added improvements to the switchtag patch based on ideas from the switchtotag patch

2019-11-21 - Added fakefullscreenclient patch

2019-10-24 - Added dragmfact, extrabar, exresize and nodmenu patches

2019-10-22 - Added ispermanent and swallow patches

2019-10-16 - Introduced [[https://github.com/bakkeby/flexipatch-finalizer][flexipatch-finalizer]]

2019-10-11 - Added the patch to ignore Xft errors when drawing text in the status bar

2019-10-10 - Added mpdcontrol, scratchpad and spawn_cwd cpatches

2019-10-08 - Added columns layout and fakefullscreen patch

2019-10-07 - Added sortscreens and dwmc patches, fixed minor cross-compatibility issues for combo, holdbar, leftlayout, hidevacanttags, taggrid and activetagindicatorbar

2019-10-06 - Added statuscolors and statusallmons patches, fixed minor cross-compatibility issues for killunsel, fullscreen, noborder, tagintostack patches

2019-10-05 - Added killunsel, taggrid, hidevacanttags and cmdcustomize patches

2019-10-04 - Added maximize, movestack, monoclesymbol, noborder, tagall and tagintostack  patches

2019-10-03 - Added onlyquitonempty and switchcol patches

2019-10-02 - Added restartsig, emptyview, focusurgent and focusadjacenttag patches

2019-10-01 - Added leftlayout, fullscreen, holdbar and unfloatvisible patches

2019-09-30 - Replaced flextile with flextile-deluxe, refactored monitor rules to support predetermined layouts per tag

2019-09-15 - Added focusonclick, xrdb, viewontag, urgentborder and winview patches

2019-09-14 - Added setborderpx, selfrestart and push (no master variant), sticky and warp patches

2019-09-13 - Added titlecolor and push patches

2019-09-12 - Added activetagindicatorbar, alwaysfullscreen and autoresize patches

2019-09-11 - Added monitor rules, combo and ewmhtags patches

2019-09-10 - Minor tweaks to awesomebar patch (incl. alpha and systray compatibility). Added floatbordercolor patch.

2019-09-09 - Added deck, fibonacci (dwindle and spiral), gridmode, gapplessgrid, horizgrid, nrowgrid, centeredmaster and flextile layouts. Added alternativetags and awesomebar patches.

2019-09-08 - Added cfacts and vanitygaps patches, added bstack and bstackhoriz layouts

2019-09-07 - Added cyclelayouts, resizecorners, rotatestack, savefloats, statuspadding, switchtag, center and windowrolerule patches

2019-09-06 - Added attachabove, attachaside, attachbelow, attachbottom, autostart, fancybar, focusonnetactive and losefullscreen patches

2019-09-05 - Alpha, systray, togglefullscreen, tagallmon, tagmonfixfs, tagswapmon, pertag and zoomswap patches added

** Patches Included

   - [[https://dwm.suckless.org/patches/activetagindicatorbar/][activetagindicatorbar]]
     - this patch changes the rectangle indicating if a tag is used by a client into a bar above the tag name

   - [[https://dwm.suckless.org/patches/alpha/][alpha]]
     - adds transparency for the status bar

   - [[https://dwm.suckless.org/patches/alt-tab/][alt-tab]]
     - adds a window task switcher toggled using alt-tab

   - [[https://dwm.suckless.org/patches/alternativetags/][alternativetags]]
     - adds alternative tags which can be toggled on the fly for the sole purpose of providing visual aid

   - [[https://dwm.suckless.org/patches/alttagsdecoration/][alttagsdecoration]]
     - provides the ability to use alternative text for tags which contain at least one window

   - [[https://dwm.suckless.org/patches/alwayscenter/][alwayscenter]]
     - makes all floating windows centered, like the center patch, but without a rule

   - +[[https://dwm.suckless.org/patches/alwaysfullscreen/][alwaysfullscreen]]+
     - +prevents the focus to drift from the active fullscreen client when using focusstack\(\)+

   - [[https://dwm.suckless.org/patches/anybar/][anybar]]
     - enables dwm to manage external status bars such as lemonbar and polybar
     - dwm treats the external bar as it would its own, so all regular dwm commands such as togglebar affect the external bar in the same way

   - [[https://dwm.suckless.org/patches/aspectresize/][aspectresize]]
     - allows windows to be resized with its aspect ratio remaining constant

   - [[https://dwm.suckless.org/patches/attachabove/][attachabove]]
     - new windows are placed above selected client

   - [[https://dwm.suckless.org/patches/attachaside/][attachaside]]
     - new windows are placed on top of the stack

   - [[https://dwm.suckless.org/patches/attachbelow/][attachbelow]]
     - new windows are placed below selected client

   - [[https://dwm.suckless.org/patches/attachbottom/][attachbottom]]
     - new windows are placed at the bottom of the stack

   - [[https://dwm.suckless.org/patches/autoresize/][autoresize]]
     - by default, windows that are not visible when requesting a resize/move will not get resized/moved, with this patch, however, they will

   - [[https://dwm.suckless.org/patches/autostart/][autostart]]
     - makes dwm run =~/.dwm/autostart_blocking.sh= and =~/.dwm/autostart.sh &= on startup

   - [[https://dwm.suckless.org/patches/awesomebar/][awesomebar]]
     - enhanced taskbar that allows focus / hiding / unhiding of windows by clicking on the status bar

   - [[https://codemadness.org/paste/dwm-border-bar.patch][bar_border]]
     - adds a border around the bar similarly to how client windows have borders

   - [[https://dwm.suckless.org/patches/bar_height/][bar_height]]
     - allows the bar height to be explicitly set rather than being derived from font

   - [[https://github.com/bakkeby/patches/wiki/barmodules/][barmodules]]
     - splits the dwm bar into modules allowing for re-arrangement of the bar and easier integration for new features

   - [[https://dwm.suckless.org/patches/barpadding/][barpadding]]
     - adds vertical and horizontal space between the statusbar and the edge of the screen

   - [[https://dwm.suckless.org/patches/bartabgroups/][bartabgroups]]
     - turns the titlebar area into a mfact-respecting tab-bar showing each client's title

   - [[https://dwm.suckless.org/patches/bidi/][bidi]]
     - adds proper support for Right-To-Left (RTL) languages (such as Farsi, Arabic or Hebrew)

   - [[https://dwm.suckless.org/patches/center/][center]]
     - adds an iscentered rule to automatically center clients on the current monitor

   - [[https://dwm.suckless.org/patches/cfacts/][cfacts]]
     - the cfacts patch provides the ability to assign different weights to clients in their respective stack in tiled layout

   - [[https://dwm.suckless.org/patches/clientindicators/][clientindicators]]
     - draws a dot indicator overlayed on each tag icon for each client
     - the selected client is drawn as a larger horizontal line

   - [[https://dwm.suckless.org/patches/cmdcustomize/][cmdcustomize]]
     - allows color attributes to be set through the command line

   - [[https://dwm.suckless.org/patches/colorbar/][colorbar]]
     - lets you change the foreground and background color of every statusbar element

   - +color_emoji+
     - +enables color emoji in dmenu by removing a workaround for a BadLength error in the Xft library when color glyphs are used+
     - +enabling this will crash dwm on encountering such glyphs unless you also have an updated Xft library that can handle them+

   - [[https://dwm.suckless.org/patches/combo/][combo]]
     - allows you to select multiple tags by pressing all the right keys as a combo, e.g. hold MOD and press and hold 1 and 3 together to view those two tags

   - [[https://dwm.suckless.org/patches/cool_autostart/][cool_autostart]]
     - allows dwm to execute commands from an array in the config.h file
     - when dwm exits all processes from the autostart array will be killed automatically

   - [[https://dwm.suckless.org/patches/cyclelayouts/][cyclelayouts]]
     - lets you cycle through all your layouts

   - [[https://dwm.suckless.org/patches/decoration_hints/][decoration_hints]]
     - make dwm respect =_MOTIF_WM_HINTS= property, and not draw borders around windows requesting for it
     - some applications use this property to notify window managers to not draw window decorations
     - not respecting this property leads to issues with applications that draw their own borders, like chromium (with "Use system title bar and borders" turned off) or vlc in fullscreen mode

   - [[https://dwm.suckless.org/patches/reorganizetags/][distributetags]]
     - this reorganisetags variant re-distributes all clients on the current monitor evenly across all tags

   - [[https://dwm.suckless.org/patches/dmenumatchtop][dmenumatchtop]]
     - updates the position of dmenu to match that of the bar
     - i.e. if topbar is 0 then dmenu will appear at the bottom and if 1 then dmenu will appear at the top

   - do-not-die-on-color-allocation-failure
     - avoids dwm terminating (dying) on color allocation failures
     - useful for the xrdb (xresources) and status2d patches

   - [[https://github.com/bakkeby/patches/wiki/dragcfact/][dragcfact]]
     - lets you resize clients' size (i.e. modify cfact) by holding modkey + shift + right-click and dragging the mouse

   - [[https://github.com/bakkeby/patches/wiki/dragmfact/][dragmfact]]
     - lets you resize the split in layouts (i.e. modify mfact) by holding the modkey + shift
       + left-click and dragging the mouse
     - this is a bespoke patch that supports vertical and horizontal layout splits as well as centered master variants

   - [[https://gist.github.com/danbyl/54f7c1d57fc6507242a95b71c3d8fdea][dwmblocks]]
     - signal integration to use dwm with a patched [[https://github.com/torrinfail/dwmblocks][dwmblocks]]
     - combined with the statuscmd patch this gives a clickable statusbar

   - [[http://dwm.suckless.org/patches/dwmc/][dwmc]]
     - a simple dwmc client using a fork of fsignal to communicate with dwm

   - [[https://dwm.suckless.org/patches/emptyview/][emptyview]]
     - allows no tag at all to be selected
     - dwm will start with no tag selected and when a client with no tag rule is started and no tag is selected then it will be opened on the first tag

   - [[https://dwm.suckless.org/patches/ewmhtags/][ewmhtags]]
     - adds EWMH support for =_NET_NUMBER_OF_DESKTOPS=, =_NET_CURRENT_DESKTOP=, =_NET_DESKTOP_NAMES= and =_NET_DESKTOP_VIEWPORT=, which allows for compatibility with other bars and programs that request workspace information, e.g. polybar's xworkspaces module

   - [[https://dwm.suckless.org/patches/exresize/][exresize]]
     - this patch allows the user to change size and placement of floating windows using only the keyboard
     - it also allows for temporary vertical and horizontal extension of windows similar to other WMs fill command

   - +[[https://dwm.suckless.org/patches/extrabar/][extrabar]]+
     - +enables an extra status bar in dwm in a similar manner to the dualstatus patch+
     - +if the primary status is at the top via topbar then the extra status bar will be placed at the bottom and vice versa+

   - extrastatus
     - formerly extrabar - now only splits the status into to statuses by using a status separator

   - [[https://dwm.suckless.org/patches/fakefullscreen/][fakefullscreen]]
     - only allow clients to "fullscreen" into the space currently given to them
     - as an example, this will allow you to view a fullscreen video in your browser on one half of the screen, while having the other half available for other tasks

   - [[https://github.com/bakkeby/patches/wiki/fakefullscreenclient/][fakefullscreenclient]]
     - similarly to the fakefullscreen patch this patch only allows clients to "fullscreen" into the space currently given to them
     - as an example, this will allow you to view a fullscreen video in your browser on one half of the screen, while having the other half available for other tasks
     - the "twist" with this patch is that fake fullscreen can be toggled on a per client basis rather than applying to all clients globally

   - [[https://dwm.suckless.org/patches/fancybar/][fancybar]]
     - shows the titles of all visible windows in the status bar

   - flexwintitle
     - based on the bartabgroups patch, this is a layout aware barmodules module for handling window titles intended to be used with flextile-deluxe

   - +[[https://dwm.suckless.org/patches/float_border_color/][floatbordercolor]]+
     - +this patch allows a different border color to be chosen for floating windows+

   - [[https://github.com/bakkeby/patches/wiki/floatpos/][floatpos]]
     - adds a float rule allowing the size and position of floating windows to be specified
     - control the size and position of floating windows similar to exresize, moveresize, moveplace patches
     - specify size and position using absolute, relative or fixed co-ordinates or
     - position floating windows in a grid-like manner

   - [[https://dwm.suckless.org/patches/focusadjacenttag/][focusadjacenttag]]
     - provides the ability to focus the tag on the immediate left or right of the currently focused tag
     - it also allows to send the focused window either on the left or the right tag

   - [[https://github.com/bakkeby/patches/wiki/focusdir][focusdir]]
     - allows focusing on clients based on direction (up, down, left, right) instead of client order

   - [[https://github.com/bakkeby/patches/wiki/focusfollowmouse][focusfollowmouse]]
     - the window under the mouse cursor will receive focus when changing tags, closing windows or
       moving client out of view (as opposed to the most recently focused client)

   - [[https://dwm.suckless.org/patches/focusmaster/][focusmaster]]
     - a simple patch that just puts focus back to the master client

   - [[https://dwm.suckless.org/patches/focusmaster/][focusmaster-return]]
     - a simple patch that just puts focus back to the master client
     - additionally allows focus to be switched back to the previous client

   - [[https://dwm.suckless.org/patches/focusonclick/][focusonclick]]
     - this patch makes you switch focus only by mouse click and not sloppy (focus follows mouse pointer)

   - [[https://dwm.suckless.org/patches/focusonnetactive/][focusonnetactive]]
     - by default, dwm responds to =_NET_ACTIVE_WINDOW= client messages by setting the urgency bit on the named window
     - this patch activates the window instead

   - [[https://dwm.suckless.org/patches/focusurgent/][focusurgent]]
     - adds a keyboard shortcut to select the next window having the urgent flag regardless of the tag it is on

   - [[https://dwm.suckless.org/patches/fsignal/][fsignal]]
     - send "fake signals" to dwm for handling, using xsetroot
     - this will not conflict with the status bar, which also is managed using xsetroot

   - [[https://dwm.suckless.org/patches/fullscreen/][fullscreen]]
     - applies the monocle layout with the focused client on top and hides the bar
     - when pressed again it shows the bar and restores the layout that was active before going fullscreen

   - [[https://dwm.suckless.org/patches/hide_vacant_tags/][hidevacanttags]]
     - prevents dwm from drawing tags with no clients (i.e. vacant) on the bar

   - [[http://dwm.suckless.org/patches/holdbar/][holdbar]]
     - with this patch dwm's built-in status bar is only shown when HOLDKEY is pressed
     - additionally the bar will now overlay the display

   - [[https://groups.google.com/forum/m/#!topic/wmii/7bncCahYIww][ignore-xft-errors-when-drawing-text]]
     - sometimes dwm crashes when it cannot render some glyphs in window titles (usually emoji)
     - this patch is essentially a hack to ignore any errors when drawing text on the status bar and may be removed if a more appropriate solution comes up

   - [[https://dwm.suckless.org/patches/inplacerotate/][inplacerotate]]
     - allows rotation of all clients in the master or stack area without affecting the other area

   - [[https://dwm.suckless.org/patches/insets/][insets]]
     - lets custom insets from each edge of the screen to be defined
     - an example use case would be to make space for an external bar

   - [[https://github.com/mihirlad55/dwm-ipc][ipc]]
     - implements inter-process communication through a UNIX socket for dwm
     - allows for the window manager to be queried for information, e.g. listen for events such as tag or layout changes, as well as send commands to control the window manager via other programs

   - [[https://github.com/bakkeby/dwm-flexipatch/issues/50][_IS_FLOATING]]
     - adds the =_IS_FLOATING= xproperty for floating windows
     - this can allow for a compositor to handle floating windows differently to tiled windows, e.g. only show shadows on floating windows
     - this patch is enabled via the ewmhtags patch

   - [[https://dwm.suckless.org/patches/ispermanent/][ispermanent]]
     - adds rule option for clients to avoid accidental termination by killclient for sticky windows

   - [[https://dwm.suckless.org/patches/keymodes/][keymodes]]
     - this patch adds key modes (like in vim or emacs) where chains of keyboard shortcuts can be performed

   - [[https://dwm.suckless.org/patches/killunsel/][killunsel]]
     - kills all visible clients that are not selected (only the selected client will remain)

   - +[[http://dwm.suckless.org/patches/leftlayout/][leftlayout]]+
     - +moves the layout symbol in the status bar to the left hand side+

   - LG3D
     - changes the window manager name to "LG3d" instead of "dwm" as a workaround for Java applications that assume that the window manager is using window reparenting
     - refer to the ISSUES secton of the dwm man page for more details

   - [[https://github.com/bakkeby/patches/wiki/losefullscreen/][losefullscreen]]
     - by default in dwm it is possible to make an application fullscreen, then use the focusstack keybindings to focus on other windows beneath the current window
     - it is also possible to spawn new windows (e.g. a terminal) that end up getting focus while the previous window remains in fullscreen
     - this patch ensures that in such scenarios the previous window loses fullscreen

   - [[https://dwm.suckless.org/patches/maximize/][maximize]]
     - adds helper functions for maximizing, horizontally and vertically, floating windows using keybindings

   - [[https://dwm.suckless.org/patches/mpdcontrol/][mpdcontrol]]
     - adds keyboard bindings to control MDP (Music Player Daemon)

   - [[https://github.com/bakkeby/patches/wiki/monitorrules/][monitorrules]]
     - adds rules per monitor, e.g. have default layouts per monitor
     - the use case for this is if the second monitor is vertical (i.e. rotated) then you may want to use a different default layout for this monitor than what is used for the main monitor (for example normal vertical split for main monitor and horizontal split for the second)

   - [[https://dwm.suckless.org/patches/monoclesymbol/][monoclesymbol]]
     - always display the monocle-symbol as defined in config.h if the monocle-layout is activated
     - do not display the number of open clients in the current tag

   - [[https://dwm.suckless.org/patches/moveresize/][moveresize]]
     - allows you to move and resize dwm's clients using keyboard bindings

   - [[https://dwm.suckless.org/patches/movestack/][movestack]]
     - allows you to move clients around in the stack and swap them with the master

   - [[https://dwm.suckless.org/patches/nametag/][nametag]]
     - allows the names of tags to be changed during runtime

   - [[https://github.com/bakkeby/patches/wiki/netclientliststacking][netclientliststacking]]
     - adds support for the =_NET_CLIENT_LIST_STACKING= atom, needed by certain applications like the Zoom video conferencing application

   - [[https://dwm.suckless.org/patches/noborder/][noborder]]
     - removes the border when there is only one window visible

   - [[https://git.suckless.org/sites/commit/ed68e3629de4ef2ca2d3f8893a79fb570b4c0cbc.html][nodmenu]]
     - enable modifying dmenu in config.def.h which resulted previously in a compilation error
       because two lines of code hardcode dmenu into dwm
     - allows complete removal of dmenu, should you want to do that
     - NB: this patch was removed from the patches listing on the suckless page due to it's simplicity

   - nomodbuttons
     - allows for toggleable client button bindings that have no modifiers
     - this can, for example, allow you to move or resize using the mouse alone without holding down a modifier key, which can be practical if you have extra buttons on your mouse

   - [[https://github.com/szatanjl/dwm/commit/1529909466206016f2101457bbf37c67195714c8][no_transparent_borders]]
     - when terminals have transparency then their borders also become transparent
     - this patch ensures that borders have no transparency
     - note that this patch is only relevant if you are not using the alpha patch

   - [[https://github.com/bakkeby/dwm-flexipatch/issues/51][on_empty_keys]]
     - port of InstantWM's on_empty_keys functionality allowing keybindings that apply only when a tag/view is empty
     - an example use case is being able to launch applications with first hand keys like "f" to launch firefox

   - [[https://dwm.suckless.org/patches/onlyquitonempty/][onlyquitonempty]]
     - makes it so dwm will only exit via quit() if no windows are open (in order to prevent accidental loss of work)

   - [[https://dwm.suckless.org/patches/pango/][pango]]
     - adds simple markup for status messages using pango markup

   - [[https://dwm.suckless.org/patches/pertag/][pertag]]
     - adds nmaster, mfact, layouts and more per tag rather than per monitor

   - [[https://github.com/bakkeby/patches/wiki/placedir][placedir]]
     - allows tiled windows to be moved in any direction (up, down, left, right)

   - [[https://github.com/bakkeby/patches/wiki/placemouse][placemouse]]
     - lets the user change the position of a client in the stack using the mouse.

   - [[https://gitlab.com/udiboy1209-suckless/dwm/-/commit/071f5063e8ac4280666828179f92788d893eea40#4b1a539194be7467cefbda22f675a3b7c19ceca7][powerline]]
     - adds drawing of powerline arrows (and diagonal lines) for both the status bar and the tags

   - [[https://dwm.suckless.org/patches/push/][push]]
     - this patch provides a way to move clients up and down inside the client list

   - [[https://github.com/bakkeby/patches/wiki/renamedscratchpads][renamed_scratchpads]]
     - variant of the [[https://dwm.suckless.org/patches/namedscratchpads/][named scratchpads]] patch

   - [[https://dwm.suckless.org/patches/reorganizetags/][reorganizetags]]
     - shifts all clients per tag to leftmost unoccupied tags
     - e.g. if clients A, B, C are tagged on tags 1, 5, 9 respectively, when reorganized they will now be on tag 1, 2, and 3

   - [[https://dwm.suckless.org/patches/resizecorners/][resizecorners]]
     - by default, windows only resize from the bottom right corner
     - with this patch the mouse is warped to the nearest corner and you resize from there

   - [[https://github.com/bakkeby/patches/wiki/resizepoint/][resizepoint]]
     - practically the same as resizecorners, but the cursor does not warp to any of the window corners

   - [[https://dwm.suckless.org/patches/restartsig/][restartsig]]
     - adds a keyboard shortcut to restart dwm or alternatively by using kill -HUP dwmpid
     - additionally dwm can quit cleanly by using kill -TERM dwmpid

   - [[https://github.com/bakkeby/patches/wiki/riodraw/][riodraw]]
     - adds rio-like drawing to spawn new windows or to resize the selected client (ported from instantWM)
     - depends on an external tool slop being installed

   - [[https://dwm.suckless.org/patches/rotatestack/][rotatestack]]
     - let's you rotate through the stack using keyboard shortcuts

   - [[https://github.com/mitchweaver/suckless/blob/master/dwm/inactive/mitch-06-rounded_corners-f04cac6d6e39cd9e3fc4fae526e3d1e8df5e34b2.patch][roundedcorners]]
     - adds rounded corners to client windows

   - [[https://dwm.suckless.org/patches/save_floats/][savefloats]]
     - saves size and position of every floating window before it is forced into tiled mode
     - if the window is made floating again then the old dimensions will be restored

   - [[https://dwm.suckless.org/patches/scratchpad/][scratchpad]]
     - the scratchpad patch allows you to spawn or restore a floating terminal window

   - [[https://github.com/GasparVardanyan/dwm-scratchpad][scratchpad_alt_1]]
     - this alternative patch enables a scratchpad feature in dwm similar to the scratchpad feature in i3wm

   - seamless_restart
     - allows for selected layout, assigned tags, etc. to be persisted across restarts

   - [[https://dwm.suckless.org/patches/selfrestart/][selfrestart]]
     - restart dwm without the unnecessary dependency of an external script

   - [[https://dwm.suckless.org/patches/sendmoncenter/][sendmoncenter]]
     - floating windows being sent to another monitor will be centered

   - [[https://github.com/bakkeby/patches/wiki/sendmon_keepfocus/][sendmon_keepfocus]]
     - minor patch that allow clients to keep focus when being sent to another monitor

   - [[https://dwm.suckless.org/patches/setborderpx/][setborderpx]]
     - this patch allows border pixels to be changed during runtime

   - [[https://dwm.suckless.org/patches/shift-tools/][shift-tools]]
     - a group of functions that shift clients or views left or right

   - [[https://github.com/chau-bao-long/dotfiles/blob/master/suckless/dwm/shiftview.diff][shiftview]]
     - adds keybindings for left and right circular shift through tags
     - also see focusadjacenttag

   - [[https://github.com/bakkeby/patches/wiki/shiftviewclients/][shiftviewclients]]
     - variant of the shiftview patch which skips tags that have no clients

   - [[https://dwm.suckless.org/patches/sizehints/][sizehints]]
     - makes dwm obey even "soft" sizehints for new clients

   - [[https://www.mail-archive.com/hackers@suckless.org/msg09400.html][sortscreens]]
     - this patch aims to address some inconsistencies when it comes to focusmon, tagmon and similar functionality by explicitly sorting screens left to right (or top to bottom in a vertical layout)

   - [[https://dwm.suckless.org/patches/spawn_cwd/][spawn_cwd]]
     - spawns programs from currently focused client's working directory

   - [[https://dwm.suckless.org/patches/stacker/][stacker]]
     - provides comprehensive utilities for managing the client stack

   - [[https://dwm.suckless.org/patches/staticstatus/][staticstatus]]
     - allows the status text to be fixed to the bar on a specific monitor rather than being drawn on the focused monitor

   - [[https://dwm.suckless.org/patches/status2d/][status2d]]
     - allows colors and rectangle drawing in the dwm status bar

   - [[https://dwm.suckless.org/patches/statuspadding/][statusallmons]]
     - this patch draws and updates the statusbar on all monitors

   - [[https://dwm.suckless.org/patches/statusbutton/][statusbutton]]
     - adds a clickable button to the left hand side of the statusbar

   - [[https://dwm.suckless.org/patches/statuscmd/][statuscmd]]
     - adds the ability to execute shell commands based on the mouse button and position when clicking the status bar

   - [[https://dwm.suckless.org/patches/statuscolors/][statuscolors]]
     - enables colored text in the status bar allowing multiple color combinations for use in the status script

   - [[https://dwm.suckless.org/patches/statuspadding/][statuspadding]]
     - adds configuration options for horizontal and vertical padding in the status bar

   - [[https://github.com/bakkeby/patches/wiki/steam][steam]]
     - a minor patch that works around the issue of floating Steam windows jumping around the screen when they receive focus

   - [[https://dwm.suckless.org/patches/sticky/][sticky]]
     - adds toggleable keyboard shortcut to make a client 'sticky', i.e. visible on all tags

   - [[https://dwm.suckless.org/patches/swallow/][swallow]]
     - this patch adds "window swallowing" to dwm as known from Plan 9's windowing system rio
     - clients marked with isterminal in config.h swallow a window opened by any child process, e.g. running xclock in a terminal
     - closing the xclock window restores the terminal window in the current position

   - [[https://dwm.suckless.org/patches/swapfocus/][swapfocus]]
     - this patch depends on the pertag patch and makes it possible to switch focus with a single shortcut (mod-s) instead of having to think if you should use mod-j or mod-k for reaching the previously used window

   - [[https://dwm.suckless.org/patches/swaptags/][swaptags]]
     - allows swapping the contents of the currently selected tag with another tag by using keyboard shortcuts

   - [[https://dwm.suckless.org/patches/switchcol/][switchcol]]
     - allows you to switch focus between the master and stack columns using a single keybinding

   - [[https://github.com/bakkeby/patches/wiki/switchtag/][switchtag]]
     - when an application opens on a specific tab this patch adds the option to also switch to that tag when the application starts
     - optionally, the previous view can also be restored when the client is closed

   - [[https://dwm.suckless.org/patches/systray/][systray]]
     - adds system tray in the status bar

   - [[https://dwm.suckless.org/patches/tab/][tab]]
     - transforms the monocle layout into a "tabbed" layout if more than one window is present on the monocle view
     - this is essentially just a specific bar
     - the patch has been added for demonstration purposes only and has limited compatibility with other patches
     - it will conflict space-wise with a second bar
     - note that fancybar, awesomebar, bartabgroups and similar patches make the tab patch redundant

   - [[https://dwm.suckless.org/patches/tagall/][tagall]]
     - adds keyboard shortcuts to move all (or only floating) windows from one tag to another

   - [[https://github.com/bakkeby/patches/wiki/tagallmon/][tagallmon]]
     - move all visible windows to an adjacent monitor

   - [[https://dwm.suckless.org/patches/tagintostack/][tagintostack]]
     - makes new clients attach into the stack area when you toggle a new tag into view
     - this means your master area will remain unchanged when toggling views

   - [[https://dwm.suckless.org/patches/taggrid/][taggrid]]
     - adds an option to place tags in rows like in many other window managers

   - [[https://dwm.suckless.org/patches/taglabels/][taglabels]]
     - shows tag + class of master client in the tags section of the bar

   - [[https://github.com/bakkeby/patches/wiki/tagmonfixfs/][tagmonfixfs]]
     - allows moving a fullscreen window to another monitor while remaining in fullscreen

   - [[https://dwm.suckless.org/patches/tagothermonitor/][tagothermonitor]]
     - adds functions and keybindings to tag a window to a desired tag on an adjacent monitor

   - [[https://dwm.suckless.org/patches/tag-previews/][tagpreview]]
     - shows a preview of a tag when hovering the tag icon using the mouse

   - [[https://github.com/bakkeby/patches/wiki/tagswapmon/][tagswapmon]]
     - swap all visible windows on one monitor with those of an adjacent monitor

   - [[https://dwm.suckless.org/patches/tapresize/][tapresize]]
     - allows resizing of windows using a touchpad
     - uses vertical and horizontal scroll events allowing you to use one-finger tap for moving windows and two-finger tap for resizing

   - +[[https://dwm.suckless.org/patches/titlecolor/][titlecolor]]+
     - +adds a new color scheme used by the (selected) window title in the bar+

   - [[https://github.com/bakkeby/patches/wiki/togglefullscreen/][togglefullscreen]]
     - allows you to toggle fullscreen on and off using a single shortcut key

   - [[https://github.com/bakkeby/patches/wiki/togglelayout][togglelayout]]
     - toggle layout using the same keyboard shortcuts to set the layout
     - e.g. hitting ~MOD+m~ switches to monocle layout, hitting the same keybinding again brings you back to the previous layout

   - [[https://github.com/bakkeby/patches/wiki/toggletag][toggletag]]
     - toggle tags using the same keyboard shortcuts to view tags
     - e.g. hitting ~MOD+4~ lets you view tag 4 and hitting the keybinding a second time brings you back to where you were before

   - [[https://dwm.suckless.org/patches/toggletopbar/][toggletopbar]]
     - allows for the bar position (top or bottom) to be toggled during runtime

   - [[https://dwm.suckless.org/patches/transfer/][transfer]]
     - lets you transfer the currently focused client between the master and stack area while increasing or decreasing the master area (nmaster) accordingly

   - [[https://dwm.suckless.org/patches/transfer/][transferall]]
     - lets you transfer all clients between the master and stack area while increasing or decreasing the master area (nmaster) accordingly

   - [[https://dwm.suckless.org/patches/underlinetags/][underlinetags]]
     - underlines the selected tag, or optionally all tags

   - [[https://dwm.suckless.org/patches/unfloatvisible/][unfloatvisible]]
     - resets isfloating on any visible windows that have it set and optionally also applies a layout

   - [[https://github.com/bakkeby/patches/wiki/unmanaged][unmanaged]]
     - adds a client rule that allows for windows to not be managed by the window manager
     - this can be useful for external bars, widgets, launchers, docks, desktop icons and more

   - +[[https://dwm.suckless.org/patches/urgentborder/][urgentborder]]+
     - +this patch makes "urgent" windows have different colors+

   - [[https://github.com/bakkeby/patches/blob/master/dwm/dwm-vanitygaps-6.2.diff][vanitygaps]]
     - adds configurable gaps between windows differentiating between outer, inner, horizontal and vertical gaps

   - viewhistory
     - adds a tag change history that is longer than the default current and previous tag
     - `MOD`+Tab (`view(0)`) can be pressed multiple times to go further back to earlier tag
       selections

   - [[https://dwm.suckless.org/patches/viewontag/][viewontag]]
     - follow a window to the tag it is being moved to

   - [[https://dwm.suckless.org/patches/vtcolors/][vtcolor]]
     - this patch adds the ability for dwm to read colors from the linux virtual console essentially allowing you to use the same color scheme as your regular tty

   - [[https://dwm.suckless.org/patches/warp/][warp]]
     - warps the mouse cursor to the center of the currently focused window or screen when the mouse cursor is (a) on a different screen or (b) on top of a different window

   - [[https://dwm.suckless.org/patches/winicon/][winicon]]
     - adds the window icon next to the window title in the bar

   - [[https://github.com/bakkeby/patches/wiki/windowrolerule/][windowrolerule]]
     - sometimes a single application opens different windows depending on the task at hand and this is often reflected in the =WM_WINDOW_ROLE(STRING)= x property
     - this patch adds the role field to the rule configuration so that one can differentiate between, say, Firefox "browser" vs "Preferences" vs "Manager" or Google-chrome "browser" vs "pop-up".

   - [[http://dwm.suckless.org/patches/winview/][winview]]
     - allows switching the view to that of a given client from the all-window view (Mod-0) using a keyboard shortcut

   - [[https://dwm.suckless.org/patches/xkb/][xkb]]
     - remembers keyboard layout per client

   - [[http://dwm.suckless.org/patches/xrdb/][xrdb]]
     - allows dwm to read colors from xrdb (.Xresources) during runtime

   - [[https://www.reddit.com/r/suckless/comments/ie5fe3/zoomfloating_my_own_simple_original_patch/][zoomfloating]]
     - a simple patch that allows floating windows to be zoomed into the master stack position

   - [[https://dwm.suckless.org/patches/zoomswap/][zoomswap]]
     - allows a master and a stack window to swap places rather than every window on the screen changing position

** Layouts Included

   - [[https://dwm.suckless.org/patches/bottomstack/][bstack]]
     - bottomstack layout

   - [[https://dwm.suckless.org/patches/bottomstack/][bstackhoriz]]
     - bottomstack horizontal layout

   - [[https://dwm.suckless.org/patches/centeredmaster/][centeredmaster]]
     - centeredmaster layout

   - [[https://dwm.suckless.org/patches/centeredmaster/][centeredfloatingmaster]]
     - centeredfloatingmaster layout

   - [[https://dwm.suckless.org/patches/columns/][columns]]
     - same as the default tile layout except clients in the master area are arranged in columns (i.e. left to right)

   - [[https://dwm.suckless.org/patches/deck/][deck]]
     - deck layout - clients in the stack area are arranged on top of each other (like monocle)

   - [[https://dwm.suckless.org/patches/fibonacci/][fibonacci]]
     - fibonacci (dwindle and spiral) layouts

   - [[https://github.com/bakkeby/patches/wiki/flextile-deluxe/][flextile-deluxe]]
     - a re-envisioned, flexible and over-the-top version of the original [[https://dwm.suckless.org/patches/flextile/][flextile]] patch supporting
       - multiple split layouts (horizontal, vertical, centered, floating, fixed)
       - tile arrangement on a per split basis (stack horizontally, stack vertically, grids, fibonacci)
       - pertag, cfacts, rmaster, vanitygaps compatibility
       - tile, deck, monocle, centeredmaster, bstack, bstackhoriz, gapplessgrid and more
     - this gives you a lot of versatility in terms of layout

   - [[https://dwm.suckless.org/patches/gaplessgrid/][gapplessgrid]]
     - gappless grid layout

   - [[https://dwm.suckless.org/patches/gridmode/][gridmode]]
     - gridmode (grid) layout

   - [[https://dwm.suckless.org/patches/horizgrid/][horizgrid]]
     - horizontal grid layout

   - [[https://dwm.suckless.org/patches/nrowgrid/][nrowgrid]]
     - nrowgrid layout, number of rows in grid controlled by nmaster

* Patches

This file contains patch control flags.

In principle you should be able to mix and match any patches you may want. In cases where patches are logically incompatible one patch may take precedence over the other as noted in the relevant descriptions.

Although layouts typically come as patches they are differentiated here for grouping purposes.

** Bar Modules

*** Awesome Bar

Enhanced taskbar that shows the titles of all visible windows in the status bar and allows focus / hiding / unhiding of windows by clicking on the status bar.

Awesomebar takes precedence over fancybar.

https://dwm.suckless.org/patches/awesomebar/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_AWESOMEBAR_PATCH 0
#+END_SRC

*** DWM Blocks

**** Main

This patch depends on statuscmd patch and adds integration with a (patched) dwmblocks instance to give a clickable status bar. One must not necessarily have to use dwmblocks for this feature, any status updater that has support for real-time signals (SIGRTMIN) can be used.

dwmblocks: https://github.com/torrinfail/dwmblocks

https://dwm.suckless.org/patches/statuscmd/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_DWMBLOCKS_PATCH 0
#+END_SRC

**** SIGUSR1

Originally the dwmblocks + statuscmd patch used a user defined signal (SIGUSR1) for communicating with dwmblocks to indicate update signal and what button was pressed. The signalling was later changed to SIGRTMIN instead.

Ultimately this makes dwmblocks instances that were patched with the old patch are incompatible with the new dwm patch and vice versa.

This is a compatibility patch that makes dwm use SIGUSR1 instead of SIGRTMIN so if button clicks are not working then you may want to try enabling this.

If dwmblocks happen to die like this when clicking on a status

   [1]    54355 user-defined signal 1  dwmblocks

then it suggests that dwmblocks does not support user defined signals and this patch should be left disabled.

Patch: https://gist.github.com/danbyl/54f7c1d57fc6507242a95b71c3d8fdea

https://dwm.suckless.org/patches/statuscmd/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_DWMBLOCKS_SIGUSR1_PATCH 0
#+END_SRC

*** Fancy Bar

This patch shows the titles of all visible windows in the status bar (as opposed to showing only the selected one).

Awesomebar takes precedence over fancybar. Fancybar takes precedence over the centeredwindowname patch.

https://dwm.suckless.org/patches/fancybar/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_FANCYBAR_PATCH 0
#+END_SRC

*** Flex Win Title

Being an evolution of the bartabgroups patch the flexwintitle patch specifically taps into the many layout options that flextile-deluxe offers to produce a window title section in the bar that is representative of what is shown on screen.

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_FLEXWINTITLE_PATCH 0
#+END_SRC

*** Layout Menu

This patch adds a context menu for layout switching.

  - xmenu needs to be installed.
  - Edit layoutmenu.sh with the installed layouts and with correct indexes.
  - Place layoutmenu.sh in PATH.
  - The text of the menu items is for display only. Name them however you want.

https://dwm.suckless.org/patches/layoutmenu/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_LAYOUTMENU_PATCH 0
#+END_SRC

*** Layout Symbol

Show layout symbol in bar

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_LTSYMBOL_PATCH 0
#+END_SRC

*** Powerline

**** Powerline Status

Adds powerline arrows for the status. This uses statuscolors logic for choosing colors for the powerline. As these markers are also control characters there is no explicit statuscmd support for this patch.

Powerline separators are defined as:
#+BEGIN_EXAMPLE
|\xXX  (creates a hard edge)
<\xXX  (creates a less than arrow)
/\xXX  (creates a diagonal line)
#+END_EXAMPLE

Examples:
#+BEGIN_EXAMPLE
xsetroot -name "$(echo -e '<\x01a<\x02b<\x03c')"
xsetroot -name "$(echo -e '/\x01d/\x02e/\x03f')"
#+END_EXAMPLE

https://gitlab.com/udiboy1209-suckless/dwm/-/commit/071f5063e8ac4280666828179f92788d893eea40#4b1a539194be7467cefbda22f675a3b7c19ceca7

https://dwm.suckless.org/patches/statuscolors/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_POWERLINE_STATUS_PATCH 0
#+END_SRC

**** Powerline Tags

Adds powerline arrows for the tags.

https://gitlab.com/udiboy1209-suckless/dwm/-/commit/071f5063e8ac4280666828179f92788d893eea40#4b1a539194be7467cefbda22f675a3b7c19ceca7

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_POWERLINE_TAGS_PATCH 0
#+END_SRC

**** Powerline Tags Slash

Alters the tags powerline to use forward slash instead of arrows.

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_POWERLINE_TAGS_SLASH_PATCH 0
#+END_SRC

*** Tab Groups

This patch turns the titlebar area into a mfact-respecting tabbar showing each client's title.

https://dwm.suckless.org/patches/bartabgroups/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_TABGROUPS_PATCH 0
#+END_SRC

*** Tag Grid

This patch adds an option to place tags in rows like in many other window managers.

https://dwm.suckless.org/patches/taggrid/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_TAGGRID_PATCH 0
#+END_SRC

*** Tag Preview

Hover tag icons to see a preview of the windows on that tag.

The patch depends on Imlib2 for icon scaling. You need to uncomment the corresponding line in config.mk to use the -lImlib2 library.

Arch Linux:
    ~sudo pacman -S imlib2~
Debian:
    ~sudo apt install libimlib2-dev~

As with the winicon patch you may want to consider adding the compiler flags of ~-O3~ and ~-march=native~ to enable auto loop vectorize for better performance.

https://dwm.suckless.org/patches/tag-previews/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_TAGPREVIEW_PATCH 0
#+END_SRC

*** Status

Show status in bar

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_STATUS_PATCH 0
#+END_SRC

*** Status Button

This patch adds a clickable button to the left hand side of the statusbar.

https://dwm.suckless.org/patches/statusbutton/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_STATUSBUTTON_PATCH 0
#+END_SRC

*** Status CMD

This patch adds the ability to execute shell commands based on the mouse button and position when clicking the status bar. Refer to the website for usage.

https://dwm.suckless.org/patches/statuscmd/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_STATUSCMD_PATCH 0
#+END_SRC

*** Status 2D

**** Main

Status2d allows colors and rectangle drawing in your dwm status bar.

This patch is incompatible with the statuscolors patch which takes precedence.
This patch is incompatible with the extrabar patch.

https://dwm.suckless.org/patches/status2d/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_STATUS2D_PATCH 0
#+END_SRC

**** No Alpha

Supplementary patch should you want to disable alpha for the status2d section

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_STATUS2D_NO_ALPHA_PATCH 0
#+END_SRC

**** XRDB Term Colors

Addition to the status2d patch that allows the use of terminal colors (color0 through color15) from xrdb in the status, allowing programs like pywal to change statusbar colors.

This adds the C and B codes to use terminal foreground and background colors respectively.

E.g. ^B5^ would use color5 as the background color.

https://dwm.suckless.org/patches/status2d/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_STATUS2D_XRDB_TERMCOLORS_PATCH 0
#+END_SRC

*** Systray

The systray patch adds systray for the status bar.

https://dwm.suckless.org/patches/systray/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_SYSTRAY_PATCH 0
#+END_SRC

*** Tags

Show tag symbols in bar.

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_TAGS_PATCH 0
#+END_SRC

*** Window Icon

This patch adds the window icon next to the window title in the bar.

The patch depends on Imlib2 for icon scaling.
You need to uncomment the corresponding line in config.mk to use the -lImlib2 library

Arch Linux:
    ~sudo pacman -S imlib2~
Debian:
    ~sudo apt install libimlib2-dev~

The author recommends adding the compiler flags of -O3 and -march=native to enable auto loop
vectorize for better performance.

https://github.com/AdamYuan/dwm-winicon
https://dwm.suckless.org/patches/winicon

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_WINICON_PATCH 0
#+END_SRC

*** Window Title

**** Main

Show window title in bar.

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_WINTITLE_PATCH 0
#+END_SRC

**** Floating

Shows window titles in the bar, but only for floating clients.

This depends on code from the flexwintitle patch.

Note that the configuration in config.def.h for this is merely an example. If combined with the corresponding hidden patch then these two will overlap unless the width of the modules are controlled.

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_WINTITLE_FLOATING_PATCH 0
#+END_SRC

**** Hidden

Shows window titles in the bar, but only for floating clients.

This depends on code from the flexwintitle patch.

Note that the configuration in config.def.h for this is merely an example. If combined with the corresponding floating patch then these two will overlap unless the width of the modules are controlled.

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_WINTITLE_HIDDEN_PATCH 0
#+END_SRC

*** Title Padding

Title bar modules such as wintitle (default), fancybar and awesomebar do not by default add left and/or right padding as they take up the remaining space. These options allow you explicitly add padding should you need it.

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_TITLE_RIGHT_PAD_PATCH 0
#define BAR_TITLE_LEFT_PAD_PATCH 0
#+END_SRC

** Bar Options

*** Active Tag Indicator

**** Main

This patch changes the rectangle indicating if a tag is used by a client into a bar above the tag name for better visibility.

Set the tagindicatortype variable in config.h to INDICATOR_TOP_BAR to enable this.

https://dwm.suckless.org/patches/activetagindicatorbar/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_ACTIVETAGINDICATORBAR_PATCH 0
#+END_SRC

**** Alternative

Alternative patch to the activetagindicatorbar patch, adds the bar below the tag icon rather than above.

Set the tagindicatortype variable in config.h to INDICATOR_BOTTOM_BAR to enable this.

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_ACTIVETAGINDICATORBAR_ALT1_PATCH 0
#+END_SRC

*** Alpha

The alpha patch adds transparency for the status bar.

You need to uncomment the corresponding line in config.mk to use the -lXrender library when including this patch.

https://dwm.suckless.org/patches/alpha/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_ALPHA_PATCH 0
#+END_SRC

*** Alternative Tags

This patch introduces alternative tags which can be switched on the fly for the sole purpose of providing visual aid.

https://dwm.suckless.org/patches/alternativetags/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_ALTERNATIVE_TAGS_PATCH 0
#+END_SRC

*** Alternative Tags Decoration

This patches provides the ability to use alternative text for tags which contain at least one window.

https://dwm.suckless.org/patches/alttagsdecoration/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_ALTTAGSDECORATION_PATCH 0
#+END_SRC

*** Anybar

**** Main

This patch enables dwm to manage external status bars such as lemonbar and polybar.

dwm treats the external bar as it would its own, so all regular dwm commands such as togglebar affect the external bar in the same way.

NB: Unless you want both anybar + dwm bar(s) then the recommendation is to disable all bar modules and have { -2 } in the barrules.

https://dwm.suckless.org/patches/anybar/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_ANYBAR_PATCH 1
#+END_SRC

**** Top and Bottom Bars

Anybar option to place the next bar depending on previous bar's position (top or bottom)

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_ANYBAR_TOP_AND_BOTTOM_BARS_PATCH 0
#+END_SRC

**** Manage Width

Anybar option to let dwm manage the width of the bar.

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_ANYBAR_MANAGE_WIDTH_PATCH 0
#+END_SRC

*** Border

This patch adds a border around the status bar(s) just like the border of client windows.

https://codemadness.org/paste/dwm-border-bar.patch

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_BORDER_PATCH 0
#+END_SRC

*** Centered Window Name

This patch centers the WM_NAME of the currently selected window on the status bar.

This is compatible with the wintitle, bartabgroups, flexwintitle and awesomebar bar modules.

https://dwm.suckless.org/patches/centeredwindowname/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_CENTEREDWINDOWNAME_PATCH 0
#+END_SRC

*** Client Indicator

Draws a dot indicator overlayed on each tag icon for each client. The selected client is drawn as a larger horizontal line.

Set the tagindicatortype variable in config.h to INDICATOR_CLIENT_DOTS to enable this.

https://dwm.suckless.org/patches/clientindicators/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_CLIENTINDICATOR_PATCH 0
#+END_SRC

*** Dmenu Match Top

Updates the position of dmenu to match that of the bar. I.e. if topbar is 0 then dmenu will appear at the bottom and if 1 then dmenu will appear at the top.

https://dwm.suckless.org/patches/dmenumatchtop

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_DMENUMATCHTOP_PATCH 0
#+END_SRC

*** Extra Status

Originally this was the extrabar patch, but as the handling of extra bars is now built-in only the splitting of the status by a designated separator remains. As such this has been renamed to more accurately reflect what it does - creating an extra status.

https://dwm.suckless.org/patches/extrabar/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_EXTRASTATUS_PATCH 0
#+END_SRC

*** EWMH Tags

Adds EWMH support for _NET_NUMBER_OF_DESKTOPS, _NET_CURRENT_DESKTOP, _NET_DESKTOP_NAMES and _NET_DESKTOP_VIEWPORT, which allows for compatibility with other bars and programs that request workspace information. For example polybar's xworkspaces module.

This patch also includes support for adding the _IS_FLOATING property for floating windows allowing for compositors to treat floating windows differently to tiled windows.

E.g. this setting makes picom only render shadows for floating windows:

    shadow-exclude = [ "! _IS_FLOATING@:32c = 1" ];

https://github.com/bakkeby/dwm-flexipatch/issues/50 (_IS_FLOATING patch)

https://dwm.suckless.org/patches/ewmhtags/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_EWMHTAGS_PATCH 1
#+END_SRC

*** Height

Allows the bar height to be explicitly set rather than being derived from font.

https://dwm.suckless.org/patches/bar_height/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_HEIGHT_PATCH 0
#+END_SRC

*** Hide Vacant Tags

This patch prevents dwm from drawing tags with no clients (i.e. vacant) on the bar.

https://dwm.suckless.org/patches/hide_vacant_tags/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_HIDEVACANTTAGS_PATCH 0
#+END_SRC

*** Holdbar

With this patch dwm's built-in status bar is only shown when HOLDKEY is pressed and the bar will now overlay the display.

http://dwm.suckless.org/patches/holdbar/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_HOLDBAR_PATCH 0
#+END_SRC

*** Ignore Xft Errors When Drawing Text

Sometimes dwm crashes when it cannot render some glyphs in window titles (usually emoji).

This patch is essentially a hack to ignore any errors when drawing text on the status bar.

https://groups.google.com/forum/m/#!topic/wmii/7bncCahYIww

https://docs.google.com/viewer?a=v&pid=forums&srcid=MDAwODA2MTg0MDQyMjE0OTgzMzMBMDQ3ODQzODkyMTU3NTAyMTMxNTYBX2RUMVNtOUtDQUFKATAuMQEBdjI&authuser=0

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_IGNORE_XFT_ERRORS_WHEN_DRAWING_TEXT_PATCH 0
#+END_SRC

*** No Color Emoji

This patch adds back in the workaround for a BadLength error in the Xft library when color glyphs are used. This is for systems that do not have an updated version of the Xft library (or generally prefer monochrome fonts).

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_NO_COLOR_EMOJI_PATCH 0
#+END_SRC

*** Padding

**** Main

This patch adds vertical and horizontal space between the statusbar and the edge of the screen.

https://dwm.suckless.org/patches/barpadding/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_PADDING_PATCH 0
#+END_SRC

**** Vanity Gaps

Same as barpadding patch but specifically tailored for the vanitygaps patch in that the outer bar padding is derived from the vanitygaps settings. In addition to this the bar padding is toggled in unison when vanitygaps are toggled. Increasing or decreasing gaps during runtime will not affect the bar padding.

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_PADDING_VANITYGAPS_PATCH 0
#+END_SRC

**** Smart

Smart bar padding patch that automatically adjusts the padding when there is only one client on the monitor. Works well with vanitygaps and barpadding patches.

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_PADDING_SMART_PATCH 0
#+END_SRC

*** Pango

This patch adds simple markup for status messages using pango markup.

This depends on the pango library v1.44 or greater.

You need to uncomment the corresponding lines in config.mk to use the pango libraries when including this patch.

Note that the pango patch does not protect against the BadLength error from Xft when color glyphs are used, which means that dwm will crash if color emoji is used.

If you need color emoji then you may want to install this patched library from the AUR: https://aur.archlinux.org/packages/libxft-bgra/

A long term fix for the libXft library is pending approval of this pull request: https://gitlab.freedesktop.org/xorg/lib/libxft/-/merge_requests/1

Also see:
https://developer.gnome.org/pygtk/stable/pango-markup-language.html
https://lists.suckless.org/hackers/2004/17285.html
https://dwm.suckless.org/patches/pango/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_PANGO_PATCH 0
#+END_SRC

*** Static Status

This patch allows the status text to be fixed to the bar on a specific monitor rather than being drawn on the focused monitor.

The statusallmons patch takes precedence over this patch.

https://dwm.suckless.org/patches/staticstatus/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_STATICSTATUS_PATCH 0
#+END_SRC

*** Status All Monitors

This patch draws and updates the statusbar on all monitors.

https://dwm.suckless.org/patches/statusallmons/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_STATUSALLMONS_PATCH 0
#+END_SRC

*** Status Colors

This patch enables colored text in the status bar. It changes the way colors are defined in config.h allowing multiple color combinations for use in the status script.

This patch is incompatible with and takes precedence over the status2d patch.

This patch is compatible with the statuscmd patch with the caveat that the first 16 markers are reserved for status colors restricting block signals to 17 through 31.

https://dwm.suckless.org/patches/statuscolors/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_STATUSCOLORS_PATCH 0
#+END_SRC

*** Status Padding

This patch adds configuration options for horizontal and vertical padding in the status bar.

https://dwm.suckless.org/patches/statuspadding/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_STATUSPADDING_PATCH 0
#+END_SRC

*** VT Colors
This patch adds the ability for dwm to read colors from the linux virtual console.

   /sys/module/vt/parameters/default_{red,grn,blu}

Essentially this way the colors you use in your regular tty is "mirrored" to dwm.

https://dwm.suckless.org/patches/vtcolors/

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_VTCOLORS_PATCH 0
#+END_SRC

*** Window Title Actions

This patch allows client windows to be hidden. This code was originally part of awesomebar, but has been separated out so that other bar modules can take advantage of it.

Both awesomebar and bartabgroups patches depend on this patch and it will be auto-enabled during compile time if it is needed. Note that if using flexipatch-finalizer this must be explicitly enabled.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-barmodules-wintitleactions-6.2.diff

#+BEGIN_SRC c :tangle patches.def.h
#define BAR_WINTITLEACTIONS_PATCH BAR_AWESOMEBAR_PATCH || BAR_TABGROUPS_PATCH || BAR_FLEXWINTITLE_PATCH
#+END_SRC

** Other

*** Alt Tab

Adds a window task switcher toggled using alt-tab.

https://dwm.suckless.org/patches/alt-tab/

#+BEGIN_SRC c :tangle patches.def.h
#define ALT_TAB_PATCH 0
#+END_SRC

*** Always Center

All floating windows are centered, like the center patch, but without a rule. The center patch takes precedence over this patch. This patch interferes with the center transient windows patches.

https://dwm.suckless.org/patches/alwayscenter/

#+BEGIN_SRC c :tangle patches.def.h
#define ALWAYSCENTER_PATCH 1
#+END_SRC

*** Aspect Resize

This patch allows windows to be resized with its aspect ratio remaining constant.

https://dwm.suckless.org/patches/aspectresize/

#+BEGIN_SRC c :tangle patches.def.h
#define ASPECTRESIZE_PATCH 1
#+END_SRC

*** Attach Above

This patch adds new clients above the selected client, instead of always becoming the new master. This behaviour is known from Xmonad.

This patch takes precedence over ATTACHASIDE_PATCH.

https://dwm.suckless.org/patches/attachabove/

#+BEGIN_SRC c :tangle patches.def.h
#define ATTACHABOVE_PATCH 0
#+END_SRC

*** Attach Aside

This patch adds new clients on top of the stack.

This patch takes precedence over ATTACHBELOW_PATCH.

https://dwm.suckless.org/patches/attachaside/

#+BEGIN_SRC c :tangle patches.def.h
#define ATTACHASIDE_PATCH 0
#+END_SRC

*** Attach Below

This patch adds new clients below the selected client.

This patch takes precedence over ATTACHBOTTOM_PATCH.

https://dwm.suckless.org/patches/attachbelow/

#+BEGIN_SRC c :tangle patches.def.h
#define ATTACHBELOW_PATCH 1
#+END_SRC

*** Attach Bottom

This patch adds new clients at the bottom of the stack.

https://dwm.suckless.org/patches/attachbottom/

#+BEGIN_SRC c :tangle patches.def.h
#define ATTACHBOTTOM_PATCH 0
#+END_SRC

*** Auto Start

This patch will make dwm run "~/.local/share/dwm/autostart_blocking.sh" and "~/.local/share/dwm/autostart.sh &" before entering the handler loop. One or both of these files can be ommited. Note the path inside .local/share rather than the original ~/.dwm folder.

https://dwm.suckless.org/patches/autostart/

#+BEGIN_SRC c :tangle patches.def.h
#define AUTOSTART_PATCH 0
#+END_SRC

*** Auto Resize

By default, windows that are not visible when requesting a resize/move will not get resized/moved. With this patch, they will.

https://dwm.suckless.org/patches/autoresize/

#+BEGIN_SRC c :tangle patches.def.h
#define AUTORESIZE_PATCH 1
#+END_SRC

*** Bidi (Right to Left Languages)

This patch adds proper support for Right-To-Left languages. (such as Farsi, Arabic or Hebrew).

You need to uncomment the corresponding lines in =config.mk= to use the =-lfribidi= library when including this patch.

This patch depends on the following additional library:
   - fribidi

https://dwm.suckless.org/patches/bidi/

#+BEGIN_SRC c :tangle patches.def.h
#define BIDI_PATCH 0
#+END_SRC

*** Center

This patch adds an iscentered rule to automatically center clients on the current monitor.

This patch takes precedence over centeredwindowname, alwayscenter and fancybar patches.

https://dwm.suckless.org/patches/center/

#+BEGIN_SRC c :tangle patches.def.h
#define CENTER_PATCH 0
#+END_SRC

*** Center Transient

**** Main

A transient window is one that is meant to be short lived and is usually raised by a parent window. Such windows are typically dialog boxes and the like.

It should be noted that in dwm transient windows are not subject to normal client rules and they are always floating by default.

This patch centers transient windows on the screen like the center patch does. Note that the 6.2 center patch piggy-backed on the updatewindowtype function to ensure that all dialog boxes were centered, transient or not. This function was removed in relation to adding wintype as a client rule filter, hence this no longer works out of the box. This patch restores previous behaviour with the center patch.

#+BEGIN_SRC c :tangle patches.def.h
#define CENTER_TRANSIENT_WINDOWS_PATCH 0
#+END_SRC

**** By Parent

As above, except that the transient window is centered within the position of the parent window, rather than at the center of the screen. This takes precedence over the above patch.

#+BEGIN_SRC c :tangle patches.def.h
#define CENTER_TRANSIENT_WINDOWS_BY_PARENT_PATCH 0
#+END_SRC

*** CFacts

This patch provides the ability to assign different weights to clients in their respective stack in tiled layout.

https://dwm.suckless.org/patches/cfacts/

#+BEGIN_SRC c :tangle patches.def.h
#define CFACTS_PATCH 1
#+END_SRC

*** CMD Customize

This patch allows color attributes to be set through the command line.

https://dwm.suckless.org/patches/cmdcustomize/

#+BEGIN_SRC c :tangle patches.def.h
#define CMDCUSTOMIZE_PATCH 0
#+END_SRC

*** Combo

This patch tweaks the tagging interface so that you can select multiple tags for tag or view by pressing all the right keys as a combo. For example to view tags 1 and 3, hold MOD and then press and hold 1 and 3 together.

https://dwm.suckless.org/patches/combo/

#+BEGIN_SRC c :tangle patches.def.h
#define COMBO_PATCH 1
#+END_SRC

*** Cool Auto Start

Allow dwm to execute commands from autostart array in your config.h file. When dwm exits then all processes from autostart array will be killed.

https://dwm.suckless.org/patches/cool_autostart/

#+BEGIN_SRC c :tangle patches.def.h
#define COOL_AUTOSTART_PATCH 0
#+END_SRC

*** Cycle Layouts

The cyclelayouts patch lets you cycle through all your layouts.

https://dwm.suckless.org/patches/cyclelayouts/

#+BEGIN_SRC c :tangle patches.def.h
#define CYCLELAYOUTS_PATCH 1
#+END_SRC

*** Decoration Hints

Make dwm respect _MOTIF_WM_HINTS property, and not draw borders around windows requesting for it. Some applications use this property to notify window managers to not draw window decorations.

Not respecting this property leads to issues with applications that draw their own borders, like chromium (with "Use system title bar and borders" turned off) or vlc in fullscreen mode.

https://dwm.suckless.org/patches/decoration_hints/

#+BEGIN_SRC c :tangle patches.def.h
#define DECORATION_HINTS_PATCH 0
#+END_SRC

*** Distribute Tags

This feature distributes all clients on the current monitor evenly across all tags.

It is a variant of the reorganizetags patch.

https://dwm.suckless.org/patches/reorganizetags/

#+BEGIN_SRC c :tangle patches.def.h
#define DISTRIBUTETAGS_PATCH 0
#+END_SRC

*** Do Not Die on Color Allocation Failure

By default dwm will terminate on color allocation failure and the behaviour is intended to catch and inform the user of color configuration issues.

Some patches like status2d and xresources / xrdb can change colours during runtime, which means that if a color can't be allocated at this time then the window manager will abruptly terminate.

This patch will ignore color allocation failures and continue on as normal. The effect of this is that the existing color, that was supposed to be replaced, will remain as-is.

#+BEGIN_SRC c :tangle patches.def.h
#define DO_NOT_DIE_ON_COLOR_ALLOCATION_FAILURE_PATCH 0
#+END_SRC

*** Drag CFact

Similarly to the dragmfact patch this allows you to click and drag clients to change the cfact to adjust the client's size in the stack. This patch depends on the cfacts patch.

#+BEGIN_SRC c :tangle patches.def.h
#define DRAGCFACT_PATCH 0
#+END_SRC

*** Drag MFact

This patch lets you resize the split in the tile layout (i.e. modify mfact) by holding the modkey and dragging the mouse.

This patch can be a bit wonky with other layouts, but generally works.

https://dwm.suckless.org/patches/dragmfact/

#+BEGIN_SRC c :tangle patches.def.h
#define DRAGMFACT_PATCH 0
#+END_SRC

*** DWMC

Simple dwmc client using a fork of fsignal to communicate with dwm.

To use this either copy the patch/dwmc shell script to somewhere in your path or uncomment the following line in Makefile:

   #cp -f patch/dwmc ${DESTDIR}${PREFIX}/bin

http://dwm.suckless.org/patches/dwmc/

#+BEGIN_SRC c :tangle patches.def.h
#define DWMC_PATCH 1
#+END_SRC

*** Empty View

This patch allows no tag at all to be selected. The result is that dwm will start with no tag selected and when you start a client with no tag rule and no tag selected then it will be opened on the first tag.

https://dwm.suckless.org/patches/emptyview/

#+BEGIN_SRC c :tangle patches.def.h
#define EMPTYVIEW_PATCH 0
#+END_SRC

*** Extension Resize

This patch allows the user to change size and placement of floating windows using only the keyboard. It also allows for temporary vertical and horizontal extension of windows similar to other WMs fill command.

https://dwm.suckless.org/patches/exresize/

#+BEGIN_SRC c :tangle patches.def.h
#define EXRESIZE_PATCH 0
#+END_SRC

*** Fake Fullscreen

Only allow clients to "fullscreen" into the space currently given to them.

As an example, this will allow you to view a fullscreen video in your browser on one half of the screen, while having the other half available for other tasks.

This patch takes precedence over the fakefullscreen client patch below.

https://dwm.suckless.org/patches/fakefullscreen/

#+BEGIN_SRC c :tangle patches.def.h
#define FAKEFULLSCREEN_PATCH 0
#+END_SRC

*** Fake Fullscreen Client

Similarly to the fakefullscreen patch this patch only allows clients to "fullscreen" into the space currently given to them.

The "twist" with this patch is that fake fullscreen can be toggled on a per client basis rather than applying to all clients globally.

Also see the selectivefakefullscreen option that adds a rule option to enabled this on client startup.

#+BEGIN_SRC c :tangle patches.def.h
#define FAKEFULLSCREEN_CLIENT_PATCH 0
#+END_SRC

*** Float Position

**** Main

This patch adds a float rule allowing the size and position of floating windows to be specified It also allows the size and position of floating windows to be controlled similar to the exresize, moveresize, and moveplace patches.

The size and position can be specified using absolute, relative or fixed co-ordinates and

https://github.com/bakkeby/patches/wiki/floatpos/

#+BEGIN_SRC c :tangle patches.def.h
#define FLOATPOS_PATCH 0
#+END_SRC

**** Respect Gaps

Add-on functionality for the above: make the float positions respect outer (vanity)gaps.

#+BEGIN_SRC c :tangle patches.def.h
#define FLOATPOS_RESPECT_GAPS_PATCH 0
#+END_SRC

*** Focus Adjacent Tag

This patch provides the ability to focus the tag on the immediate left or right of the currently focused tag. It also allows to send the focused window either on the left or the right tag.

http://dwm.suckless.org/patches/focusadjacenttag/

#+BEGIN_SRC c :tangle patches.def.h
#define FOCUSADJACENTTAG_PATCH 0
#+END_SRC

*** Focus Direction

Allows focusing on clients based on direction (up, down, left, right) instead of client order.

https://github.com/bakkeby/patches/wiki/focusdir/

#+BEGIN_SRC c :tangle patches.def.h
#define FOCUSDIR_PATCH 0
#+END_SRC

*** Focus Follow Mouse

When changing tags, closing windows or moving clients out of view then focus will revert to the
client window that remains under the mouse cursor rather than the most recently focused window.

https://github.com/bakkeby/patches/wiki/focusfollowmouse

#+BEGIN_SRC c :tangle patches.def.h
#define FOCUSFOLLOWMOUSE_PATCH 0
#+END_SRC

*** Focus Master

A simple patch that just puts focus back to the master client.

https://dwm.suckless.org/patches/focusmaster/

#+BEGIN_SRC c :tangle patches.def.h
#define FOCUSMASTER_PATCH 0
#+END_SRC

*** Focus Master Return

A variant of the focusmaster patch that additionally allows the focus to be returned to the
previously focused client

https://dwm.suckless.org/patches/focusmaster/

#+BEGIN_SRC c :tangle patches.def.h
#define FOCUSMASTER_RETURN_PATCH 0
#+END_SRC

*** Focus On Click

Switch focus only by mouse click and not sloppy (focus follows mouse pointer).

https://dwm.suckless.org/patches/focusonclick/

#+BEGIN_SRC c :tangle patches.def.h
#define FOCUSONCLICK_PATCH 0
#+END_SRC

*** Focus Urgent

Selects the next window having the urgent flag regardless of the tag it is on.

The urgent flag can be artificially set with the following xdotool command on any window:

  xdotool selectwindow -- set_window --urgency 1

https://dwm.suckless.org/patches/focusurgent/

#+BEGIN_SRC c :tangle patches.def.h
#define FOCUSURGENT_PATCH 0
#+END_SRC

*** Focus On Net Active

By default, dwm responds to _NET_ACTIVE_WINDOW client messages by setting the urgency bit on the named window. This patch activates the window instead.

https://dwm.suckless.org/patches/focusonnetactive/

#+BEGIN_SRC c :tangle patches.def.h
#define FOCUSONNETACTIVE_PATCH 1
#+END_SRC

*** Fake Signals

Send "fake signals" to dwm for handling, using xsetroot. This will not conflict with the status bar, which also is managed using xsetroot.

Also see the dwmc patch, which takes precedence over this patch.

https://dwm.suckless.org/patches/fsignal/

#+BEGIN_SRC c :tangle patches.def.h
#define FSIGNAL_PATCH 0
#+END_SRC

*** Fullscreen

Applies the monocle layout with the focused client on top and hides the bar. When pressed again it shows the bar and restores the layout that was active before going fullscreen.

https://dwm.suckless.org/patches/fullscreen/

#+BEGIN_SRC c :tangle patches.def.h
#define FULLSCREEN_PATCH 0
#+END_SRC

*** In-Place Rotate

This patch provides a keybinding to rotate all clients in the currently selected area (master or stack) without affecting the other area.

https://dwm.suckless.org/patches/inplacerotate/

#+BEGIN_SRC c :tangle patches.def.h
#define INPLACEROTATE_PATCH 0
#+END_SRC

*** Insets

This patch lets you define custom insets from each edge of the screen. One use case would be to arrange space for an external bar.

https://dwm.suckless.org/patches/insets/

#+BEGIN_SRC c :tangle patches.def.h
#define INSETS_PATCH 0
#+END_SRC

*** IPC

This patch (v1.5.7) implements inter-process communication through a UNIX socket for dwm. This allows for the window manager to be queried for information, e.g. listen for events such as tag or layout changes, as well as send commands to control the window manager via other programs.

You need to uncomment the corresponding lines in config.mk to use the -lyajl library when including this patch.

This patch depends on the following additional library:
   - yajl

https://github.com/mihirlad55/dwm-ipc

https://dwm.suckless.org/patches/ipc/

#+BEGIN_SRC c :tangle patches.def.h
#define IPC_PATCH 1
#+END_SRC

*** Is Permanent

Adds rule option for clients to avoid accidental termination by killclient for sticky windows.

https://dwm.suckless.org/patches/ispermanent/

#+BEGIN_SRC c :tangle patches.def.h
#define ISPERMANENT_PATCH 0
#+END_SRC

*** Key Modes

This patch adds key modes (like in vim or emacs) where chains of keyboard shortcuts can be performed.

https://dwm.suckless.org/patches/keymodes/

#+BEGIN_SRC c :tangle patches.def.h
#define KEYMODES_PATCH 0
#+END_SRC

*** Kill Unselected

This patch adds a keybinding to kills all visible clients that are not selected.

https://dwm.suckless.org/patches/killunsel/

#+BEGIN_SRC c :tangle patches.def.h
#define KILLUNSEL_PATCH 0
#+END_SRC

*** LG3d

This changes the window manager name to LG3d instead of dwm as a workaround for Java applications that assume that the window manager is using window reparenting.

Refer to the ISSUES secton of the dwm man page for more details.

#+BEGIN_SRC c :tangle patches.def.h
#define LG3D_PATCH 0
#+END_SRC

*** Lose Fullscreen

By default in dwm it is possible to make an application fullscreen, then use the focusstack keybindings to focus on other windows beneath the current window.

It is also possible to spawn new windows (e.g. a terminal) that end up getting focus while the previous window remains in fullscreen. This patch ensures that in such scenarios the previous window loses fullscreen.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-losefullscreen-6.2.diff

#+BEGIN_SRC c :tangle patches.def.h
#define LOSEFULLSCREEN_PATCH 1
#+END_SRC

*** Maximize Floating Windows

This patch adds helper functions for maximizing, horizontally and vertically, floating windows using keybindings.

https://dwm.suckless.org/patches/maximize/

#+BEGIN_SRC c :tangle patches.def.h
#define MAXIMIZE_PATCH 0
#+END_SRC

*** Music Player Daemon

Control Music Player Daemon via keybinds.

You need to uncomment the corresponding line in config.mk to use the -lmpdclient library when including this patch.

This patch depends on the following additional library:
   - libmpdclient

https://dwm.suckless.org/patches/mpdcontrol/

#+BEGIN_SRC c :tangle patches.def.h
#define MPDCONTROL_PATCH 0
#+END_SRC

*** Monitor Rules

Adds rules per monitor, e.g. have default layouts per monitor.

The use case for this is if the second monitor is vertical (i.e. rotated) then you may want to use a different default layout for this monitor than what is used for the main monitor. E.g. normal vertical split for main monitor and horizontal split for the second.

#+BEGIN_SRC c :tangle patches.def.h
#define MONITOR_RULES_PATCH 0
#+END_SRC

*** Monocle Symbol

Always display the the monocle-symbol as defined in config.h if the monocle-layout is activated. Do not display the number of open clients in the current tag.

https://dwm.suckless.org/patches/monoclesymbol/

#+BEGIN_SRC c :tangle patches.def.h
#define MONOCLESYMBOL_PATCH 0
#+END_SRC

*** Move Place

Makes a window floating and 1/3rd the height and 1/3rd the width of the screen and is positioned in either the center or one of the 8 cardinal directions depending on which key is pressed.

https://dwm.suckless.org/patches/moveplace/

#+BEGIN_SRC c :tangle patches.def.h
#define MOVEPLACE_PATCH 0
#+END_SRC

*** Move Resize

This patch allows you to move and resize dwm's clients using keyboard bindings.

https://dwm.suckless.org/patches/moveresize/

#+BEGIN_SRC c :tangle patches.def.h
#define MOVERESIZE_PATCH 0
#+END_SRC

*** Move Stack

This patch allows you to move clients around in the stack and swap them with the master.

https://dwm.suckless.org/patches/movestack/

#+BEGIN_SRC c :tangle patches.def.h
#define MOVESTACK_PATCH 1
#+END_SRC

*** Name Tag

**** Main

This patch allows you to change the names of tags during runtime.

This is a bespoke version implemented specifically in relation to tagicons, which is integrated
into dwm-flexipatch. By default it uses dmenu to retrieve the new name, but this can be
customised via config along with the maximum text length and the format string.

Special behaviour:
   - if more than one tag is selected then the name change applies to all selected tags
   - if tagicons is configured to have unique tags per monitor then the change only applies
     for the current monitor
   - the name change applies to the tag set that is active for the current tag:
      * if used in combination with BAR_ALTTAGSDECORATION_PATCH and there are clients on the
        given tag then the name change only applies to the ALT_TAGS_DECORATION tag set
      * if used in combination with the BAR_ALTERNATIVE_TAGS_PATCH and alternative tags are
        shown then the name change only applies to the ALTERNATIVE_TAGS tag set
      * if used in combination with both then BAR_ALTTAGSDECORATION_PATCH takes precedence
      * otherwise the name change applies to the DEFAULT_TAGS tag set

https://dwm.suckless.org/patches/nametag/

#+BEGIN_SRC c :tangle patches.def.h
#define NAMETAG_PATCH 0
#+END_SRC

**** Prepend

Variant of the above which prepends the tag number to the given string. The toggle does nothing on its own and need to be enabled in combination with the above.

#+BEGIN_SRC c :tangle patches.def.h
#define NAMETAG_PREPEND_PATCH 0
#+END_SRC

*** Net Client List Stacking

Adds support for the _NET_CLIENT_LIST_STACKING atom, needed by certain applications like the Zoom video conferencing application.

https://github.com/bakkeby/patches/wiki/netclientliststacking/

#+BEGIN_SRC c :tangle patches.def.h
#define NET_CLIENT_LIST_STACKING_PATCH 1
#+END_SRC

*** No Border

Removes the border when there is only one window visible.

https://dwm.suckless.org/patches/noborder/

#+BEGIN_SRC c :tangle patches.def.h
#define NOBORDER_PATCH 0
#+END_SRC

*** No Dmenu

Enable modifying or removing dmenu in config.def.h which resulted previously in a
compilation error because two lines of code hardcode dmenu into dwm.
https://dwm.suckless.org/patches/nodmenu/

#+BEGIN_SRC c :tangle patches.def.h
#define NODMENU_PATCH 0
#+END_SRC

*** No Mod Buttons

This patch allows for toggleable client button bindings that have no modifiers.

This can, for example, allow you to move or resize using the mouse alone without holding down a modifier key. This can be practical if you have extra buttons on your mouse.

While you can use button bindings with no modifiers without this patch in a bare dwm, those buttons are then unavailable for use within the application itself so being able to toggle these on and off can be necessary in certain situations (e.g. being able to use back and forward buttons in a browser).

Example bindings:
    { ClkClientWin,              0,              Button8,        movemouse,      {0} },
    { ClkClientWin,              0,              Button9,        resizemouse,    {0} },

#+BEGIN_SRC c :tangle patches.def.h
#define NO_MOD_BUTTONS_PATCH 0
#+END_SRC

*** No Transparent Borders

When terminals have transparency then their borders also become transparent.

This patch ensures that borders have no transparency. Note that this patch is only relevant if you are not using the alpha patch.

https://github.com/szatanjl/dwm/commit/1529909466206016f2101457bbf37c67195714c8

https://dwm.suckless.org/patches/alpha/dwm-fixborders-6.2.diff

#+BEGIN_SRC c :tangle patches.def.h
#define NO_TRANSPARENT_BORDERS_PATCH 1
#+END_SRC

*** On Empty Keys

Port of InstantVM's on_empty_keys functionality allowing keybindings that apply only when a tag is empty. An example use case is being able to launch applications with first hand keys like "f" to launch firefox.

https://github.com/instantOS/instantWM/

https://github.com/bakkeby/dwm-flexipatch/issues/51

#+BEGIN_SRC c :tangle patches.def.h
#define ON_EMPTY_KEYS_PATCH 0
#+END_SRC

*** Only One Rule Match

Minor patch that prevents more than one rule being matched for a given client.

#+BEGIN_SRC c :tangle patches.def.h
#define ONLY_ONE_RULE_MATCH_PATCH 0
#+END_SRC

*** Only Quit On Empty

This patch makes it so dwm will only exit via quit() if no windows are open.

This is to prevent you accidentally losing all your work.

https://dwm.suckless.org/patches/onlyquitonempty/

#+BEGIN_SRC c :tangle patches.def.h
#define ONLYQUITONEMPTY_PATCH 0
#+END_SRC

*** Per Tag

**** Main

The pertag patch adds nmaster, mfacts and layouts per tag rather than per monitor (default).

https://dwm.suckless.org/patches/pertag/

#+BEGIN_SRC c :tangle patches.def.h
#define PERTAG_PATCH 1
#+END_SRC

**** Vanity Gaps

Option to enable gaps on a per tag basis rather than globally.

Depends on both pertag and vanitygaps patches being enabled.

#+BEGIN_SRC c :tangle patches.def.h
#define PERTAG_VANITYGAPS_PATCH 0
#+END_SRC

**** Bar

This controls whether or not to also store bar position on a per tag basis, or leave it as one bar per monitor.

#+BEGIN_SRC c :tangle patches.def.h
#define PERTAGBAR_PATCH 0
#+END_SRC

*** Per Monitor

**** Vanity Gaps

This patch allows configuring vanity gaps on a per-monitor basis rather than all monitors (default).

#+BEGIN_SRC c :tangle patches.def.h
#define PERMON_VANITYGAPS_PATCH 0
#+END_SRC

*** Place Direction

Similar to the focusdir patch this patch allow users to move a window in any direction in the tiled stack (up, down, left, right).

https://github.com/bakkeby/patches/wiki/placedir

#+BEGIN_SRC c :tangle patches.def.h
#define PLACEDIR_PATCH 0
#+END_SRC

*** Place Mouse

This patch lets you change the position of a client in the stack using the mouse.

https://github.com/bakkeby/patches/wiki/placemouse

#+BEGIN_SRC c :tangle patches.def.h
#define PLACEMOUSE_PATCH 1
#+END_SRC

*** Push

**** Main

This patch provides a way to move clients up and down inside the client list.

https://dwm.suckless.org/patches/push/

#+BEGIN_SRC c :tangle patches.def.h
#define PUSH_PATCH 0
#+END_SRC

**** No Master

This patch provides a way to move clients up and down inside the client list, but does not push up or down into the master area (except that it does not take nmaster into account).

This takes precedence over the push patch above.

https://dwm.suckless.org/patches/push/

#+BEGIN_SRC c :tangle patches.def.h
#define PUSH_NO_MASTER_PATCH 0
#+END_SRC

*** Renamed Scratchpads

**** Main

Variant of the named scratchpads patch allowing scratch keys to be added or removed
on demand, allowing multiple scratchpad windows to be toggled into and out of view
in unison, as well as including multi-monitor support.

https://github.com/bakkeby/patches/wiki/renamedscratchpads

#+BEGIN_SRC c :tangle patches.def.h
#define RENAMED_SCRATCHPADS_PATCH 0
#+END_SRC

**** Auto-Hide

Renamed scratchpads option to auto-hide scratchpads when moving to a different tag.
This behaviour is similar to that of the (multiple) scratchpads patch.

#+BEGIN_SRC c :tangle patches.def.h
#define RENAMED_SCRATCHPADS_AUTO_HIDE_PATCH 0
#+END_SRC

*** Re-Organize Tags

Shifts all clients per tag to leftmost unoccupied tags.

For example, if clients A, B, C are tagged on tags 1, 5, 9 respectively, when this function is called, they will now be on 1, 2, and 3. The focused client will also remain focused.

Clients on multiple tags will be treated as if they only were only on their leftmost tag, and will be reduced to one tag after the operation is complete.

https://dwm.suckless.org/patches/reorganizetags/

#+BEGIN_SRC c :tangle patches.def.h
#define REORGANIZETAGS_PATCH 0
#+END_SRC

*** Resize Corners

By default, windows only resize from the bottom right corner. With this patch the mouse is warped to the nearest corner and you resize from there.

https://dwm.suckless.org/patches/resizecorners/

#+BEGIN_SRC c :tangle patches.def.h
#define RESIZECORNERS_PATCH 1
#+END_SRC

*** Resize Point

Practically the same as resizecorners, but the cursor does not warp to corners.

This takes precedence over the resizecorners patch.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-resizepoint-6.2.diff

#+BEGIN_SRC c :tangle patches.def.h
#define RESIZEPOINT_PATCH 0
#+END_SRC

*** Restart SIG

Adds a keyboard shortcut to restart dwm or alternatively by using kill -HUP dwmpid.

Additionally dwm can quit cleanly by using kill -TERM dwmpid.

https://dwm.suckless.org/patches/restartsig/

#+BEGIN_SRC c :tangle patches.def.h
#define RESTARTSIG_PATCH 1
#+END_SRC

*** Rio Draw

Adds rio-like drawing to resize the selected client.

This depends on an external tool slop being installed.

This patch was backported from instantWM.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-riodraw-6.2.diff

#+BEGIN_SRC c :tangle patches.def.h
#define RIODRAW_PATCH 0
#+END_SRC

*** Rotate Stack

This patch let's you rotate through the stack using keyboard shortcuts.

https://dwm.suckless.org/patches/rotatestack/

#+BEGIN_SRC c :tangle patches.def.h
#define ROTATESTACK_PATCH 0
#+END_SRC

*** Rounded Corners

This patch adds rounded corners to client windows in dwm.

You need to uncomment the corresponding line in config.mk to use the -lXext library when including this patch. You will also want to set "borderpx = 0;" in your config.h.

https://github.com/mitchweaver/suckless/blob/master/dwm/patches/mitch-06-rounded_corners-f04cac6d6e39cd9e3fc4fae526e3d1e8df5e34b2.patch

#+BEGIN_SRC c :tangle patches.def.h
#define ROUNDED_CORNERS_PATCH 0
#+END_SRC

*** Save Floats

This patch saves size and position of every floating window before it is forced into tiled mode. If the window is made floating again then the old dimensions will be restored.

https://dwm.suckless.org/patches/save_floats/

#+BEGIN_SRC c :tangle patches.def.h
#define SAVEFLOATS_PATCH 0
#+END_SRC

*** Scratch Pads

**** Main

The scratchpad patch allows you to spawn or restore floating terminal windows.

It is typically useful when one need to do some short typing.

Note that this patch changes TAGMASK to make room for special scratchpad tags, so ~0 does more than select all tags with this patch. Code that relies on ~0 to represent all tags should use ~SPTAGMASK instead.

Upgraded to Christian Tenllado's multiple scratchpad version.

https://lists.suckless.org/hackers/2004/17205.html

https://dwm.suckless.org/patches/scratchpads/

#+BEGIN_SRC c :tangle patches.def.h
#define SCRATCHPADS_PATCH 0
#+END_SRC

**** Keep Position And Size

Minor alteration of the above allowing clients to keep their size and position when shown.

#+BEGIN_SRC c :tangle patches.def.h
#define SCRATCHPADS_KEEP_POSITION_AND_SIZE_PATCH 0
#+END_SRC

**** Alternative

This alternative patch enables a scratchpad feature in dwm similar to the scratchpad feature in i3wm.

https://github.com/GasparVardanyan/dwm-scratchpad

#+BEGIN_SRC c :tangle patches.def.h
#define SCRATCHPAD_ALT_1_PATCH 0
#+END_SRC

*** Seamless Restart

This patch persists some settings across window manager restarts. These include but are not limited to:
   - client's assigned tag(s) on which monitor
   - the order of clients
   - nmaster
   - selected layout
   - plus various additions depending on what other patches are used

The above is not persisted across reboots, however.

#+BEGIN_SRC c :tangle patches.def.h
#define SEAMLESS_RESTART_PATCH 1
#+END_SRC

*** Selective Fake Fullscreen

As opposed to the original patch this only adds a rule option allowing fake fullscreen to be enabled for applications when they start. This is intended to be used in combination with the fakefullscreenclient patch and offers no practical functionality without it.

https://dwm.suckless.org/patches/selectivefakefullscreen/

#+BEGIN_SRC c :tangle patches.def.h
#define SELECTIVEFAKEFULLSCREEN_PATCH 0
#+END_SRC

*** Self Restart

Allows restarting dwm without the dependency of an external script.

https://dwm.suckless.org/patches/selfrestart/

#+BEGIN_SRC c :tangle patches.def.h
#define SELFRESTART_PATCH 0
#+END_SRC

*** Send Monitor Center

Floating windows being sent to another monitor will be centered.

https://dwm.suckless.org/patches/sendmoncenter/

#+BEGIN_SRC c :tangle patches.def.h
#define SENDMON_CENTER_PATCH 0
#+END_SRC

*** Send Monitor Keep Focus

This patch allow clients to keep focus when being sent to another monitor.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-sendmon_keepfocus-6.2.diff

#+BEGIN_SRC c :tangle patches.def.h
#define SENDMON_KEEPFOCUS_PATCH 0
#+END_SRC

*** Set Border Pixels

This patch allows border pixels to be changed during runtime.

https://dwm.suckless.org/patches/setborderpx/

#+BEGIN_SRC c :tangle patches.def.h
#define SETBORDERPX_PATCH 0
#+END_SRC


*** Shift Both

Combines shifttag and shiftview. Basically moves the window to the next/prev tag and follows it. Also see the focusadjacenttag patch.

https://dwm.suckless.org/patches/shift-tools/

#+BEGIN_SRC c :tangle patches.def.h
#define SHIFTBOTH_PATCH 0
#+END_SRC

*** Shift Swap Tags

Swaps all the clients on the current tag with all the client on the next/prev tag. Depends on the swaptags patch.

https://dwm.suckless.org/patches/shift-tools/

#+BEGIN_SRC c :tangle patches.def.h
#define SHIFTSWAPTAGS_PATCH 0
#+END_SRC

*** Shift Tag

Moves the current selected client to the adjacent tag. Also see the focusadjacenttag patch.

https://dwm.suckless.org/patches/shift-tools/

#+BEGIN_SRC c :tangle patches.def.h
#define SHIFTTAG_PATCH 0
#+END_SRC

*** Shift Tag Clients

Moves the current selected client to the adjacent tag that has at least one client, if none then it acts as shifttag.

https://dwm.suckless.org/patches/shift-tools/

#+BEGIN_SRC c :tangle patches.def.h
#define SHIFTTAGCLIENTS_PATCH 0
#+END_SRC

*** Shift View

**** Main

This patch adds keybindings for left and right circular shift through tags.

https://github.com/chau-bao-long/dotfiles/blob/master/suckless/dwm/shiftview.diff

#+BEGIN_SRC c :tangle patches.def.h
#define SHIFTVIEW_PATCH 0
#+END_SRC

**** Clients

This variant of the shiftview patch adds left and right circular shift through tags, but skips tags where there are no clients.

#+BEGIN_SRC c :tangle patches.def.h
#define SHIFTVIEW_CLIENTS_PATCH 0
#+END_SRC

*** Size Hints

**** Main

This patch makes dwm obey even "soft" sizehints for new clients. Any window that requests a specific initial size will be floated and set to that size.

Unlike with "fixed size" windows, you are able to resize and/or unfloat these windows freely - only the initial state is affected.

This version of the patch is honestly of limited utility since there are many clients that will abuse it.

https://dwm.suckless.org/patches/sizehints/

#+BEGIN_SRC c :tangle patches.def.h
#define SIZEHINTS_PATCH 0
#+END_SRC

**** Ruled

This patch makes dwm obey even "soft" sizehints for new clients. This ruled version is essentially the same patch except it obeys the "isfloating" rule if it is available in config.h for the given client.

https://dwm.suckless.org/patches/sizehints/

#+BEGIN_SRC c :tangle patches.def.h
#define SIZEHINTS_RULED_PATCH 0
#+END_SRC

*** Sort Screens

In a multi-head setup monitor 0 is by default the primary screen, with the left and right screen being monitor 1 and 2 respectively. This patch sorts screens left to right (or top to bottom in a vertical layout) which aims to address some inconsistencies when it comes to focusmon, tagmon and similar functionality.

https://www.mail-archive.com/hackers@suckless.org/msg09400.html

#+BEGIN_SRC c :tangle patches.def.h
#define SORTSCREENS_PATCH 1
#+END_SRC

*** Spawn CMD

Spawns programs from currently focused client's working directory.

https://dwm.suckless.org/patches/spawn_cwd/

#+BEGIN_SRC c :tangle patches.def.h
#define SPAWNCMD_PATCH 0
#+END_SRC

*** Stacker

This patch provides comprehensive utilities for managing the client stack, providing keyboard shortcuts for focusing or placing a client at specific positions in the stack.

Note that the default keybindings for this patch have been changed in dwm-flexipatch due to the many conflicts with other patches. As it provides similar functionality to the swapfocus patch it also uses the MOD+s shortcut to focus the previously selected client, thus note a conflict between these two patches.

https://dwm.suckless.org/patches/stacker/

#+BEGIN_SRC c :tangle patches.def.h
#define STACKER_PATCH 0
#+END_SRC

*** Steam

Steam, and steam windows (games), trigger a ConfigureNotify request every time the window gets focus. More so, the configure event passed along from Steam tends to have the wrong x and y co-ordinates which can make the window, if floating, jump around the screen.

This patch works around this age-old issue by ignoring the x and y co-ordinates for ConfigureNotify requests relating to Steam windows.

https://github.com/bakkeby/patches/wiki/steam

#+BEGIN_SRC c :tangle patches.def.h
#define STEAM_PATCH 1
#+END_SRC

*** Sticky

Adds toggleable keyboard shortcut to make a client 'sticky', i.e. visible on all tags.

https://dwm.suckless.org/patches/sticky/

#+BEGIN_SRC c :tangle patches.def.h
#define STICKY_PATCH 0
#+END_SRC

*** Swallow

This patch adds "window swallowing" to dwm as known from Plan 9's windowing system rio.

Clients marked with isterminal in config.h swallow a window opened by any child process, e.g. running xclock in a terminal. Closing the xclock window restores the terminal window in the current position.

This patch depends on the following additional libraries:
   - libxcb
   - Xlib-libxcb
   - xcb-res

You need to uncomment the corresponding line in config.mk to use the above libraries when including this patch.

https://dwm.suckless.org/patches/swallow/

#+BEGIN_SRC c :tangle patches.def.h
#define SWALLOW_PATCH 1
#+END_SRC

*** Swap Focus

This patch depends on the pertag patch and makes it possible to switch focus with a single shortcut (MOD+s) instead of having to think if you should use mod-j or mod-k for reaching the previously used window.

https://dwm.suckless.org/patches/swapfocus/

#+BEGIN_SRC c :tangle patches.def.h
#define SWAPFOCUS_PATCH 1
#+END_SRC

*** Swap Tags

This patch allows swapping the contents of the currently selected tag with another tag using keyboard shortcuts.

https://dwm.suckless.org/patches/swaptags/

#+BEGIN_SRC c :tangle patches.def.h
#define SWAPTAGS_PATCH 0
#+END_SRC

*** Switch Column Focus

Switch focus between the master and stack columns using a single keybinding.

https://dwm.suckless.org/patches/switchcol/

#+BEGIN_SRC c :tangle patches.def.h
#define SWITCHCOL_PATCH 0
#+END_SRC

***  Switch Tag

By default dwm allow you to set application specific rules so that you can have your browser, for example, start up on tag 9 optionally on a given monitor when you open your browser it is then automatically moved to the configured tag, but you have to manually enable the tag to see the newly opened application.

This patch adds an extra configuration option for individual rules where:
  0 is default behaviour
  1 automatically moves you to the tag of the newly opened application and
  2 enables the tag of the newly opened application in addition to your existing enabled tags
  3 as 1, but closing that window reverts the view back to what it was previously (*)
  4 as 2, but closing that window reverts the view back to what it was previously (*)

(*) except if the client has been moved between tags or to another monitor

https://github.com/bakkeby/patches/blob/master/dwm/dwm-switchtag-6.2.diff

Also see https://dwm.suckless.org/patches/switchtotag

#+BEGIN_SRC c :tangle patches.def.h
#define SWITCHTAG_PATCH 0
#+END_SRC

*** Tab
This patch transforms the monocle layout into a "tabbed" layout if more than one window is present on the monocle view. This patch has been added for demonstration purposes only and has limited compatibility with other patches. It will conflict space-wise with a second bar.

Note that fancybar, awesomebar, bartabgroups and similar patches make the tab patch redundant.

https://dwm.suckless.org/patches/tab/

#+BEGIN_SRC c :tangle patches.def.h
#define TAB_PATCH 0
#+END_SRC

*** Tag All

Adds keyboard shortcuts to move all (or only floating) windows from one tag to another.

https://dwm.suckless.org/patches/tagall/

#+BEGIN_SRC c :tangle patches.def.h
#define TAGALL_PATCH 0
#+END_SRC

*** Tag All Monitor

This patch allows you to move all visible windows on a monitor to an adjacent monitor.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-tagallmon-6.2.diff

#+BEGIN_SRC c :tangle patches.def.h
#define TAGALLMON_PATCH 0
#+END_SRC

*** Tag Into Stack

**** All Master

This patch makes new clients attach into the stack area when you toggle a new tag into view. This means your master area will remain unchanged when toggling views.

The allmaster patch will cause all clients in the master area to be left alone. This patch takes precedence over the onemaster tagintostack patch.

https://dwm.suckless.org/patches/tagintostack/

#+BEGIN_SRC c :tangle patches.def.h
#define TAGINTOSTACK_ALLMASTER_PATCH 0
#+END_SRC

**** One Master

This patch makes new clients attach into the stack area when you toggle a new tag into view. This means your master area will remain unchanged when toggling views.

The onemaster patch will cause the first client in the master area to be left alone.

https://dwm.suckless.org/patches/tagintostack/

#+BEGIN_SRC c :tangle patches.def.h
#define TAGINTOSTACK_ONEMASTER_PATCH 0
#+END_SRC

*** Tag Monitor Fix Fullscreen

If you try to send a fullscreen window to an adjacent monitor using tagmon then the window is moved behind the scenes, but it remains in fullscreen on the original monitor until you exit fullscreen view (at which point it will appear on the adjacent monitor). This patch allows a fullscreen window to be moved to an adjacent monitor while remaining in fullscreen.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-tagmonfixfs-6.2.diff

#+BEGIN_SRC c :tangle patches.def.h
#define TAGMONFIXFS_PATCH 1
#+END_SRC

*** Tag Other Monitor

Add functions and keybindings to tag a window to a desired tag on the next (right) or previous (left) monitor from the currently selected monitor.

https://dwm.suckless.org/patches/tagothermonitor/

#+BEGIN_SRC c :tangle patches.def.h
#define TAGOTHERMONITOR_PATCH 1
#+END_SRC

*** Tag Swap Monitor

This patch allows you to swap all visible windows on one monitor with those of an adjacent monitor.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-tagswapmon-6.2.diff

#+BEGIN_SRC c :tangle patches.def.h
#define TAGSWAPMON_PATCH 1
#+END_SRC

*** Tap Resize

This patch can be useful to the touchpad users because it allows to resize windows using Mod + two-finger scroll. It is useful when two-finger scrolling is configured in libinput.

https://dwm.suckless.org/patches/tapresize/

#+BEGIN_SRC c :tangle patches.def.h
#define TAPRESIZE_PATCH 0
#+END_SRC

*** Toggle Fullscreen

This patch allows you to toggle fullscreen on and off using a single shortcut key.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-togglefullscreen-6.2.diff

#+BEGIN_SRC c :tangle patches.def.h
#define TOGGLEFULLSCREEN_PATCH 1
#+END_SRC

*** Toggle Top Bar

This patch allows for the bar position (top or bottom) to be toggled during runtime.

https://dwm.suckless.org/patches/toggletopbar/

#+BEGIN_SRC c :tangle patches.def.h
#define TOGGLETOPBAR_PATCH 0
#+END_SRC

*** Toggle Layout

Minor patch that lets you use the same keyboard shortcut to toggle to the previous layout if the designated layout is already active.

This allows you to use e.g. MOD+m to change to the monocle layout and use the same keybinding to toggle back to what it was previously. The default behaviour in dwm forces you to use either MOD+space or MOD+t to change back to tiled layout.

https://github.com/bakkeby/patches/wiki/togglelayout

#+BEGIN_SRC c :tangle patches.def.h
#define TOGGLELAYOUT_PATCH 0
#+END_SRC

*** Toggle Tag

Minor patch that lets you use the same keyboard shortcut to toggle to the previous tag if the designated tag is already active.

This allows you to use e.g. MOD+4 to quickly view the 4th tag and use the same keybinding to toggle back to what it was previously. The default behaviour in dwm forces you to use either MOD+tab or MOD+1 to change back to the previous tag.

Idea ref.
https://www.reddit.com/r/suckless/comments/ik27vd/key_toggle_between_next_and_previous_tag_dwm/
https://github.com/bakkeby/patches/wiki/toggletag

#+BEGIN_SRC c :tangle patches.def.h
#define TOGGLETAG_PATCH 0
#+END_SRC

*** Transfer

**** Main

Lets you transfer the currently focused client between the master and stack area while increasing or decreasing the master area (nmaster) accordingly.

https://dwm.suckless.org/patches/transfer/

#+BEGIN_SRC c :tangle patches.def.h
#define TRANSFER_PATCH 0
#+END_SRC

**** Transfer All

Lets you transfer all clients between the master and stack area while increasing or decreasing the master area (nmaster) accordingly.

https://dwm.suckless.org/patches/transfer/

#+BEGIN_SRC c :tangle patches.def.h
#define TRANSFER_ALL_PATCH 0
#+END_SRC

*** Unfloat Visible

This patch resets isfloating on any visible windows that have it set.

Optionally also applies a layout.

https://dwm.suckless.org/patches/unfloatvisible/

#+BEGIN_SRC c :tangle patches.def.h
#define UNFLOATVISIBLE_PATCH 1
#+END_SRC

*** Unmanaged

This patch adds a client rule that allows for windows that do not specify the override-redirect to not be managed by the window manager. This can be useful for external bars, widgets, launchers, docks, desktop icons and more.

https://github.com/bakkeby/patches/wiki/unmanaged

#+BEGIN_SRC c :tangle patches.def.h
#define UNMANAGED_PATCH 1
#+END_SRC

*** Vanity Gaps

**** Main

This patch adds configurable gaps between windows differentiating between outer, inner, horizontal and vertical gaps.

https://github.com/bakkeby/patches/blob/master/dwm/dwm-vanitygaps-6.2.diff

https://github.com/bakkeby/patches/blob/master/dwm/dwm-cfacts-vanitygaps-6.2.diff

#+BEGIN_SRC c :tangle patches.def.h
#define VANITYGAPS_PATCH 1
#+END_SRC

**** Monocle

This patch adds outer gaps for the monocle layout.

Most gaps patches tries to avoid gaps on the monocle layout, as it is often used as a fullscreen mode, hence this is enabled separately from the main vanitygaps patch.

#+BEGIN_SRC c :tangle patches.def.h
#define VANITYGAPS_MONOCLE_PATCH 0
#+END_SRC

*** View History

By default ~MOD+Tab~ will take the user back to the previous tag only. If the user keeps using ~MOD+Tab~ then the view will switch back and forth between the current and previous tag. This patch allows dwm to keep a longer history of previous tag changes such that ~MOD+Tab~ can be pressed multiple times to go further back to earlier tag selections.

The number of history elements is defined by the ~NUMVIEWHIST~ macro in dwm.c and defaults to the number of tags in the system.

#+BEGIN_SRC c :tangle patches.def.h
#define VIEW_HISTORY_PATCH 0
#+END_SRC

*** View On Tag

Follow a window to the tag it is being moved to.

https://dwm.suckless.org/patches/viewontag/

#+BEGIN_SRC c :tangle patches.def.h
#define VIEWONTAG_PATCH 0
#+END_SRC

*** Warp

This patch warps the mouse cursor to the center of the currently focused window or screen when the mouse cursor is (a) on a different screen or (b) on top of a different window.

https://dwm.suckless.org/patches/warp/

#+BEGIN_SRC c :tangle patches.def.h
#define WARP_PATCH 1
#+END_SRC

*** Window Role Rule

Sometimes a single application opens different windows depending on the task at hand and this is often reflected in the WM_WINDOW_ROLE(STRING) x property.

This patch adds the role field to the rule configuration so that one can differentiate between, say, Firefox "browser" vs "Preferences" vs "Manager" or Google-chrome "browser" vs "pop-up".

https://github.com/bakkeby/patches/blob/master/dwm/dwm-windowrolerule-6.2.diff

#+BEGIN_SRC c :tangle patches.def.h
#define WINDOWROLERULE_PATCH 0
#+END_SRC

*** Window View

The winview patch allows switching the view to that of a given client from the all-window view (Mod-0) using a keyboard shortcut.

http://dwm.suckless.org/patches/winview/

#+BEGIN_SRC c :tangle patches.def.h
#define WINVIEW_PATCH 0
#+END_SRC

*** X Keyboard

Remember keyboard layout per client.

It is recommended that you configure xkb before using this patch as described in https://www.x.org/archive/X11R7.5/doc/input/XKB-Config.html

https://dwm.suckless.org/patches/xkb/

#+BEGIN_SRC c :tangle patches.def.h
#define XKB_PATCH 0
#+END_SRC

*** XRDB

Allows dwm to read colors from xrdb (.Xresources) during runtime. Compatible with the float border color, awesomebar, urgentborder and titlecolor patches.

https://dwm.suckless.org/patches/xrdb/

#+BEGIN_SRC c :tangle patches.def.h
#define XRDB_PATCH 1
#+END_SRC

*** Zoom Floating

Simple patch that allows floating windows to be zoomed into the master stack position.

https://www.reddit.com/r/suckless/comments/ie5fe3/zoomfloating_my_own_simple_original_patch/

#+BEGIN_SRC c :tangle patches.def.h
#define ZOOMFLOATING_PATCH 0
#+END_SRC

*** Zoom Swap

The zoomswap patch allows a master and a stack window to swap places rather than every window on the screen changing position.

https://dwm.suckless.org/patches/zoomswap/

#+BEGIN_SRC c :tangle patches.def.h
#define ZOOMSWAP_PATCH 0
#+END_SRC

** Layouts

*** Bottomstack

**** Main

Bottomstack layout.

https://dwm.suckless.org/patches/bottomstack/

#+BEGIN_SRC c :tangle patches.def.h
#define BSTACK_LAYOUT 0
#+END_SRC

**** Horizontal

Bottomstack horizontal layout.

https://dwm.suckless.org/patches/bottomstack/

#+BEGIN_SRC c :tangle patches.def.h
#define BSTACKHORIZ_LAYOUT 0
#+END_SRC

*** Centered Master

**** Main

Centered master layout.

https://dwm.suckless.org/patches/centeredmaster/

#+BEGIN_SRC c :tangle patches.def.h
#define CENTEREDMASTER_LAYOUT 0
#+END_SRC

**** Floating

Centered floating master layout.

https://dwm.suckless.org/patches/centeredmaster/

#+BEGIN_SRC c :tangle patches.def.h
#define CENTEREDFLOATINGMASTER_LAYOUT 0
#+END_SRC

*** Columns

Same as the default tile layout except clients in the master area are arranged in columns (i.e. left to right).

https://dwm.suckless.org/patches/columns/

#+BEGIN_SRC c :tangle patches.def.h
#define COLUMNS_LAYOUT 0
#+END_SRC

*** Deck

Deck layout.

https://dwm.suckless.org/patches/deck/

#+BEGIN_SRC c :tangle patches.def.h
#define DECK_LAYOUT 1
#+END_SRC

*** Fibonacci

**** Dwindle

Fibonacci dwindle layout.

https://dwm.suckless.org/patches/fibonacci/

#+BEGIN_SRC c :tangle patches.def.h
#define FIBONACCI_DWINDLE_LAYOUT 0
#+END_SRC

**** Spiral

Fibonacci spiral layout.

https://dwm.suckless.org/patches/fibonacci/

#+BEGIN_SRC c :tangle patches.def.h
#define FIBONACCI_SPIRAL_LAYOUT 0
#+END_SRC

*** Flextile

Flextile deluxe layout.

A revamped, more flexible, and over-the-top version of the original flextile layout.

https://dwm.suckless.org/patches/flextile/ (original)

#+BEGIN_SRC c :tangle patches.def.h
#define FLEXTILE_DELUXE_LAYOUT 0
#+END_SRC

*** Grid

**** Main

Gridmode (grid) layout.

https://dwm.suckless.org/patches/gridmode/

#+BEGIN_SRC c :tangle patches.def.h
#define GRIDMODE_LAYOUT 1
#+END_SRC

**** Gapless

Gappless grid layout.

https://dwm.suckless.org/patches/gaplessgrid/

#+BEGIN_SRC c :tangle patches.def.h
#define GAPPLESSGRID_LAYOUT 0
#+END_SRC

**** Horizontal

Horizontal grid (horizgrid) layout.

https://dwm.suckless.org/patches/horizgrid/

#+BEGIN_SRC c :tangle patches.def.h
#define HORIZGRID_LAYOUT 0
#+END_SRC

**** N Row

Grid layout where nmaster controls the number of rows.

https://dwm.suckless.org/patches/nrowgrid/

#+BEGIN_SRC c :tangle patches.def.h
#define NROWGRID_LAYOUT 0
#+END_SRC

*** Tile

The default tile layout.

This can be optionally disabled in favour of other layouts.

#+BEGIN_SRC c :tangle patches.def.h
#define TILE_LAYOUT 1
#+END_SRC

*** Monocle

Monocle layout (default).

This can be optionally disabled in favour of other layouts.

#+BEGIN_SRC c :tangle patches.def.h
#define MONOCLE_LAYOUT 1
#+END_SRC

* Build System Settings

** Make Config

#+BEGIN_SRC makefile :tangle config.mk
# dwm version
VERSION = 6.5

# Customize below to fit your system

# paths
PREFIX = /usr/local
MANPREFIX = ${PREFIX}/share/man

X11INC = /usr/X11R6/include
X11LIB = /usr/X11R6/lib

# FreeBSD (uncomment)
#X11INC = /usr/local/include
#X11LIB = /usr/local/lib

# Xinerama, comment if you don't want it
XINERAMALIBS  = -lXinerama
XINERAMAFLAGS = -DXINERAMA

# freetype
FREETYPELIBS = -lfontconfig -lXft
FREETYPEINC = /usr/include/freetype2
# FreeBSD (uncomment)
#FREETYPEINC = /usr/local/include/freetype2
# OpenBSD (uncomment)
#FREETYPEINC = ${X11INC}/freetype2
# OpenBSD - Uncomment this for the swallow patch / SWALLOW_PATCH
#KVMLIB = -lkvm

# Uncomment this for the alpha patch and the winicon patch (BAR_ALPHA_PATCH, BAR_WINICON_PATCH)
#XRENDER = -lXrender

# Uncomment this for the mdpcontrol patch / MDPCONTROL_PATCH
#MPDCLIENT = -lmpdclient

# Uncomment for the pango patch / BAR_PANGO_PATCH
#PANGOINC = `pkg-config --cflags xft pango pangoxft`
#PANGOLIB = `pkg-config --libs xft pango pangoxft`

# Uncomment for the ipc patch / IPC_PATCH
YAJLLIBS = -lyajl
YAJLINC = -I/usr/include/yajl

# Uncomment this for the rounded corners patch / ROUNDED_CORNERS_PATCH
#XEXTLIB = -lXext

# Uncomment this for the swallow patch / SWALLOW_PATCH
XCBLIBS = -lX11-xcb -lxcb -lxcb-res

# This is needed for the winicon and tagpreview patches / BAR_WINICON_PATCH / BAR_TAGPREVIEW_PATCH
#IMLIB2LIBS = -lImlib2

# Uncomment for the bidi patch
#BDINC = `pkg-config --cflags fribidi`
#BDLIBS = `pkg-config --libs fribidi`

# includes and libs
INCS = -I${X11INC} -I${FREETYPEINC} ${YAJLINC} ${PANGOINC} ${BDINC}
LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}  ${XRENDER} ${MPDCLIENT} ${XEXTLIB} ${XCBLIBS} ${KVMLIB} ${PANGOLIB} ${YAJLLIBS} ${IMLIB2LIBS} $(BDLIBS)
# flags
CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
#CFLAGS   = -g -std=c99 -pedantic -Wall -O0 ${INCS} ${CPPFLAGS}
CFLAGS   = -std=c99 -pedantic -Wall -Wno-unused-function -Wno-deprecated-declarations -Os ${INCS} ${CPPFLAGS}
LDFLAGS  = ${LIBS}

# Solaris
#CFLAGS = -fast ${INCS} -DVERSION=\"${VERSION}\"
#LDFLAGS = ${LIBS}

# compiler and linker
CC = cc
#+END_SRC

** Makefile

#+BEGIN_SRC makefile :tangle Makefile
# dwm - dynamic window manager
# See LICENSE file for copyright and license details.

include config.mk

SRC = drw.c dwm.c util.c
OBJ = ${SRC:.c=.o}

# FreeBSD users, prefix all ifdef, else and endif statements with a . for this to work (e.g. .ifdef)

ifdef YAJLLIBS
all: dwm dwm-msg
else
all: dwm
endif

.c.o:
	${CC} -c ${CFLAGS} $<

${OBJ}: config.h config.mk patches.h

config.h:
	cp config.def.h $@

patches.h:
	cp patches.def.h $@

dwm: ${OBJ}
	${CC} -o $@ ${OBJ} ${LDFLAGS}

ifdef YAJLLIBS
dwm-msg:
	${CC} -o $@ patch/ipc/dwm-msg.c ${LDFLAGS}
endif

clean:
	rm -f dwm ${OBJ} dwm-${VERSION}.tar.gz
	rm -f dwm-msg
	rm -f config.h
	rm -f patches.h

dist: clean
	mkdir -p dwm-${VERSION}
	cp -R LICENSE Makefile README config.def.h config.mk\
		dwm.1 drw.h util.h ${SRC} dwm.png transient.c dwm-${VERSION}
	tar -cf dwm-${VERSION}.tar dwm-${VERSION}
	gzip dwm-${VERSION}.tar
	rm -rf dwm-${VERSION}

install: all
	mkdir -p ${DESTDIR}${PREFIX}/bin
	cp -f dwm ${DESTDIR}${PREFIX}/bin
ifdef YAJLLIBS
	cp -f dwm-msg ${DESTDIR}${PREFIX}/bin
endif
	cp -f patch/dwmc ${DESTDIR}${PREFIX}/bin
	chmod 755 ${DESTDIR}${PREFIX}/bin/dwm
ifdef YAJLLIBS
	chmod 755 ${DESTDIR}${PREFIX}/bin/dwm-msg
endif
	mkdir -p ${DESTDIR}${MANPREFIX}/man1
	sed "s/VERSION/${VERSION}/g" < dwm.1 > ${DESTDIR}${MANPREFIX}/man1/dwm.1
	chmod 644 ${DESTDIR}${MANPREFIX}/man1/dwm.1
	mkdir -p ${DESTDIR}${PREFIX}/share/xsessions
	test -f ${DESTDIR}${PREFIX}/share/xsessions/dwm.desktop || cp -n dwm.desktop ${DESTDIR}${PREFIX}/share/xsessions
	chmod 644 ${DESTDIR}${PREFIX}/share/xsessions/dwm.desktop

uninstall:
	rm -f ${DESTDIR}${PREFIX}/bin/dwm\
		${DESTDIR}${MANPREFIX}/man1/dwm.1\
		${DESTDIR}${PREFIX}/share/xsessions/dwm.desktop

.PHONY: all clean dist install uninstall
#+END_SRC

* DWM Configuration

** Appearance

#+BEGIN_SRC c :tangle config.def.h
#if ROUNDED_CORNERS_PATCH
static const unsigned int borderpx       = 0;   /* border pixel of windows */
static const int corner_radius           = 10;
#else
static const unsigned int borderpx       = 2;   /* border pixel of windows */
#endif // ROUNDED_CORNERS_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_BORDER_PATCH
/* This allows the bar border size to be explicitly set separately from borderpx.
 * If left as 0 then it will default to the borderpx value of the monitor and will
 * automatically update with setborderpx. */
static const unsigned int barborderpx    = 0;  /* border pixel of bar */
#endif // BAR_BORDER_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
static const unsigned int snap           = 10;  /* snap pixel */
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if SWALLOW_PATCH
static const int swallowfloating         = 0;   /* 1 means swallow floating windows by default */
#endif // SWALLOW_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_TAGPREVIEW_PATCH
static const int scalepreview            = 4;        /* Tag preview scaling */
#endif // BAR_TAGPREVIEW_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if NO_MOD_BUTTONS_PATCH
static int nomodbuttons                  = 1;   /* allow client mouse button bindings that have no modifier */
#endif // NO_MOD_BUTTONS_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if VANITYGAPS_PATCH
static const unsigned int gappih         = 20;  /* horiz inner gap between windows */
static const unsigned int gappiv         = 20;  /* vert inner gap between windows */
static const unsigned int gappoh         = 30;  /* horiz outer gap between windows and screen edge */
static const unsigned int gappov         = 30;  /* vert outer gap between windows and screen edge */
static const int smartgaps_fact          = 1;   /* gap factor when there is only one client; 0 = no gaps, 3 = 3x outer gaps */
#endif // VANITYGAPS_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if AUTOSTART_PATCH
static const char autostartblocksh[]     = "autostart_blocking.sh";
static const char autostartsh[]          = "autostart.sh";
static const char dwmdir[]               = "dwm";
static const char localshare[]           = ".local/share";
#endif // AUTOSTART_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_ANYBAR_PATCH
static const int usealtbar               = 1;        /* 1 means use non-dwm status bar */
static const char *altbarclass           = "Polybar"; /* Alternate bar class name */
static const char *altbarcmd             = "/home/sravan/.config/dwm-flexipatch/polybar/launch.sh"; /* Alternate bar launch command */
#endif // BAR_ANYBAR_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_HOLDBAR_PATCH
static const int showbar                 = 0;   /* 0 means no bar */
#else
static const int showbar                 = 1;   /* 0 means no bar */
#endif // BAR_HOLDBAR_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
static const int topbar                  = 1;   /* 0 means bottom bar */
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if TAB_PATCH
/*  Display modes of the tab bar: never shown, always shown, shown only in  */
/*  monocle mode in the presence of several windows.                        */
/*  Modes after showtab_nmodes are disabled.                                */
enum showtab_modes { showtab_never, showtab_auto, showtab_nmodes, showtab_always};
static const int showtab                 = showtab_auto;        /* Default tab bar show mode */
static const int toptab                  = False;               /* False means bottom tab bar */
#endif // TAB_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_HEIGHT_PATCH
static const int bar_height              = 0;   /* 0 means derive from font, >= 1 explicit height */
#endif // BAR_HEIGHT_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_PADDING_PATCH
static const int vertpad                 = 10;  /* vertical padding of bar */
static const int sidepad                 = 10;  /* horizontal padding of bar */
#endif // BAR_PADDING_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_WINICON_PATCH
#define ICONSIZE 20    /* icon size */
#define ICONSPACING 5  /* space between icon and title */
#endif // BAR_WINICON_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if FOCUSONCLICK_PATCH
static const int focusonwheel            = 0;
#endif // FOCUSONCLICK_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if FLOATPOS_PATCH
static int floatposgrid_x                = 5;  /* float grid columns */
static int floatposgrid_y                = 5;  /* float grid rows */
#endif // FLOATPOS_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if RIODRAW_PATCH
static const char slopspawnstyle[]       = "-t 0 -c 0.92,0.85,0.69,0.3 -o"; /* do NOT define -f (format) here */
static const char slopresizestyle[]      = "-t 0 -c 0.92,0.85,0.69,0.3"; /* do NOT define -f (format) here */
static const int riodraw_borders         = 0;  /* 0 or 1, indicates whether the area drawn using slop includes the window borders */
#if SWALLOW_PATCH
static const int riodraw_matchpid        = 1;  /* 0 or 1, indicates whether to match the PID of the client that was spawned with riospawn */
#endif // SWALLOW_PATCH
#endif // RIODRAW_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
/* Status is to be shown on: -1 (all monitors), 0 (a specific monitor by index), 'A' (active monitor) */
#if BAR_STATUSALLMONS_PATCH
static const int statusmon               = -1;
#elif BAR_STATICSTATUS_PATCH
static const int statusmon               = 0;
#else
static const int statusmon               = 'A';
#endif // BAR_STATUSALLMONS_PATCH | BAR_STATICSTATUS_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_STATUSPADDING_PATCH
static const int horizpadbar             = 2;   /* horizontal padding for statusbar */
static const int vertpadbar              = 0;   /* vertical padding for statusbar */
#endif // BAR_STATUSPADDING_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_STATUSBUTTON_PATCH
static const char buttonbar[]            = "<O>";
#endif // BAR_STATUSBUTTON_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_SYSTRAY_PATCH
static const unsigned int systrayspacing = 2;   /* systray spacing */
static const int showsystray             = 1;   /* 0 means no systray */
#endif // BAR_SYSTRAY_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_TAGLABELS_PATCH
static const char ptagf[] = "[%s %s]";          /* format of a tag label */
static const char etagf[] = "[%s]";             /* format of an empty tag */
static const int lcaselbl = 0;                  /* 1 means make tag label lowercase */
#endif // BAR_TAGLABELS_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_UNDERLINETAGS_PATCH
static const unsigned int ulinepad = 5;         /* horizontal padding between the underline and tag */
static const unsigned int ulinestroke  = 2;     /* thickness / height of the underline */
static const unsigned int ulinevoffset = 0;     /* how far above the bottom of the bar the line should appear */
static const int ulineall = 0;                  /* 1 to show underline on all tags, 0 for just the active ones */
#endif // BAR_UNDERLINETAGS_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if NAMETAG_PATCH
#if NAMETAG_PREPEND_PATCH
/* The format in which the tag is written when named. E.g. %d: %.12s will write the tag number
 * followed the first 12 characters of the given string. You can also just use "%d: %s" here. */
#define NAMETAG_FORMAT "%d: %.12s"
#else
#define NAMETAG_FORMAT "%s"
#endif // NAMETAG_PREPEND_PATCH
/* The maximum amount of bytes reserved for each tag text. */
#define MAX_TAGLEN 16
/* The command to run (via popen). This can be tailored by adding a prompt, passing other command
 * line arguments or providing name options. Optionally you can use other dmenu like alternatives
 * like rofi -dmenu. */
#define NAMETAG_COMMAND "dmenu < /dev/null"
#endif // NAMETAG_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if ALT_TAB_PATCH
/* alt-tab configuration */
static const unsigned int tabmodkey        = 0x40; /* (Alt) when this key is held down the alt-tab functionality stays active. Must be the same modifier as used to run alttabstart */
static const unsigned int tabcyclekey      = 0x17; /* (Tab) when this key is hit the menu moves one position forward in client stack. Must be the same key as used to run alttabstart */
static const unsigned int tabposy          = 1;    /* tab position on Y axis, 0 = top, 1 = center, 2 = bottom */
static const unsigned int tabposx          = 1;    /* tab position on X axis, 0 = left, 1 = center, 2 = right */
static const unsigned int maxwtab          = 600;  /* tab menu width */
static const unsigned int maxhtab          = 200;  /* tab menu height */
#endif // ALT_TAB_PATCH
#+END_SRC

** Indicators

See patch/bar_indicators.h for options

#+BEGIN_SRC c :tangle config.def.h
static int tagindicatortype              = INDICATOR_TOP_LEFT_SQUARE;
static int tiledindicatortype            = INDICATOR_NONE;
static int floatindicatortype            = INDICATOR_TOP_LEFT_SQUARE;
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if FAKEFULLSCREEN_CLIENT_PATCH && !FAKEFULLSCREEN_PATCH
static int fakefsindicatortype           = INDICATOR_PLUS;
static int floatfakefsindicatortype      = INDICATOR_PLUS_AND_LARGER_SQUARE;
#endif // FAKEFULLSCREEN_CLIENT_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if ONLYQUITONEMPTY_PATCH
static const int quit_empty_window_count = 0;   /* only allow dwm to quit if no (<= count) windows are open */
#endif // ONLYQUITONEMPTY_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_EXTRASTATUS_PATCH
static const char statussep              = ';'; /* separator between status bars */
#endif // BAR_EXTRASTATUS_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_TABGROUPS_PATCH
#if MONOCLE_LAYOUT
static void (*bartabmonfns[])(Monitor *) = { monocle /* , customlayoutfn */ };
#else
static void (*bartabmonfns[])(Monitor *) = { NULL /* , customlayoutfn */ };
#endif // MONOCLE_LAYOUT
#endif // BAR_TABGROUPS_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_PANGO_PATCH
static const char font[]                 = "monospace 10";
#else
static const char *fonts[]               = { "monospace:size=10" };
#endif // BAR_PANGO_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
static const char dmenufont[]            = "monospace:size=10";
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
static char c000000[]                    = "#000000"; // placeholder value
#+END_SRC

** Colors

*** Define Colors

#+BEGIN_SRC c :tangle config.def.h
static char normfgcolor[]                = "#F8F8F2";
static char normbgcolor[]                = "#282A36";
static char normbordercolor[]            = "#4D4D4D";
static char normfloatcolor[]             = "#6272A4";

static char selfgcolor[]                 = "#282A36";
static char selbgcolor[]                 = "#BD93F9";
static char selbordercolor[]             = "#BD93F9";
static char selfloatcolor[]              = "#FF79C6";

static char titlenormfgcolor[]           = "#bbbbbb";
static char titlenormbgcolor[]           = "#222222";
static char titlenormbordercolor[]       = "#444444";
static char titlenormfloatcolor[]        = "#db8fd9";

static char titleselfgcolor[]            = "#eeeeee";
static char titleselbgcolor[]            = "#005577";
static char titleselbordercolor[]        = "#005577";
static char titleselfloatcolor[]         = "#005577";

static char tagsnormfgcolor[]            = "#bbbbbb";
static char tagsnormbgcolor[]            = "#222222";
static char tagsnormbordercolor[]        = "#444444";
static char tagsnormfloatcolor[]         = "#db8fd9";

static char tagsselfgcolor[]             = "#eeeeee";
static char tagsselbgcolor[]             = "#005577";
static char tagsselbordercolor[]         = "#005577";
static char tagsselfloatcolor[]          = "#005577";

static char hidnormfgcolor[]             = "#005577";
static char hidselfgcolor[]              = "#227799";
static char hidnormbgcolor[]             = "#222222";
static char hidselbgcolor[]              = "#222222";

static char urgfgcolor[]                 = "#F8F8F2";
static char urgbgcolor[]                 = "#282A36";
static char urgbordercolor[]             = "#FF5555";
static char urgfloatcolor[]              = "#FF5555";
#+END_SRC

*** Renamed Scratchpads

#+BEGIN_SRC c :tangle config.def.h
#if RENAMED_SCRATCHPADS_PATCH
static char scratchselfgcolor[]          = "#FFF7D4";
static char scratchselbgcolor[]          = "#77547E";
static char scratchselbordercolor[]      = "#894B9F";
static char scratchselfloatcolor[]       = "#894B9F";

static char scratchnormfgcolor[]         = "#FFF7D4";
static char scratchnormbgcolor[]         = "#664C67";
static char scratchnormbordercolor[]     = "#77547E";
static char scratchnormfloatcolor[]      = "#77547E";
#endif // RENAMED_SCRATCHPADS_PATCH
#+END_SRC

*** Bar Flex Win Title

#+BEGIN_SRC c :tangle config.def.h
#if BAR_FLEXWINTITLE_PATCH
static char normTTBbgcolor[]             = "#330000";
static char normLTRbgcolor[]             = "#330033";
static char normMONObgcolor[]            = "#000033";
static char normGRIDbgcolor[]            = "#003300";
static char normGRD1bgcolor[]            = "#003300";
static char normGRD2bgcolor[]            = "#003300";
static char normGRDMbgcolor[]            = "#506600";
static char normHGRDbgcolor[]            = "#b96600";
static char normDWDLbgcolor[]            = "#003333";
static char normSPRLbgcolor[]            = "#333300";
static char normfloatbgcolor[]           = "#115577";
static char actTTBbgcolor[]              = "#440000";
static char actLTRbgcolor[]              = "#440044";
static char actMONObgcolor[]             = "#000044";
static char actGRIDbgcolor[]             = "#004400";
static char actGRD1bgcolor[]             = "#004400";
static char actGRD2bgcolor[]             = "#004400";
static char actGRDMbgcolor[]             = "#507711";
static char actHGRDbgcolor[]             = "#b97711";
static char actDWDLbgcolor[]             = "#004444";
static char actSPRLbgcolor[]             = "#444400";
static char actfloatbgcolor[]            = "#116688";
static char selTTBbgcolor[]              = "#550000";
static char selLTRbgcolor[]              = "#550055";
static char selMONObgcolor[]             = "#212171";
static char selGRIDbgcolor[]             = "#005500";
static char selGRD1bgcolor[]             = "#005500";
static char selGRD2bgcolor[]             = "#005500";
static char selGRDMbgcolor[]             = "#508822";
static char selHGRDbgcolor[]             = "#b98822";
static char selDWDLbgcolor[]             = "#005555";
static char selSPRLbgcolor[]             = "#555500";
static char selfloatbgcolor[]            = "#117799";
#endif // BAR_FLEXWINTITLE_PATCH
#+END_SRC

*** Bar Alpha

#+BEGIN_SRC c :tangle config.def.h
#if BAR_ALPHA_PATCH
static const unsigned int baralpha = 0xd0;
static const unsigned int borderalpha = OPAQUE;
static const unsigned int alphas[][3] = {
        /*                       fg      bg        border     */
        [SchemeNorm]         = { OPAQUE, baralpha, borderalpha },
        [SchemeSel]          = { OPAQUE, baralpha, borderalpha },
        [SchemeTitleNorm]    = { OPAQUE, baralpha, borderalpha },
        [SchemeTitleSel]     = { OPAQUE, baralpha, borderalpha },
        [SchemeTagsNorm]     = { OPAQUE, baralpha, borderalpha },
        [SchemeTagsSel]      = { OPAQUE, baralpha, borderalpha },
        [SchemeHidNorm]      = { OPAQUE, baralpha, borderalpha },
        [SchemeHidSel]       = { OPAQUE, baralpha, borderalpha },
        [SchemeUrg]          = { OPAQUE, baralpha, borderalpha },
        #if RENAMED_SCRATCHPADS_PATCH
        [SchemeScratchSel]   = { OPAQUE, baralpha, borderalpha },
        [SchemeScratchNorm]  = { OPAQUE, baralpha, borderalpha },
        #endif // RENAMED_SCRATCHPADS_PATCH
        #if BAR_FLEXWINTITLE_PATCH
        [SchemeFlexActTTB]   = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexActLTR]   = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexActMONO]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexActGRID]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexActGRD1]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexActGRD2]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexActGRDM]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexActHGRD]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexActDWDL]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexActSPRL]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexActFloat] = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexInaTTB]   = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexInaLTR]   = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexInaMONO]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexInaGRID]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexInaGRD1]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexInaGRD2]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexInaGRDM]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexInaHGRD]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexInaDWDL]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexInaSPRL]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexInaFloat] = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexSelTTB]   = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexSelLTR]   = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexSelMONO]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexSelGRID]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexSelGRD1]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexSelGRD2]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexSelGRDM]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexSelHGRD]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexSelDWDL]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexSelSPRL]  = { OPAQUE, baralpha, borderalpha },
        [SchemeFlexSelFloat] = { OPAQUE, baralpha, borderalpha },
        #endif // BAR_FLEXWINTITLE_PATCH
};
#endif // BAR_ALPHA_PATCH
#+END_SRC

*** VT Colors

#+BEGIN_SRC c :tangle config.def.h
#if BAR_VTCOLORS_PATCH
static const char title_bg_dark[]   = "#303030";
static const char title_bg_light[]  = "#fdfdfd";
static const int color_ptrs[][ColCount] = {
        /*                       fg      bg      border  float */
        [SchemeNorm]         = { -1,     -1,     5,      12 },
        [SchemeSel]          = { -1,     -1,     11,     13 },
        [SchemeTitleNorm]    = { 6,      -1,     -1,     -1 },
        [SchemeTitleSel]     = { 6,      -1,     -1,     -1 },
        [SchemeTagsNorm]     = { 2,      0,      0,      -1 },
        [SchemeTagsSel]      = { 6,      5,      5,      -1 },
        [SchemeHidNorm]      = { 5,      0,      0,      -1 },
        [SchemeHidSel]       = { 6,      -1,     -1,     -1 },
        [SchemeUrg]          = { 7,      9,      9,      15 },
};
#endif // BAR_VTCOLORS_PATCH
#+END_SRC

*** Set Colors

#+BEGIN_SRC c :tangle config.def.h
static char *colors[][ColCount] = {
        /*                       fg                bg                border                float */
        [SchemeNorm]         = { normfgcolor,      normbgcolor,      normbordercolor,      normfloatcolor },
        [SchemeSel]          = { selfgcolor,       selbgcolor,       selbordercolor,       selfloatcolor },
        [SchemeTitleNorm]    = { titlenormfgcolor, titlenormbgcolor, titlenormbordercolor, titlenormfloatcolor },
        [SchemeTitleSel]     = { titleselfgcolor,  titleselbgcolor,  titleselbordercolor,  titleselfloatcolor },
        [SchemeTagsNorm]     = { tagsnormfgcolor,  tagsnormbgcolor,  tagsnormbordercolor,  tagsnormfloatcolor },
        [SchemeTagsSel]      = { tagsselfgcolor,   tagsselbgcolor,   tagsselbordercolor,   tagsselfloatcolor },
        [SchemeHidNorm]      = { hidnormfgcolor,   hidnormbgcolor,   c000000,              c000000 },
        [SchemeHidSel]       = { hidselfgcolor,    hidselbgcolor,    c000000,              c000000 },
        [SchemeUrg]          = { urgfgcolor,       urgbgcolor,       urgbordercolor,       urgfloatcolor },
        #if RENAMED_SCRATCHPADS_PATCH
        [SchemeScratchSel]   = { scratchselfgcolor, scratchselbgcolor, scratchselbordercolor, scratchselfloatcolor },
        [SchemeScratchNorm]  = { scratchnormfgcolor, scratchnormbgcolor, scratchnormbordercolor, scratchnormfloatcolor },
        #endif // RENAMED_SCRATCHPADS_PATCH
        #if BAR_FLEXWINTITLE_PATCH
        [SchemeFlexActTTB]   = { titleselfgcolor,  actTTBbgcolor,    actTTBbgcolor,        c000000 },
        [SchemeFlexActLTR]   = { titleselfgcolor,  actLTRbgcolor,    actLTRbgcolor,        c000000 },
        [SchemeFlexActMONO]  = { titleselfgcolor,  actMONObgcolor,   actMONObgcolor,       c000000 },
        [SchemeFlexActGRID]  = { titleselfgcolor,  actGRIDbgcolor,   actGRIDbgcolor,       c000000 },
        [SchemeFlexActGRD1]  = { titleselfgcolor,  actGRD1bgcolor,   actGRD1bgcolor,       c000000 },
        [SchemeFlexActGRD2]  = { titleselfgcolor,  actGRD2bgcolor,   actGRD2bgcolor,       c000000 },
        [SchemeFlexActGRDM]  = { titleselfgcolor,  actGRDMbgcolor,   actGRDMbgcolor,       c000000 },
        [SchemeFlexActHGRD]  = { titleselfgcolor,  actHGRDbgcolor,   actHGRDbgcolor,       c000000 },
        [SchemeFlexActDWDL]  = { titleselfgcolor,  actDWDLbgcolor,   actDWDLbgcolor,       c000000 },
        [SchemeFlexActSPRL]  = { titleselfgcolor,  actSPRLbgcolor,   actSPRLbgcolor,       c000000 },
        [SchemeFlexActFloat] = { titleselfgcolor,  actfloatbgcolor,  actfloatbgcolor,      c000000 },
        [SchemeFlexInaTTB]   = { titlenormfgcolor, normTTBbgcolor,   normTTBbgcolor,       c000000 },
        [SchemeFlexInaLTR]   = { titlenormfgcolor, normLTRbgcolor,   normLTRbgcolor,       c000000 },
        [SchemeFlexInaMONO]  = { titlenormfgcolor, normMONObgcolor,  normMONObgcolor,      c000000 },
        [SchemeFlexInaGRID]  = { titlenormfgcolor, normGRIDbgcolor,  normGRIDbgcolor,      c000000 },
        [SchemeFlexInaGRD1]  = { titlenormfgcolor, normGRD1bgcolor,  normGRD1bgcolor,      c000000 },
        [SchemeFlexInaGRD2]  = { titlenormfgcolor, normGRD2bgcolor,  normGRD2bgcolor,      c000000 },
        [SchemeFlexInaGRDM]  = { titlenormfgcolor, normGRDMbgcolor,  normGRDMbgcolor,      c000000 },
        [SchemeFlexInaHGRD]  = { titlenormfgcolor, normHGRDbgcolor,  normHGRDbgcolor,      c000000 },
        [SchemeFlexInaDWDL]  = { titlenormfgcolor, normDWDLbgcolor,  normDWDLbgcolor,      c000000 },
        [SchemeFlexInaSPRL]  = { titlenormfgcolor, normSPRLbgcolor,  normSPRLbgcolor,      c000000 },
        [SchemeFlexInaFloat] = { titlenormfgcolor, normfloatbgcolor, normfloatbgcolor,     c000000 },
        [SchemeFlexSelTTB]   = { titleselfgcolor,  selTTBbgcolor,    selTTBbgcolor,        c000000 },
        [SchemeFlexSelLTR]   = { titleselfgcolor,  selLTRbgcolor,    selLTRbgcolor,        c000000 },
        [SchemeFlexSelMONO]  = { titleselfgcolor,  selMONObgcolor,   selMONObgcolor,       c000000 },
        [SchemeFlexSelGRID]  = { titleselfgcolor,  selGRIDbgcolor,   selGRIDbgcolor,       c000000 },
        [SchemeFlexSelGRD1]  = { titleselfgcolor,  selGRD1bgcolor,   selGRD1bgcolor,       c000000 },
        [SchemeFlexSelGRD2]  = { titleselfgcolor,  selGRD2bgcolor,   selGRD2bgcolor,       c000000 },
        [SchemeFlexSelGRDM]  = { titleselfgcolor,  selGRDMbgcolor,   selGRDMbgcolor,       c000000 },
        [SchemeFlexSelHGRD]  = { titleselfgcolor,  selHGRDbgcolor,   selHGRDbgcolor,       c000000 },
        [SchemeFlexSelDWDL]  = { titleselfgcolor,  selDWDLbgcolor,   selDWDLbgcolor,       c000000 },
        [SchemeFlexSelSPRL]  = { titleselfgcolor,  selSPRLbgcolor,   selSPRLbgcolor,       c000000 },
        [SchemeFlexSelFloat] = { titleselfgcolor,  selfloatbgcolor,  selfloatbgcolor,      c000000 },
        #endif // BAR_FLEXWINTITLE_PATCH
};
#+END_SRC

*** Powerline

#+BEGIN_SRC c :tangle config.def.h
#if BAR_POWERLINE_STATUS_PATCH
static char *statuscolors[][ColCount] = {
        /*                       fg                bg                border                float */
        [SchemeNorm]         = { normfgcolor,      normbgcolor,      normbordercolor,      normfloatcolor },
        [SchemeSel]          = { selfgcolor,       selbgcolor,       selbordercolor,       selfloatcolor },
        [SchemeTitleNorm]    = { titlenormfgcolor, titlenormbgcolor, titlenormbordercolor, titlenormfloatcolor },
        [SchemeTitleSel]     = { titleselfgcolor,  titleselbgcolor,  titleselbordercolor,  titleselfloatcolor },
        [SchemeTagsNorm]     = { tagsnormfgcolor,  tagsnormbgcolor,  tagsnormbordercolor,  tagsnormfloatcolor },
        [SchemeTagsSel]      = { tagsselfgcolor,   tagsselbgcolor,   tagsselbordercolor,   tagsselfloatcolor },
        [SchemeHidNorm]      = { hidnormfgcolor,   hidnormbgcolor,   c000000,              c000000 },
        [SchemeHidSel]       = { hidselfgcolor,    hidselbgcolor,    c000000,              c000000 },
        [SchemeUrg]          = { urgfgcolor,       urgbgcolor,       urgbordercolor,       urgfloatcolor },
};
#endif // BAR_POWERLINE_STATUS_PATCH
#+END_SRC

** Layout Menu

#+BEGIN_SRC c :tangle config.def.h
#if BAR_LAYOUTMENU_PATCH
static const char *layoutmenu_cmd = "layoutmenu.sh";
#endif
#+END_SRC

** Autostart

#+BEGIN_SRC c :tangle config.def.h
#if COOL_AUTOSTART_PATCH
static const char *const autostart[] = {
        "st", NULL,
        NULL /* terminate */
};
#endif // COOL_AUTOSTART_PATCH
#+END_SRC

** Scratchpads

#+BEGIN_SRC c :tangle config.def.h
#if RENAMED_SCRATCHPADS_PATCH
static const char *scratchpadcmd[] = {"s", "st", "-n", "spterm", NULL};
#elif SCRATCHPADS_PATCH
const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
static Sp scratchpads[] = {
   /* name          cmd  */
   {"spterm",      spcmd1},
};
#endif // SCRATCHPADS_PATCH
#+END_SRC

** Tags

In a traditional dwm the number of tags in use can be changed simply by changing the number of strings in the tags array. This build does things a bit different which has some added benefits. If you need to change the number of tags here then change the NUMTAGS macro in dwm.c.

Examples:

#+BEGIN_EXAMPLE
1) static char *tagicons[][NUMTAGS*2] = {
       [DEFAULT_TAGS] = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I" },
   }

2) static char *tagicons[][1] = {
       [DEFAULT_TAGS] = { "" },
   }
#+END_EXAMPLE

The first example would result in the tags on the first monitor to be 1 through 9, while the tags for the second monitor would be named A through I. A third monitor would start again at 1 through 9 while the tags on a fourth monitor would also be named A through I. Note the tags count of NUMTAGS*2 in the array initialiser which defines how many tag text / icon exists in the array. This can be changed to *3 to add separate icons for a third monitor.

For the second example each tag would be represented as a bullet point. Both cases work the same from a technical standpoint - the icon index is derived from the tag index and the monitor index. If the icon index is is greater than the number of tag icons then it will wrap around until it an icon matches. Similarly if there are two tag icons then it would alternate between them. This works seamlessly with alternative tags and alttagsdecoration patches.

#+BEGIN_SRC c :tangle config.def.h
#if NAMETAG_PATCH
static char tagicons[][NUMTAGS][MAX_TAGLEN] =
#else
static char *tagicons[][NUMTAGS] =
#endif // NAMETAG_PATCH
{
        /* [DEFAULT_TAGS]        = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }, */
        [DEFAULT_TAGS]        = { " ", " ", " ", " ", " ", " ", " ", " ", " " },
        [ALTERNATIVE_TAGS]    = { "A", "B", "C", "D", "E", "F", "G", "H", "I" },
        [ALT_TAGS_DECORATION] = { "<1>", "<2>", "<3>", "<4>", "<5>", "<6>", "<7>", "<8>", "<9>" },
};
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_TAGGRID_PATCH
/* grid of tags */
#define SWITCHTAG_UP                1 << 0
#define SWITCHTAG_DOWN              1 << 1
#define SWITCHTAG_LEFT              1 << 2
#define SWITCHTAG_RIGHT             1 << 3
#define SWITCHTAG_TOGGLETAG         1 << 4
#define SWITCHTAG_TAG               1 << 5
#define SWITCHTAG_VIEW              1 << 6
#define SWITCHTAG_TOGGLEVIEW        1 << 7

static const int tagrows = 2;
#endif // BAR_TAGGRID_PATCH
#+END_SRC

** Rules

*** Window Rules

There are two options when it comes to per-client rules:
  - a typical struct table or
  - using the RULE macro

A traditional struct table looks like this:

#+BEGIN_EXAMPLE
// class      instance  title  wintype  tags mask  isfloating  monitor
{ "Gimp",     NULL,     NULL,  NULL,    1 << 4,    0,          -1 },
{ "Firefox",  NULL,     NULL,  NULL,    1 << 7,    0,          -1 },
#+END_EXAMPLE

The RULE macro has the default values set for each field allowing you to only specify the values that are relevant for your rule, e.g.

#+BEGIN_EXAMPLE
RULE(.class = "Gimp", .tags = 1 << 4)
RULE(.class = "Firefox", .tags = 1 << 7)
#+END_EXAMPLE

Refer to the Rule struct definition for the list of available fields depending on the patches you enable.

#+BEGIN_EXAMPLE
xprop(1):
        WM_CLASS(STRING) = instance, class
        WM_NAME(STRING) = title
        WM_WINDOW_ROLE(STRING) = role
        _NET_WM_WINDOW_TYPE(ATOM) = wintype
#+END_EXAMPLE

#+BEGIN_SRC c :tangle config.def.h
static const Rule rules[] = {
        RULE(.wintype = WTYPE "DIALOG", .isfloating = 1)
        RULE(.wintype = WTYPE "UTILITY", .isfloating = 1)
        RULE(.wintype = WTYPE "TOOLBAR", .isfloating = 1)
        RULE(.wintype = WTYPE "SPLASH", .isfloating = 1)
        RULE(.wintype = WTYPE "NOTIFICATION", .unmanaged = 1) // 1 - the window will be placed above all other windows
        RULE(.title = "Picture in picture", .isfloating = 1)
        RULE(.class = "Beeper", .tags = 1 << 0)
        RULE(.class = "Signal", .tags = 1 << 0)
        RULE(.class = "discord", .tags = 1 << 0)
        RULE(.class = "zoom", .tags = 1 << 0)
        RULE(.class = "Logseq", .tags = 1 << 1)
        RULE(.class = "obsidian", .tags = 1 << 1)
        RULE(.class = "anytype", .tags = 1 << 1)
        RULE(.class = "pocket-casts-linux", .tags = 1 << 2)
        RULE(.class = "Spotify", .tags = 1 << 2)
        RULE(.class = "Pavucontrol", .tags = 1 << 2)
        RULE(.class = "easyeffects", .tags = 1 << 2)
        RULE(.class = "NoiseTorch", .tags = 1 << 2)
        RULE(.class = "Audacity", .tags = 1 << 2)
        RULE(.class = "mpv", .tags = 1 << 3)
        RULE(.class = "vlc", .tags = 1 << 3)
        RULE(.class = "Ristretto", .tags = 1 << 3)
        RULE(.class = "trackma-qt", .tags = 1 << 3)
        RULE(.class = "Trackma-gtk", .tags = 1 << 3)
        RULE(.class = "obs", .tags = 1 << 3)
        RULE(.class = "kdenlive", .tags = 1 << 3)
        RULE(.class = "Blender", .tags = 1 << 3)
        RULE(.class = "Vivaldi-stable", .tags = 1 << 4)
        RULE(.class = "kitty", .tags = 1 << 5, .isterminal = 1)
        RULE(.class = "Emacs", .tags = 1 << 6)
        RULE(.class = "Code", .tags = 1 << 6)
        RULE(.class = "GNU Octave", .tags = 1 << 6)
        RULE(.title = "Steam", .tags = 1 << 7)
        RULE(.class = "Lutris", .tags = 1 << 7)
        RULE(.class = "gamescope", .tags = 1 << 7)
        RULE(.class = "Oversteer", .tags = 1 << 7)
        RULE(.class = "PrismLauncher", .tags = 1 << 7)
        RULE(.class = "antimicrox", .tags = 1 << 7)
        RULE(.class = "ProtonUp-Qt", .tags = 1 << 7)
        RULE(.class = "Thunar", .tags = 1 << 8)
        RULE(.class = "Syncthing GTK", .tags = 1 << 8)
        RULE(.class = "Nyrna", .tags = 1 << 8)
        RULE(.class = "openrgb", .tags = 1 << 8)
        #if RENAMED_SCRATCHPADS_PATCH
        RULE(.instance = "spterm", .scratchkey = 's', .isfloating = 1)
        #elif SCRATCHPADS_PATCH
        RULE(.instance = "spterm", .tags = SPTAG(0), .isfloating = 1)
        #endif // SCRATCHPADS_PATCH
};
#+END_SRC

*** Monitor & Tag Rules

#+BEGIN_SRC c :tangle config.def.h
#if MONITOR_RULES_PATCH
#if PERTAG_PATCH
static const MonitorRule monrules[] = {
        /* monitor  tag   layout  mfact  nmaster  showbar  topbar */
        {  1,       -1,   2,      -1,    -1,      -1,      -1     }, // use a different layout for the second monitor
        {  -1,      -1,   0,      -1,    -1,      -1,      -1     }, // default
};
#else
static const MonitorRule monrules[] = {
        /* monitor  layout  mfact  nmaster  showbar  topbar */
        {  1,       2,      -1,    -1,      -1,      -1     }, // use a different layout for the second monitor
        {  -1,      0,      -1,    -1,      -1,      -1     }, // default
};
#endif // PERTAG_PATCH
#endif // MONITOR_RULES_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if INSETS_PATCH
static const Inset default_inset = {
        .x = 0,
        .y = 30,
        .w = 0,
        .h = 0,
};
#endif // INSETS_PATCH
#+END_SRC

*** Bar Rules

Bar rules allow you to configure what is shown where on the bar, as well as introducing your own bar modules.

monitor:
  -1  show on all monitors
   0  show on monitor 0
  'A' show on active monitor (i.e. focused / selected) (or just -1 for active?)

bar - bar index, 0 is default, 1 is extrabar

alignment - how the module is aligned compared to other modules

widthfunc, drawfunc, clickfunc - providing bar module width, draw and click functions

name - does nothing, intended for visual clue and for logging / debugging

#+BEGIN_SRC c :tangle config.def.h
static const BarRule barrules[] = {
        /* monitor   bar    alignment         widthfunc                 drawfunc                clickfunc                hoverfunc                name */
        { -2 },
        #if BAR_STATUSBUTTON_PATCH
        { -1,        0,     BAR_ALIGN_LEFT,   width_stbutton,           draw_stbutton,          click_stbutton,          NULL,                    "statusbutton" },
        #endif // BAR_STATUSBUTTON_PATCH
        #if BAR_POWERLINE_TAGS_PATCH
        {  0,        0,     BAR_ALIGN_LEFT,   width_pwrl_tags,          draw_pwrl_tags,         click_pwrl_tags,         hover_pwrl_tags,         "powerline_tags" },
        #endif // BAR_POWERLINE_TAGS_PATCH
        #if BAR_TAGS_PATCH
        { -1,        0,     BAR_ALIGN_LEFT,   width_tags,               draw_tags,              click_tags,              hover_tags,              "tags" },
        #endif // BAR_TAGS_PATCH
        #if BAR_TAGLABELS_PATCH
        { -1,        0,     BAR_ALIGN_LEFT,   width_taglabels,          draw_taglabels,         click_taglabels,         hover_taglabels,         "taglabels" },
        #endif // BAR_TAGLABELS_PATCH
        #if BAR_TAGGRID_PATCH
        { -1,        0,     BAR_ALIGN_LEFT,   width_taggrid,            draw_taggrid,           click_taggrid,           NULL,                    "taggrid" },
        #endif // BAR_TAGGRID_PATCH
        #if BAR_SYSTRAY_PATCH
        {  0,        0,     BAR_ALIGN_RIGHT,  width_systray,            draw_systray,           click_systray,           NULL,                    "systray" },
        #endif // BAR_SYSTRAY_PATCH
        #if BAR_LTSYMBOL_PATCH
        { -1,        0,     BAR_ALIGN_LEFT,   width_ltsymbol,           draw_ltsymbol,          click_ltsymbol,          NULL,                    "layout" },
        #endif // BAR_LTSYMBOL_PATCH
        #if BAR_STATUSCOLORS_PATCH && BAR_STATUSCMD_PATCH
        { statusmon, 0,     BAR_ALIGN_RIGHT,  width_statuscolors,       draw_statuscolors,      click_statuscmd,         NULL,                    "statuscolors" },
        #elif BAR_STATUSCOLORS_PATCH
        { statusmon, 0,     BAR_ALIGN_RIGHT,  width_statuscolors,       draw_statuscolors,      click_statuscolors,      NULL,                    "statuscolors" },
        #elif BAR_STATUS2D_PATCH && BAR_STATUSCMD_PATCH
        { statusmon, 0,     BAR_ALIGN_RIGHT,  width_status2d,           draw_status2d,          click_statuscmd,         NULL,                    "status2d" },
        #elif BAR_STATUS2D_PATCH
        { statusmon, 0,     BAR_ALIGN_RIGHT,  width_status2d,           draw_status2d,          click_status2d,          NULL,                    "status2d" },
        #elif BAR_POWERLINE_STATUS_PATCH
        { statusmon, 0,     BAR_ALIGN_RIGHT,  width_pwrl_status,        draw_pwrl_status,       click_pwrl_status,       NULL,                    "powerline_status" },
        #elif BAR_STATUS_PATCH && BAR_STATUSCMD_PATCH
        { statusmon, 0,     BAR_ALIGN_RIGHT,  width_status,             draw_status,            click_statuscmd,         NULL,                    "status" },
        #elif BAR_STATUS_PATCH
        { statusmon, 0,     BAR_ALIGN_RIGHT,  width_status,             draw_status,            click_status,            NULL,                    "status" },
        #endif // BAR_STATUS2D_PATCH | BAR_STATUSCMD_PATCH
        #if XKB_PATCH
        {  0,        0,     BAR_ALIGN_RIGHT,  width_xkb,                draw_xkb,               click_xkb,               NULL,                    "xkb" },
        #endif // XKB_PATCH
        #if BAR_FLEXWINTITLE_PATCH
        { -1,        0,     BAR_ALIGN_NONE,   width_flexwintitle,       draw_flexwintitle,      click_flexwintitle,      NULL,                    "flexwintitle" },
        #elif BAR_TABGROUPS_PATCH
        { -1,        0,     BAR_ALIGN_NONE,   width_bartabgroups,       draw_bartabgroups,      click_bartabgroups,      NULL,                    "bartabgroups" },
        #elif BAR_AWESOMEBAR_PATCH
        { -1,        0,     BAR_ALIGN_NONE,   width_awesomebar,         draw_awesomebar,        click_awesomebar,        NULL,                    "awesomebar" },
        #elif BAR_FANCYBAR_PATCH
        { -1,        0,     BAR_ALIGN_NONE,   width_fancybar,           draw_fancybar,          click_fancybar,          NULL,                    "fancybar" },
        #elif BAR_WINTITLE_PATCH
        { -1,        0,     BAR_ALIGN_NONE,   width_wintitle,           draw_wintitle,          click_wintitle,          NULL,                    "wintitle" },
        #endif // BAR_TABGROUPS_PATCH | BAR_AWESOMEBAR_PATCH | BAR_FANCYBAR_PATCH | BAR_WINTITLE_PATCH
        #if BAR_EXTRASTATUS_PATCH
        #if BAR_STATUSCOLORS_PATCH && BAR_STATUSCMD_PATCH
        { statusmon, 1,     BAR_ALIGN_CENTER, width_statuscolors_es,    draw_statuscolors_es,   click_statuscmd_es,      NULL,                    "statuscolors_es" },
        #elif BAR_STATUSCOLORS_PATCH
        { statusmon, 1,     BAR_ALIGN_CENTER, width_statuscolors_es,    draw_statuscolors_es,   click_statuscolors,      NULL,                    "statuscolors_es" },
        #elif BAR_STATUS2D_PATCH && BAR_STATUSCMD_PATCH
        { statusmon, 1,     BAR_ALIGN_CENTER, width_status2d_es,        draw_status2d_es,       click_statuscmd_es,      NULL,                    "status2d_es" },
        #elif BAR_STATUS2D_PATCH
        { statusmon, 1,     BAR_ALIGN_CENTER, width_status2d_es,        draw_status2d_es,       click_status2d,          NULL,                    "status2d_es" },
        #elif BAR_POWERLINE_STATUS_PATCH
        { statusmon, 1,     BAR_ALIGN_RIGHT,  width_pwrl_status_es,     draw_pwrl_status_es,    click_pwrl_status,       NULL,                    "powerline_status" },
        #elif BAR_STATUSCMD_PATCH && BAR_STATUS_PATCH
        { statusmon, 1,     BAR_ALIGN_CENTER, width_status_es,          draw_status_es,         click_statuscmd_es,      NULL,                    "status_es" },
        #elif BAR_STATUS_PATCH
        { statusmon, 1,     BAR_ALIGN_CENTER, width_status_es,          draw_status_es,         click_status,            NULL,                    "status_es" },
        #endif // BAR_STATUS2D_PATCH | BAR_STATUSCMD_PATCH
        #endif // BAR_EXTRASTATUS_PATCH
        #if BAR_FLEXWINTITLE_PATCH
        #if BAR_WINTITLE_HIDDEN_PATCH
        { -1,        1,  BAR_ALIGN_RIGHT_RIGHT, width_wintitle_hidden,  draw_wintitle_hidden,   click_wintitle_hidden,   NULL,                    "wintitle_hidden" },
        #endif
        #if BAR_WINTITLE_FLOATING_PATCH
        { -1,        1,     BAR_ALIGN_LEFT,   width_wintitle_floating,  draw_wintitle_floating, click_wintitle_floating, NULL,                    "wintitle_floating" },
        #endif // BAR_WINTITLE_FLOATING_PATCH
        #endif // BAR_FLEXWINTITLE_PATCH
};
#+END_SRC

** Layouts

#+BEGIN_SRC c :tangle config.def.h
static const float mfact     = 0.50; /* factor of master area size [0.05..0.95] */
static const int nmaster     = 1;    /* number of clients in master area */
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if FLEXTILE_DELUXE_LAYOUT
static const int nstack      = 0;    /* number of clients in primary stack area */
#endif // FLEXTILE_DELUXE_LAYOUT
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
static const int resizehints = 0;    /* 1 means respect size hints in tiled resizals */
static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if DECORATION_HINTS_PATCH
static const int decorhints  = 1;    /* 1 means respect decoration hints */
#endif // DECORATION_HINTS_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if NROWGRID_LAYOUT
#define FORCE_VSPLIT 1
#endif
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if TAPRESIZE_PATCH
/* mouse scroll resize */
static const int scrollsensetivity = 30; /* 1 means resize window by 1 pixel for each scroll event */
/* resizemousescroll direction argument list */
static const int scrollargs[][2] = {
        /* width change         height change */
        { +scrollsensetivity,	0 },
        { -scrollsensetivity,	0 },
        { 0, 				  	+scrollsensetivity },
        { 0, 					-scrollsensetivity },
};
#endif // TAPRESIZE_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if FLEXTILE_DELUXE_LAYOUT
static const Layout layouts[] = {
        /* symbol     arrange function, { nmaster, nstack, layout, master axis, stack axis, secondary stack axis, symbol func } */
        { "[]=",      flextile,         { -1, -1, SPLIT_VERTICAL, TOP_TO_BOTTOM, TOP_TO_BOTTOM, 0, NULL } }, // default tile layout
        { "><>",      NULL,             {0} },    /* no layout function means floating behavior */
        { "[M]",      flextile,         { -1, -1, NO_SPLIT, MONOCLE, MONOCLE, 0, NULL } }, // monocle
        { "|||",      flextile,         { -1, -1, SPLIT_VERTICAL, LEFT_TO_RIGHT, TOP_TO_BOTTOM, 0, NULL } }, // columns (col) layout
        { ">M>",      flextile,         { -1, -1, FLOATING_MASTER, LEFT_TO_RIGHT, LEFT_TO_RIGHT, 0, NULL } }, // floating master
        { "[D]",      flextile,         { -1, -1, SPLIT_VERTICAL, TOP_TO_BOTTOM, MONOCLE, 0, NULL } }, // deck
        { "TTT",      flextile,         { -1, -1, SPLIT_HORIZONTAL, LEFT_TO_RIGHT, LEFT_TO_RIGHT, 0, NULL } }, // bstack
        { "===",      flextile,         { -1, -1, SPLIT_HORIZONTAL, LEFT_TO_RIGHT, TOP_TO_BOTTOM, 0, NULL } }, // bstackhoriz
        { "|M|",      flextile,         { -1, -1, SPLIT_CENTERED_VERTICAL, LEFT_TO_RIGHT, TOP_TO_BOTTOM, TOP_TO_BOTTOM, NULL } }, // centeredmaster
        { "-M-",      flextile,         { -1, -1, SPLIT_CENTERED_HORIZONTAL, TOP_TO_BOTTOM, LEFT_TO_RIGHT, LEFT_TO_RIGHT, NULL } }, // centeredmaster horiz
        { ":::",      flextile,         { -1, -1, NO_SPLIT, GAPPLESSGRID, GAPPLESSGRID, 0, NULL } }, // gappless grid
        { "[\\]",     flextile,         { -1, -1, NO_SPLIT, DWINDLE, DWINDLE, 0, NULL } }, // fibonacci dwindle
        { "(@)",      flextile,         { -1, -1, NO_SPLIT, SPIRAL, SPIRAL, 0, NULL } }, // fibonacci spiral
        { "[T]",      flextile,         { -1, -1, SPLIT_VERTICAL, LEFT_TO_RIGHT, TATAMI, 0, NULL } }, // tatami mats
        #if TILE_LAYOUT
        { "[]=",      tile,             {0} },
        #endif
        #if MONOCLE_LAYOUT
        { "[M]",      monocle,          {0} },
        #endif
        #if BSTACK_LAYOUT
        { "TTT",      bstack,           {0} },
        #endif
        #if BSTACKHORIZ_LAYOUT
        { "===",      bstackhoriz,      {0} },
        #endif
        #if CENTEREDMASTER_LAYOUT
        { "|M|",      centeredmaster,   {0} },
        #endif
        #if CENTEREDFLOATINGMASTER_LAYOUT
        { ">M>",      centeredfloatingmaster, {0} },
        #endif
        #if COLUMNS_LAYOUT
        { "|||",      col,              {0} },
        #endif
        #if DECK_LAYOUT
        { "[D]",      deck,             {0} },
        #endif
        #if FIBONACCI_SPIRAL_LAYOUT
        { "(@)",      spiral,           {0} },
        #endif
        #if FIBONACCI_DWINDLE_LAYOUT
        { "[\\]",     dwindle,          {0} },
        #endif
        #if GRIDMODE_LAYOUT
        { "HHH",      grid,             {0} },
        #endif
        #if HORIZGRID_LAYOUT
        { "---",      horizgrid,        {0} },
        #endif
        #if GAPPLESSGRID_LAYOUT
        { ":::",      gaplessgrid,      {0} },
        #endif
        #if NROWGRID_LAYOUT
        { "###",      nrowgrid,         {0} },
        #endif
        #if CYCLELAYOUTS_PATCH
        { NULL,       NULL,             {0} },
        #endif
};
#else
static const Layout layouts[] = {
        /* symbol     arrange function */
        #if TILE_LAYOUT
        { "[]=",      tile },    /* first entry is default */
        #endif
        { "><>",      NULL },    /* no layout function means floating behavior */
        #if MONOCLE_LAYOUT
        { "[M]",      monocle },
        #endif
        #if BSTACK_LAYOUT
        { "TTT",      bstack },
        #endif
        #if BSTACKHORIZ_LAYOUT
        { "===",      bstackhoriz },
        #endif
        #if CENTEREDMASTER_LAYOUT
        { "|M|",      centeredmaster },
        #endif
        #if CENTEREDFLOATINGMASTER_LAYOUT
        { ">M>",      centeredfloatingmaster },
        #endif
        #if COLUMNS_LAYOUT
        { "|||",      col },
        #endif
        #if DECK_LAYOUT
        { "[D]",      deck },
        #endif
        #if FIBONACCI_SPIRAL_LAYOUT
        { "(@)",      spiral },
        #endif
        #if FIBONACCI_DWINDLE_LAYOUT
        { "[\\]",     dwindle },
        #endif
        #if GRIDMODE_LAYOUT
        { "HHH",      grid },
        #endif
        #if HORIZGRID_LAYOUT
        { "---",      horizgrid },
        #endif
        #if GAPPLESSGRID_LAYOUT
        { ":::",      gaplessgrid },
        #endif
        #if NROWGRID_LAYOUT
        { "###",      nrowgrid },
        #endif
        #if CYCLELAYOUTS_PATCH
        { NULL,       NULL },
        #endif
};
#endif // FLEXTILE_DELUXE_LAYOUT
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if XKB_PATCH
/* xkb frontend */
static const char *xkb_layouts[]  = {
        "en",
        "ru",
};
#endif // XKB_PATCH
#+END_SRC

** Keybindings

#+BEGIN_SRC c :tangle config.def.h
#define MODKEY Mod4Mask
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if COMBO_PATCH && SWAPTAGS_PATCH && TAGOTHERMONITOR_PATCH
#define TAGKEYS(KEY,TAG) \
        { MODKEY,                       KEY,      comboview,      {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
        { MODKEY|ShiftMask,             KEY,      combotag,       {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} }, \
        { MODKEY|Mod1Mask|ShiftMask,    KEY,      swaptags,       {.ui = 1 << TAG} }, \
        { MODKEY|Mod1Mask,              KEY,      tagnextmon,     {.ui = 1 << TAG} }, \
        { MODKEY|Mod1Mask|ControlMask,  KEY,      tagprevmon,     {.ui = 1 << TAG} },
#elif COMBO_PATCH && SWAPTAGS_PATCH
#define TAGKEYS(KEY,TAG) \
        { MODKEY,                       KEY,      comboview,      {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
        { MODKEY|ShiftMask,             KEY,      combotag,       {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} }, \
        { MODKEY|Mod1Mask|ShiftMask,    KEY,      swaptags,       {.ui = 1 << TAG} },
#elif COMBO_PATCH && TAGOTHERMONITOR_PATCH
#define TAGKEYS(KEY,TAG) \
        { MODKEY,                       KEY,      comboview,      {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
        { MODKEY|ShiftMask,             KEY,      combotag,       {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} }, \
        { MODKEY|Mod1Mask,              KEY,      tagnextmon,     {.ui = 1 << TAG} }, \
        { MODKEY|Mod1Mask|ControlMask,  KEY,      tagprevmon,     {.ui = 1 << TAG} },
#elif COMBO_PATCH
#define TAGKEYS(KEY,TAG) \
        { MODKEY,                       KEY,      comboview,      {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
        { MODKEY|ShiftMask,             KEY,      combotag,       {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
#elif SWAPTAGS_PATCH && TAGOTHERMONITOR_PATCH
#define TAGKEYS(KEY,TAG) \
        { MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
        { MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} }, \
        { MODKEY|Mod1Mask|ShiftMask,    KEY,      swaptags,       {.ui = 1 << TAG} }, \
        { MODKEY|Mod1Mask,              KEY,      tagnextmon,     {.ui = 1 << TAG} }, \
        { MODKEY|Mod1Mask|ControlMask,  KEY,      tagprevmon,     {.ui = 1 << TAG} },
#elif SWAPTAGS_PATCH
#define TAGKEYS(KEY,TAG) \
        { MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
        { MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} }, \
        { MODKEY|Mod1Mask|ShiftMask,    KEY,      swaptags,       {.ui = 1 << TAG} },
#elif TAGOTHERMONITOR_PATCH
#define TAGKEYS(KEY,TAG) \
        { MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
        { MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} }, \
        { MODKEY|Mod1Mask,              KEY,      tagnextmon,     {.ui = 1 << TAG} }, \
        { MODKEY|Mod1Mask|ControlMask,  KEY,      tagprevmon,     {.ui = 1 << TAG} },
#else
#define TAGKEYS(KEY,TAG) \
        { MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
        { MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
        { MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
#endif // COMBO_PATCH / SWAPTAGS_PATCH / TAGOTHERMONITOR_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if STACKER_PATCH
#define STACKKEYS(MOD,ACTION) \
        { MOD, XK_j,     ACTION##stack, {.i = INC(+1) } }, \
        { MOD, XK_k,     ACTION##stack, {.i = INC(-1) } }, \
        { MOD, XK_s,     ACTION##stack, {.i = PREVSEL } }, \
        { MOD, XK_w,     ACTION##stack, {.i = 0 } }, \
        { MOD, XK_e,     ACTION##stack, {.i = 1 } }, \
        { MOD, XK_a,     ACTION##stack, {.i = 2 } }, \
        { MOD, XK_z,     ACTION##stack, {.i = -1 } },
#endif // STACKER_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_HOLDBAR_PATCH
#define HOLDKEY 0 // replace 0 with the keysym to activate holdbar
#endif // BAR_HOLDBAR_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
/* helper for spawning shell commands in the pre dwm-5.0 fashion */
#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if !NODMENU_PATCH
static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
#endif // NODMENU_PATCH
static const char *dmenucmd[] = {
        "dmenu_run",
        #if !NODMENU_PATCH
        "-m", dmenumon,
        #endif // NODMENU_PATCH
        "-fn", dmenufont,
        "-nb", normbgcolor,
        "-nf", normfgcolor,
        "-sb", selbgcolor,
        "-sf", selfgcolor,
        #if BAR_DMENUMATCHTOP_PATCH
        topbar ? NULL : "-b",
        #endif // BAR_DMENUMATCHTOP_PATCH
        NULL
};
static const char *termcmd[]             = { "kitty", NULL };
static const char *roficmd[]             = { "rofi", "-show", "combi", NULL };
static const char *controlcentercmd[]    = { "/home/sravan/.scripts/control-center.sh", "--rofi", NULL };
static const char *brightnesscmd[]       = { "/home/sravan/.scripts/brightness.sh", "--rofi", NULL };
static const char *clipboardcmd[]        = { "rofi", "-show", "clipboard", NULL };
static const char *rbwcmd[]              = { "rofi-rbw", NULL };
static const char *volumecmd[]           = { "/home/sravan/.scripts/pactl.sh", "--rofi", NULL };
static const char *mediacmd[]            = { "/home/sravan/.scripts/playerctl.sh", "--rofi", NULL };
static const char *notificationcmd[]     = { "/home/sravan/.scripts/dunst.sh", "--rofi", NULL };
static const char *sessioncmd[]          = { "/home/sravan/.scripts/session.sh", "--rofi", NULL };
static const char *compositorcmd[]       = { "/home/sravan/.scripts/picom.sh", "--rofi", NULL };
static const char *lowervolumecmd[]      = { "/home/sravan/.scripts/pactl.sh", "--lower", NULL };
static const char *mutevolumecmd[]       = { "/home/sravan/.scripts/pactl.sh", "--mute", NULL };
static const char *raisevolumecmd[]      = { "/home/sravan/.scripts/pactl.sh", "--raise", NULL };
static const char *playerplaypausecmd[]  = { "/home/sravan/.scripts/playerctl.sh", "--play-pause", NULL };
static const char *playernextcmd[]       = { "/home/sravan/.scripts/playerctl.sh", "--next", NULL };
static const char *playerprevcmd[]       = { "/home/sravan/.scripts/playerctl.sh", "--prev", NULL };
static const char *flameshotcmd[]        = { "flameshot", "gui", NULL };
static const char *forceclosewindowcmd[] = { "xkill", NULL };
static const char *trackpadtogglecmd[]   = { "/home/sravan/.scripts/trackpad.sh", NULL };
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if BAR_STATUSCMD_PATCH
#if BAR_DWMBLOCKS_PATCH
/* This defines the name of the executable that handles the bar (used for signalling purposes) */
#define STATUSBAR "dwmblocks"
#else
/* commands spawned when clicking statusbar, the mouse button pressed is exported as BUTTON */
static const StatusCmd statuscmds[] = {
        { "notify-send Volume$BUTTON", 1 },
        { "notify-send CPU$BUTTON", 2 },
        { "notify-send Battery$BUTTON", 3 },
};
/* test the above with: xsetroot -name "$(printf '\x01Volume |\x02 CPU |\x03 Battery')" */
static const char *statuscmd[] = { "/bin/sh", "-c", NULL, NULL };
#endif // BAR_DWMBLOCKS_PATCH
#endif // BAR_STATUSCMD_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if ON_EMPTY_KEYS_PATCH
static const char* firefoxcmd[] = {"firefox", NULL};
static const Key on_empty_keys[] = {
        /* modifier key            function                argument */
        { 0,        XK_f,          spawn,                  {.v = firefoxcmd } },
};
#endif // ON_EMPTY_KEYS_PATCH
#+END_SRC

See [[https://cgit.freedesktop.org/xorg/proto/x11proto/tree/XF86keysym.h][X11 protocol header]] for list of key symbols.

#+BEGIN_SRC c :tangle config.def.h
#include <X11/XF86keysym.h>
static const Key keys[] = {
        /* modifier                     key            function                argument */
        #if KEYMODES_PATCH
        { MODKEY,                       XK_Escape,     setkeymode,             {.ui = COMMANDMODE} },
        #endif // KEYMODES_PATCH

        { MODKEY,                       XK_p,          spawn,                  {.v = roficmd } },
        { MODKEY|ControlMask,           XK_p,          spawn,                  {.v = controlcentercmd } },
        { MODKEY|ShiftMask,             XK_Return,     spawn,                  {.v = termcmd } },
        { MODKEY|ControlMask,           XK_c,          spawn,                  {.v = clipboardcmd} },
        { MODKEY|ControlMask,           XK_d,          spawn,                  {.v = brightnesscmd} },
        { MODKEY|ControlMask,           XK_b,          spawn,                  {.v = rbwcmd} },
        { MODKEY|ControlMask,           XK_v,          spawn,                  {.v = volumecmd} },
        { MODKEY|ControlMask,           XK_m,          spawn,                  {.v = mediacmd} },
        { MODKEY|ControlMask,           XK_n,          spawn,                  {.v = notificationcmd} },
        { MODKEY|ControlMask,           XK_q,          spawn,                  {.v = sessioncmd} },
        { MODKEY|ControlMask,           XK_Escape,     spawn,                  {.v = compositorcmd} },

        { 0,                            XF86XK_AudioLowerVolume, spawn,        {.v = lowervolumecmd} },
        { 0,                            XF86XK_AudioMute,        spawn,        {.v = mutevolumecmd} },
        { 0,                            XF86XK_AudioRaiseVolume, spawn,        {.v = raisevolumecmd} },
        { 0,                            XF86XK_AudioPlay,        spawn,        {.v = playerplaypausecmd} },
        { 0,                            XF86XK_AudioNext,        spawn,        {.v = playernextcmd} },
        { 0,                            XF86XK_AudioPrev,        spawn,        {.v = playerprevcmd} },
        { 0,                            XF86XK_TouchpadToggle,   spawn,        {.v = trackpadtogglecmd} },
        { 0,                            XK_Print,                spawn,        {.v = flameshotcmd} },

        #if RIODRAW_PATCH
        { MODKEY|ControlMask,           XK_p,          riospawnsync,           {.v = dmenucmd } },
        { MODKEY|ControlMask,           XK_Return,     riospawn,               {.v = termcmd } },
        { MODKEY,                       XK_s,          rioresize,              {0} },
        #endif // RIODRAW_PATCH

        { MODKEY,                       XK_s,          togglebar,              {0} },

        #if TOGGLETOPBAR_PATCH
        { MODKEY|ShiftMask,             XK_b,          toggletopbar,           {0} },
        #endif // TOGGLETOPBAR_PATCH

        #if TAB_PATCH
        { MODKEY|ControlMask,           XK_b,          tabmode,                {-1} },
        #endif // TAB_PATCH

        #if FOCUSMASTER_PATCH || FOCUSMASTER_RETURN_PATCH
        { MODKEY|ControlMask,           XK_space,      focusmaster,            {0} },
        #endif // FOCUSMASTER_PATCH / FOCUSMASTER_RETURN_PATCH

        #if STACKER_PATCH
        STACKKEYS(MODKEY,                              focus)
        STACKKEYS(MODKEY|ShiftMask,                    push)
        #else
        { MODKEY,                       XK_j,          focusstack,             {.i = +1 } },
        { MODKEY,                       XK_k,          focusstack,             {.i = -1 } },
        #endif // STACKER_PATCH

        #if FOCUSDIR_PATCH
        { MODKEY,                       XK_Left,       focusdir,               {.i = 0 } }, // left
        { MODKEY,                       XK_Right,      focusdir,               {.i = 1 } }, // right
        { MODKEY,                       XK_Up,         focusdir,               {.i = 2 } }, // up
        { MODKEY,                       XK_Down,       focusdir,               {.i = 3 } }, // down
        #endif // FOCUSDIR_PATCH

        #if PLACEDIR_PATCH
        { MODKEY|ControlMask,           XK_Left,       placedir,               {.i = 0 } }, // left
        { MODKEY|ControlMask,           XK_Right,      placedir,               {.i = 1 } }, // right
        { MODKEY|ControlMask,           XK_Up,         placedir,               {.i = 2 } }, // up
        { MODKEY|ControlMask,           XK_Down,       placedir,               {.i = 3 } }, // down
        #endif // PLACEDIR_PATCH

        #if SWAPFOCUS_PATCH && PERTAG_PATCH
        { MODKEY,                       XK_s,          swapfocus,              {.i = -1 } },
        #endif // SWAPFOCUS_PATCH

        #if SWITCHCOL_PATCH
        { MODKEY,                       XK_v,          switchcol,              {0} },
        #endif // SWITCHCOL_PATCH

        #if ROTATESTACK_PATCH
        { MODKEY|Mod1Mask,              XK_j,          rotatestack,            {.i = +1 } },
        { MODKEY|Mod1Mask,              XK_k,          rotatestack,            {.i = -1 } },
        #endif // ROTATESTACK_PATCH

        #if INPLACEROTATE_PATCH
        { MODKEY|Mod1Mask,              XK_j,          inplacerotate,          {.i = +2 } }, // same as rotatestack
        { MODKEY|Mod1Mask,              XK_k,          inplacerotate,          {.i = -2 } }, // same as reotatestack
        { MODKEY|Mod1Mask|ShiftMask,    XK_j,          inplacerotate,          {.i = +1} },
        { MODKEY|Mod1Mask|ShiftMask,    XK_k,          inplacerotate,          {.i = -1} },
        #endif // INPLACEROTATE_PATCH

        #if PUSH_PATCH || PUSH_NO_MASTER_PATCH
        { MODKEY|ControlMask,           XK_j,          pushdown,               {0} },
        { MODKEY|ControlMask,           XK_k,          pushup,                 {0} },
        #endif // PUSH_PATCH / PUSH_NO_MASTER_PATCH

        { MODKEY,                       XK_i,          incnmaster,             {.i = +1 } },
        { MODKEY,                       XK_d,          incnmaster,             {.i = -1 } },

        #if FLEXTILE_DELUXE_LAYOUT
        { MODKEY|ControlMask,           XK_i,          incnstack,              {.i = +1 } },
        { MODKEY|ControlMask,           XK_u,          incnstack,              {.i = -1 } },
        #endif // FLEXTILE_DELUXE_LAYOUT

        { MODKEY,                       XK_h,          setmfact,               {.f = -0.05} },
        { MODKEY,                       XK_l,          setmfact,               {.f = +0.05} },

        #if CFACTS_PATCH
        { MODKEY|ShiftMask,             XK_h,          setcfact,               {.f = +0.25} },
        { MODKEY|ShiftMask,             XK_l,          setcfact,               {.f = -0.25} },
        { MODKEY|ShiftMask,             XK_o,          setcfact,               {0} },
        #endif // CFACTS_PATCH

        #if ASPECTRESIZE_PATCH
        { MODKEY|ControlMask|ShiftMask, XK_e,          aspectresize,           {.i = +24} },
        { MODKEY|ControlMask|ShiftMask, XK_r,          aspectresize,           {.i = -24} },
        #endif // ASPECTRESIZE_PATCH

        #if MOVERESIZE_PATCH
        { MODKEY|Mod1Mask,              XK_Down,       moveresize,             {.v = "0x 25y 0w 0h" } },
        { MODKEY|Mod1Mask,              XK_Up,         moveresize,             {.v = "0x -25y 0w 0h" } },
        { MODKEY|Mod1Mask,              XK_Right,      moveresize,             {.v = "25x 0y 0w 0h" } },
        { MODKEY|Mod1Mask,              XK_Left,       moveresize,             {.v = "-25x 0y 0w 0h" } },
        { MODKEY|Mod1Mask|ShiftMask,    XK_Down,       moveresize,             {.v = "0x 0y 0w 25h" } },
        { MODKEY|Mod1Mask|ShiftMask,    XK_Up,         moveresize,             {.v = "0x 0y 0w -25h" } },
        { MODKEY|Mod1Mask|ShiftMask,    XK_Right,      moveresize,             {.v = "0x 0y 25w 0h" } },
        { MODKEY|Mod1Mask|ShiftMask,    XK_Left,       moveresize,             {.v = "0x 0y -25w 0h" } },
        #endif // MOVERESIZE_PATCH

        #if MOVESTACK_PATCH
        { MODKEY|ShiftMask,             XK_j,          movestack,              {.i = +1 } },
        { MODKEY|ShiftMask,             XK_k,          movestack,              {.i = -1 } },
        #endif // MOVESTACK_PATCH

        #if TRANSFER_PATCH
        { MODKEY,                       XK_x,          transfer,               {0} },
        #endif // TRANSFER_PATCH

        #if TRANSFER_ALL_PATCH
        { MODKEY|ControlMask,           XK_x,          transferall,            {0} },
        #endif // TRANSFER_ALL_PATCH

        #if REORGANIZETAGS_PATCH
        { MODKEY|ControlMask,           XK_r,          reorganizetags,         {0} },
        #endif // REORGANIZETAGS_PATCH

        #if DISTRIBUTETAGS_PATCH
        { MODKEY|ControlMask,           XK_d,          distributetags,         {0} },
        #endif // DISTRIBUTETAGS_PATCH

        #if INSETS_PATCH
        { MODKEY|ShiftMask|ControlMask, XK_a,          updateinset,            {.v = &default_inset } },
        #endif // INSETS_PATCH

        { MODKEY,                       XK_Return,     zoom,                   {0} },
        #if VANITYGAPS_PATCH
        { MODKEY|Mod1Mask,              XK_u,          incrgaps,               {.i = +1 } },
        { MODKEY|Mod1Mask|ShiftMask,    XK_u,          incrgaps,               {.i = -1 } },
        { MODKEY|Mod1Mask,              XK_i,          incrigaps,              {.i = +1 } },
        { MODKEY|Mod1Mask|ShiftMask,    XK_i,          incrigaps,              {.i = -1 } },
        { MODKEY|Mod1Mask,              XK_o,          incrogaps,              {.i = +1 } },
        { MODKEY|Mod1Mask|ShiftMask,    XK_o,          incrogaps,              {.i = -1 } },
        { MODKEY|Mod1Mask,              XK_6,          incrihgaps,             {.i = +1 } },
        { MODKEY|Mod1Mask|ShiftMask,    XK_6,          incrihgaps,             {.i = -1 } },
        { MODKEY|Mod1Mask,              XK_7,          incrivgaps,             {.i = +1 } },
        { MODKEY|Mod1Mask|ShiftMask,    XK_7,          incrivgaps,             {.i = -1 } },
        { MODKEY|Mod1Mask,              XK_8,          incrohgaps,             {.i = +1 } },
        { MODKEY|Mod1Mask|ShiftMask,    XK_8,          incrohgaps,             {.i = -1 } },
        { MODKEY|Mod1Mask,              XK_9,          incrovgaps,             {.i = +1 } },
        { MODKEY|Mod1Mask|ShiftMask,    XK_9,          incrovgaps,             {.i = -1 } },
        { MODKEY|Mod1Mask,              XK_0,          togglegaps,             {0} },
        { MODKEY|Mod1Mask|ShiftMask,    XK_0,          defaultgaps,            {0} },
        #endif // VANITYGAPS_PATCH

        #if ALT_TAB_PATCH
        { Mod1Mask,                     XK_Tab,        alttabstart,            {0} },
        #else
        { MODKEY,                       XK_Tab,        view,                   {0} },
        #endif // ALT_TAB_PATCH

        #if SHIFTTAG_PATCH
        { MODKEY|ShiftMask,             XK_Left,       shifttag,               { .i = -1 } }, // note keybinding conflict with focusadjacenttag tagtoleft
        { MODKEY|ShiftMask,             XK_Right,      shifttag,               { .i = +1 } }, // note keybinding conflict with focusadjacenttag tagtoright
        #endif // SHIFTTAG_PATCH

        #if SHIFTTAGCLIENTS_PATCH
        { MODKEY|ShiftMask|ControlMask, XK_Left,       shifttagclients,        { .i = -1 } },
        { MODKEY|ShiftMask|ControlMask, XK_Right,      shifttagclients,        { .i = +1 } },
        #endif // SHIFTTAGCLIENTS_PATCH

        #if SHIFTVIEW_PATCH
        { MODKEY|ShiftMask,             XK_Tab,        shiftview,              { .i = -1 } },
        { MODKEY|ShiftMask,             XK_backslash,  shiftview,              { .i = +1 } },
        #endif // SHIFTVIEW_PATCH

        #if SHIFTVIEW_CLIENTS_PATCH
        { MODKEY|Mod1Mask,              XK_Tab,        shiftviewclients,       { .i = -1 } },
        { MODKEY|Mod1Mask,              XK_backslash,  shiftviewclients,       { .i = +1 } },
        #endif // SHIFTVIEW_CLIENTS_PATCH

        #if SHIFTBOTH_PATCH
        { MODKEY|ControlMask,           XK_Left,       shiftboth,              { .i = -1 } }, // note keybinding conflict with focusadjacenttag tagandviewtoleft placedir
        { MODKEY|ControlMask,           XK_Right,      shiftboth,              { .i = +1 } }, // note keybinding conflict with focusadjacenttag tagandviewtoright placedir
        #endif // SHIFTBOTH_PATCH

        #if SHIFTSWAPTAGS_PATCH && SWAPTAGS_PATCH
        { MODKEY|Mod4Mask|ShiftMask,    XK_Left,       shiftswaptags,          { .i = -1 } },
        { MODKEY|Mod4Mask|ShiftMask,    XK_Right,      shiftswaptags,          { .i = +1 } },
        #endif // SHIFTSWAPTAGS_PATCH

        #if BAR_WINTITLEACTIONS_PATCH
        { MODKEY|ControlMask,           XK_z,          showhideclient,         {0} },
        #endif // BAR_WINTITLEACTIONS_PATCH

        { MODKEY|ShiftMask,             XK_c,          killclient,             {0} },
        { MODKEY|ControlMask|ShiftMask, XK_c,          spawn,                  {.v = forceclosewindowcmd} },

        #if KILLUNSEL_PATCH
        { MODKEY|ShiftMask,             XK_x,          killunsel,              {0} },
        #endif // KILLUNSEL_PATCH

        #if SELFRESTART_PATCH
        { MODKEY|ControlMask|ShiftMask, XK_q,          self_restart,           {0} },
        #endif // SELFRESTART_PATCH

        { MODKEY|ShiftMask,             XK_q,          quit,                   {0} },

        #if RESTARTSIG_PATCH
        { MODKEY|ControlMask|ShiftMask, XK_q,          quit,                   {1} },
        #endif // RESTARTSIG_PATCH

        #if FOCUSURGENT_PATCH
        { MODKEY,                       XK_u,          focusurgent,            {0} },
        #endif // FOCUSURGENT_PATCH

        #if BAR_HOLDBAR_PATCH
        { 0,                            HOLDKEY,       holdbar,                {0} },
        #endif // BAR_HOLDBAR_PATCH

        #if WINVIEW_PATCH
        { MODKEY,                       XK_o,          winview,                {0} },
        #endif // WINVIEW_PATCH

        #if XRDB_PATCH && !BAR_VTCOLORS_PATCH
        { MODKEY|ShiftMask,             XK_F5,         xrdb,                   {.v = NULL } },
        #endif // XRDB_PATCH

        { MODKEY,                       XK_t,          setlayout,              {.v = &layouts[0]} },
        { MODKEY,                       XK_f,          setlayout,              {.v = &layouts[1]} },
        { MODKEY,                       XK_m,          setlayout,              {.v = &layouts[2]} },
        { MODKEY,                       XK_y,          setlayout,              {.v = &layouts[3]} },
        { MODKEY,                       XK_g,          setlayout,              {.v = &layouts[4]} },

        #if COLUMNS_LAYOUT
        { MODKEY,                       XK_c,          setlayout,              {.v = &layouts[3]} },
        #endif // COLUMNS_LAYOUT

        #if FLEXTILE_DELUXE_LAYOUT
        { MODKEY|ControlMask,           XK_t,          rotatelayoutaxis,       {.i = +1 } },   /* flextile, 1 = layout axis */
        { MODKEY|ControlMask,           XK_Tab,        rotatelayoutaxis,       {.i = +2 } },   /* flextile, 2 = master axis */
        { MODKEY|ControlMask|ShiftMask, XK_Tab,        rotatelayoutaxis,       {.i = +3 } },   /* flextile, 3 = stack axis */
        { MODKEY|ControlMask|Mod1Mask,  XK_Tab,        rotatelayoutaxis,       {.i = +4 } },   /* flextile, 4 = secondary stack axis */
        { MODKEY|Mod5Mask,              XK_t,          rotatelayoutaxis,       {.i = -1 } },   /* flextile, 1 = layout axis */
        { MODKEY|Mod5Mask,              XK_Tab,        rotatelayoutaxis,       {.i = -2 } },   /* flextile, 2 = master axis */
        { MODKEY|Mod5Mask|ShiftMask,    XK_Tab,        rotatelayoutaxis,       {.i = -3 } },   /* flextile, 3 = stack axis */
        { MODKEY|Mod5Mask|Mod1Mask,     XK_Tab,        rotatelayoutaxis,       {.i = -4 } },   /* flextile, 4 = secondary stack axis */
        { MODKEY|ControlMask,           XK_Return,     mirrorlayout,           {0} },          /* flextile, flip master and stack areas */
        #endif // FLEXTILE_DELUXE_LAYOUT

        { MODKEY,                       XK_space,      setlayout,              {0} },
        { MODKEY|ShiftMask,             XK_space,      togglefloating,         {0} },

        #if MAXIMIZE_PATCH
        { MODKEY|ControlMask|ShiftMask, XK_h,          togglehorizontalmax,    {0} },
        { MODKEY|ControlMask|ShiftMask, XK_l,          togglehorizontalmax,    {0} },
        { MODKEY|ControlMask|ShiftMask, XK_j,          toggleverticalmax,      {0} },
        { MODKEY|ControlMask|ShiftMask, XK_k,          toggleverticalmax,      {0} },
        { MODKEY|ControlMask,           XK_m,          togglemax,              {0} },
        #endif // MAXIMIZE_PATCH

        #if NO_MOD_BUTTONS_PATCH
        { MODKEY|ShiftMask,             XK_Escape,     togglenomodbuttons,     {0} },
        #endif // NO_MOD_BUTTONS_PATCH

        #if RENAMED_SCRATCHPADS_PATCH
        { MODKEY,                       XK_grave,      togglescratch,          {.v = scratchpadcmd } },
        { MODKEY|ControlMask,           XK_grave,      setscratch,             {.v = scratchpadcmd } },
        { MODKEY|ShiftMask,             XK_grave,      removescratch,          {.v = scratchpadcmd } },
        #elif SCRATCHPADS_PATCH
        { MODKEY,                       XK_grave,      togglescratch,          {.ui = 0 } },
        { MODKEY|ControlMask,           XK_grave,      setscratch,             {.ui = 0 } },
        { MODKEY|ShiftMask,             XK_grave,      removescratch,          {.ui = 0 } },
        #endif // SCRATCHPADS_PATCH | RENAMED_SCRATCHPADS_PATCH

        #if UNFLOATVISIBLE_PATCH
        { MODKEY|Mod1Mask,              XK_space,      unfloatvisible,         {0} },
        { MODKEY|ShiftMask,             XK_t,          unfloatvisible,         {.v = &layouts[0]} },
        { MODKEY|ShiftMask,             XK_m,          unfloatvisible,         {.v = &layouts[2]} },
        { MODKEY|ShiftMask,             XK_y,          unfloatvisible,         {.v = &layouts[3]} },
        { MODKEY|ShiftMask,             XK_g,          unfloatvisible,         {.v = &layouts[4]} },
        #endif // UNFLOATVISIBLE_PATCH

        #if TOGGLEFULLSCREEN_PATCH
        { MODKEY|ShiftMask,             XK_f,          togglefullscreen,       {0} },
        #endif // TOGGLEFULLSCREEN_PATCH

        #if !FAKEFULLSCREEN_PATCH && FAKEFULLSCREEN_CLIENT_PATCH
        { MODKEY|ShiftMask,             XK_y,          togglefakefullscreen,   {0} },
        #endif // FAKEFULLSCREEN_CLIENT_PATCH

        #if FULLSCREEN_PATCH
        { MODKEY|ShiftMask,             XK_f,          fullscreen,             {0} },
        #endif // FULLSCREEN_PATCH

        #if STICKY_PATCH
        { MODKEY|ShiftMask,             XK_s,          togglesticky,           {0} },
        #endif // STICKY_PATCH

        #if SCRATCHPAD_ALT_1_PATCH
        { MODKEY,                       XK_minus,      scratchpad_show,        {0} },
        { MODKEY|ShiftMask,             XK_minus,      scratchpad_hide,        {0} },
        { MODKEY,                       XK_equal,      scratchpad_remove,      {0} },
        #elif SCRATCHPADS_PATCH && !RENAMED_SCRATCHPADS_PATCH
        { MODKEY,                       XK_0,          view,                   {.ui = ~SPTAGMASK } },
        { MODKEY|ShiftMask,             XK_0,          tag,                    {.ui = ~SPTAGMASK } },
        #else
        { MODKEY,                       XK_0,          view,                   {.ui = ~0 } },
        { MODKEY|ShiftMask,             XK_0,          tag,                    {.ui = ~0 } },
        #endif // SCRATCHPAD_ALT_1_PATCH

        { MODKEY,                       XK_comma,      focusmon,               {.i = -1 } },
        { MODKEY,                       XK_period,     focusmon,               {.i = +1 } },
        { MODKEY|ShiftMask,             XK_comma,      tagmon,                 {.i = -1 } },
        { MODKEY|ShiftMask,             XK_period,     tagmon,                 {.i = +1 } },

        #if FOCUSADJACENTTAG_PATCH
        { MODKEY,                       XK_Left,       viewtoleft,             {0} }, // note keybinding conflict with focusdir
        { MODKEY,                       XK_Right,      viewtoright,            {0} }, // note keybinding conflict with focusdir
        { MODKEY|ShiftMask,             XK_Left,       tagtoleft,              {0} }, // note keybinding conflict with shifttag
        { MODKEY|ShiftMask,             XK_Right,      tagtoright,             {0} }, // note keybinding conflict with shifttag
        { MODKEY|ControlMask,           XK_Left,       tagandviewtoleft,       {0} }, // note keybinding conflict with placedir
        { MODKEY|ControlMask,           XK_Right,      tagandviewtoright,      {0} }, // note keybinding conflict with placedir
        #endif // FOCUSADJACENTTAG_PATCH

        #if TAGALL_PATCH
        { MODKEY|ShiftMask,             XK_F1,         tagall,                 {.v = "F1"} },
        { MODKEY|ShiftMask,             XK_F2,         tagall,                 {.v = "F2"} },
        { MODKEY|ShiftMask,             XK_F3,         tagall,                 {.v = "F3"} },
        { MODKEY|ShiftMask,             XK_F4,         tagall,                 {.v = "F4"} },
        { MODKEY|ShiftMask,             XK_F5,         tagall,                 {.v = "F5"} },
        { MODKEY|ShiftMask,             XK_F6,         tagall,                 {.v = "F6"} },
        { MODKEY|ShiftMask,             XK_F7,         tagall,                 {.v = "F7"} },
        { MODKEY|ShiftMask,             XK_F8,         tagall,                 {.v = "F8"} },
        { MODKEY|ShiftMask,             XK_F9,         tagall,                 {.v = "F9"} },
        { MODKEY|ControlMask,           XK_F1,         tagall,                 {.v = "1"} },
        { MODKEY|ControlMask,           XK_F2,         tagall,                 {.v = "2"} },
        { MODKEY|ControlMask,           XK_F3,         tagall,                 {.v = "3"} },
        { MODKEY|ControlMask,           XK_F4,         tagall,                 {.v = "4"} },
        { MODKEY|ControlMask,           XK_F5,         tagall,                 {.v = "5"} },
        { MODKEY|ControlMask,           XK_F6,         tagall,                 {.v = "6"} },
        { MODKEY|ControlMask,           XK_F7,         tagall,                 {.v = "7"} },
        { MODKEY|ControlMask,           XK_F8,         tagall,                 {.v = "8"} },
        { MODKEY|ControlMask,           XK_F9,         tagall,                 {.v = "9"} },
        #endif // TAGALL_PATCH

        #if TAGALLMON_PATCH
        { MODKEY|Mod1Mask|ShiftMask,    XK_comma,      tagallmon,              {.i = +1 } },
        { MODKEY|Mod1Mask|ShiftMask,    XK_period,     tagallmon,              {.i = -1 } },
        #endif // TAGALLMON_PATCH

        #if TAGSWAPMON_PATCH
        { MODKEY|Mod1Mask|ControlMask,  XK_comma,      tagswapmon,             {.i = +1 } },
        { MODKEY|Mod1Mask|ControlMask,  XK_period,     tagswapmon,             {.i = -1 } },
        #endif // TAGSWAPMON_PATCH

        #if BAR_ALTERNATIVE_TAGS_PATCH
        { MODKEY,                       XK_n,          togglealttag,           {0} },
        #endif // BAR_ALTERNATIVE_TAGS_PATCH

        #if NAMETAG_PATCH
        { MODKEY|ShiftMask,             XK_n,          nametag,                {0} },
        #endif // NAMETAG_PATCH

        #if BAR_TAGGRID_PATCH
        { MODKEY|ControlMask,           XK_Up,         switchtag,              { .ui = SWITCHTAG_UP    | SWITCHTAG_VIEW } },
        { MODKEY|ControlMask,           XK_Down,       switchtag,              { .ui = SWITCHTAG_DOWN  | SWITCHTAG_VIEW } },
        { MODKEY|ControlMask,           XK_Right,      switchtag,              { .ui = SWITCHTAG_RIGHT | SWITCHTAG_VIEW } }, // note keybinding conflict with placedir
        { MODKEY|ControlMask,           XK_Left,       switchtag,              { .ui = SWITCHTAG_LEFT  | SWITCHTAG_VIEW } }, // note keybinding conflict with placedir
        { MODKEY|Mod1Mask,              XK_Up,         switchtag,              { .ui = SWITCHTAG_UP    | SWITCHTAG_TAG | SWITCHTAG_VIEW } },
        { MODKEY|Mod1Mask,              XK_Down,       switchtag,              { .ui = SWITCHTAG_DOWN  | SWITCHTAG_TAG | SWITCHTAG_VIEW } },
        { MODKEY|Mod1Mask,              XK_Right,      switchtag,              { .ui = SWITCHTAG_RIGHT | SWITCHTAG_TAG | SWITCHTAG_VIEW } },
        { MODKEY|Mod1Mask,              XK_Left,       switchtag,              { .ui = SWITCHTAG_LEFT  | SWITCHTAG_TAG | SWITCHTAG_VIEW } },
        #endif // BAR_TAGGRID_PATCH

        #if MOVEPLACE_PATCH
        { MODKEY,                       XK_KP_7,       moveplace,              {.ui = WIN_NW }},   /* XK_KP_Home,  */
        { MODKEY,                       XK_KP_8,       moveplace,              {.ui = WIN_N  }},   /* XK_KP_Up,    */
        { MODKEY,                       XK_KP_9,       moveplace,              {.ui = WIN_NE }},   /* XK_KP_Prior, */
        { MODKEY,                       XK_KP_4,       moveplace,              {.ui = WIN_W  }},   /* XK_KP_Left,  */
        { MODKEY,                       XK_KP_5,       moveplace,              {.ui = WIN_C  }},   /* XK_KP_Begin, */
        { MODKEY,                       XK_KP_6,       moveplace,              {.ui = WIN_E  }},   /* XK_KP_Right, */
        { MODKEY,                       XK_KP_1,       moveplace,              {.ui = WIN_SW }},   /* XK_KP_End,   */
        { MODKEY,                       XK_KP_2,       moveplace,              {.ui = WIN_S  }},   /* XK_KP_Down,  */
        { MODKEY,                       XK_KP_3,       moveplace,              {.ui = WIN_SE }},   /* XK_KP_Next,  */
        #endif // MOVEPLACE_PATCH

        #if NAMETAG_PATCH
        { "nametag",                 nametag },
        #endif // NAMETAG_PATCH

        #if EXRESIZE_PATCH
        { MODKEY,                       XK_KP_7,       explace,                {.ui = EX_NW }},   /* XK_KP_Home,  */
        { MODKEY,                       XK_KP_8,       explace,                {.ui = EX_N  }},   /* XK_KP_Up,    */
        { MODKEY,                       XK_KP_9,       explace,                {.ui = EX_NE }},   /* XK_KP_Prior, */
        { MODKEY,                       XK_KP_4,       explace,                {.ui = EX_W  }},   /* XK_KP_Left,  */
        { MODKEY,                       XK_KP_5,       explace,                {.ui = EX_C  }},   /* XK_KP_Begin, */
        { MODKEY,                       XK_KP_6,       explace,                {.ui = EX_E  }},   /* XK_KP_Right, */
        { MODKEY,                       XK_KP_1,       explace,                {.ui = EX_SW }},   /* XK_KP_End,   */
        { MODKEY,                       XK_KP_2,       explace,                {.ui = EX_S  }},   /* XK_KP_Down,  */
        { MODKEY,                       XK_KP_3,       explace,                {.ui = EX_SE }},   /* XK_KP_Next,  */
        { MODKEY|ShiftMask,             XK_KP_8,       exresize,               {.v = (int []){   0,  25 }}},  /* XK_KP_Up,    */
        { MODKEY|ShiftMask,             XK_KP_2,       exresize,               {.v = (int []){   0, -25 }}},  /* XK_KP_Down,  */
        { MODKEY|ShiftMask,             XK_KP_6,       exresize,               {.v = (int []){  25,   0 }}},  /* XK_KP_Right, */
        { MODKEY|ShiftMask,             XK_KP_4,       exresize,               {.v = (int []){ -25,   0 }}},  /* XK_KP_Left,  */
        { MODKEY|ShiftMask,             XK_KP_5,       exresize,               {.v = (int []){  25,  25 }}},  /* XK_KP_Begin, */
        { MODKEY|ShiftMask|ControlMask, XK_KP_5,       exresize,               {.v = (int []){ -25, -25 }}},  /* XK_KP_Begin, */
        { MODKEY|ControlMask,           XK_KP_6,       togglehorizontalexpand, {.i = +1} },  /* XK_KP_Right, */
        { MODKEY|ControlMask,           XK_KP_3,       togglehorizontalexpand, {.i =  0} },  /* XK_KP_Next,  */
        { MODKEY|ControlMask,           XK_KP_4,       togglehorizontalexpand, {.i = -1} },  /* XK_KP_Left,  */
        { MODKEY|ControlMask,           XK_KP_8,       toggleverticalexpand,   {.i = +1} },  /* XK_KP_Up,    */
        { MODKEY|ControlMask,           XK_KP_1,       toggleverticalexpand,   {.i =  0} },  /* XK_KP_End,   */
        { MODKEY|ControlMask,           XK_KP_2,       toggleverticalexpand,   {.i = -1} },  /* XK_KP_Down,  */
        { MODKEY|ControlMask,           XK_KP_9,       togglemaximize,         {.i = -1} },  /* XK_KP_Prior, */
        { MODKEY|ControlMask,           XK_KP_7,       togglemaximize,         {.i = +1} },  /* XK_KP_Home,  */
        { MODKEY|ControlMask,           XK_KP_5,       togglemaximize,         {.i =  0} },  /* XK_KP_Begin, */
        #endif // EXRESIZE_PATCH

        #if FLOATPOS_PATCH
        /* Note that due to key limitations the below example kybindings are defined with a Mod3Mask,
         ,* which is not always readily available. Refer to the patch wiki for more details. */
        /* Client position is limited to monitor window area */
        { Mod3Mask,                     XK_u,            floatpos,               {.v = "-26x -26y" } }, // 
        { Mod3Mask,                     XK_i,            floatpos,               {.v = "  0x -26y" } }, // 
        { Mod3Mask,                     XK_o,            floatpos,               {.v = " 26x -26y" } }, // 
        { Mod3Mask,                     XK_j,            floatpos,               {.v = "-26x   0y" } }, // 
        { Mod3Mask,                     XK_l,            floatpos,               {.v = " 26x   0y" } }, // 
        { Mod3Mask,                     XK_m,            floatpos,               {.v = "-26x  26y" } }, // 
        { Mod3Mask,                     XK_comma,        floatpos,               {.v = "  0x  26y" } }, // 
        { Mod3Mask,                     XK_period,       floatpos,               {.v = " 26x  26y" } }, // 
        /* Absolute positioning (allows moving windows between monitors) */
        { Mod3Mask|ControlMask,         XK_u,            floatpos,               {.v = "-26a -26a" } }, // 
        { Mod3Mask|ControlMask,         XK_i,            floatpos,               {.v = "  0a -26a" } }, // 
        { Mod3Mask|ControlMask,         XK_o,            floatpos,               {.v = " 26a -26a" } }, // 
        { Mod3Mask|ControlMask,         XK_j,            floatpos,               {.v = "-26a   0a" } }, // 
        { Mod3Mask|ControlMask,         XK_l,            floatpos,               {.v = " 26a   0a" } }, // 
        { Mod3Mask|ControlMask,         XK_m,            floatpos,               {.v = "-26a  26a" } }, // 
        { Mod3Mask|ControlMask,         XK_comma,        floatpos,               {.v = "  0a  26a" } }, // 
        { Mod3Mask|ControlMask,         XK_period,       floatpos,               {.v = " 26a  26a" } }, // 
        /* Resize client, client center position is fixed which means that client expands in all directions */
        { Mod3Mask|ShiftMask,           XK_u,            floatpos,               {.v = "-26w -26h" } }, // 
        { Mod3Mask|ShiftMask,           XK_i,            floatpos,               {.v = "  0w -26h" } }, // 
        { Mod3Mask|ShiftMask,           XK_o,            floatpos,               {.v = " 26w -26h" } }, // 
        { Mod3Mask|ShiftMask,           XK_j,            floatpos,               {.v = "-26w   0h" } }, // 
        { Mod3Mask|ShiftMask,           XK_k,            floatpos,               {.v = "800W 800H" } }, // 
        { Mod3Mask|ShiftMask,           XK_l,            floatpos,               {.v = " 26w   0h" } }, // 
        { Mod3Mask|ShiftMask,           XK_m,            floatpos,               {.v = "-26w  26h" } }, // 
        { Mod3Mask|ShiftMask,           XK_comma,        floatpos,               {.v = "  0w  26h" } }, // 
        { Mod3Mask|ShiftMask,           XK_period,       floatpos,               {.v = " 26w  26h" } }, // 
        /* Client is positioned in a floating grid, movement is relative to client's current position */
        { Mod3Mask|Mod1Mask,            XK_u,            floatpos,               {.v = "-1p -1p" } }, // 
        { Mod3Mask|Mod1Mask,            XK_i,            floatpos,               {.v = " 0p -1p" } }, // 
        { Mod3Mask|Mod1Mask,            XK_o,            floatpos,               {.v = " 1p -1p" } }, // 
        { Mod3Mask|Mod1Mask,            XK_j,            floatpos,               {.v = "-1p  0p" } }, // 
        { Mod3Mask|Mod1Mask,            XK_k,            floatpos,               {.v = " 0p  0p" } }, // 
        { Mod3Mask|Mod1Mask,            XK_l,            floatpos,               {.v = " 1p  0p" } }, // 
        { Mod3Mask|Mod1Mask,            XK_m,            floatpos,               {.v = "-1p  1p" } }, // 
        { Mod3Mask|Mod1Mask,            XK_comma,        floatpos,               {.v = " 0p  1p" } }, // 
        { Mod3Mask|Mod1Mask,            XK_period,       floatpos,               {.v = " 1p  1p" } }, // 
        #endif // FLOATPOS_PATCH

        #if SETBORDERPX_PATCH
        { MODKEY|ControlMask,           XK_minus,      setborderpx,            {.i = -1 } },
        { MODKEY|ControlMask,           XK_plus,       setborderpx,            {.i = +1 } },
        { MODKEY|ControlMask,           XK_numbersign, setborderpx,            {.i = 0 } },
        #endif // SETBORDERPX_PATCH

        #if CYCLELAYOUTS_PATCH
        { MODKEY|ControlMask,           XK_comma,      cyclelayout,            {.i = -1 } },
        { MODKEY|ControlMask,           XK_period,     cyclelayout,            {.i = +1 } },
        #endif // CYCLELAYOUTS_PATCH

        #if MPDCONTROL_PATCH
        { MODKEY,                       XK_F1,         mpdchange,              {.i = -1} },
        { MODKEY,                       XK_F2,         mpdchange,              {.i = +1} },
        { MODKEY,                       XK_Escape,     mpdcontrol,             {0} },
        #endif // MPDCONTROL_PATCH

        TAGKEYS(                        XK_1,                                  0)
        TAGKEYS(                        XK_2,                                  1)
        TAGKEYS(                        XK_3,                                  2)
        TAGKEYS(                        XK_4,                                  3)
        TAGKEYS(                        XK_5,                                  4)
        TAGKEYS(                        XK_6,                                  5)
        TAGKEYS(                        XK_7,                                  6)
        TAGKEYS(                        XK_8,                                  7)
        TAGKEYS(                        XK_9,                                  8)
};
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if KEYMODES_PATCH
static const Key cmdkeys[] = {
        /* modifier                    keys                     function         argument */
        { 0,                           XK_Escape,               clearcmd,        {0} },
        { ControlMask,                 XK_c,                    clearcmd,        {0} },
        { 0,                           XK_i,                    setkeymode,      {.ui = INSERTMODE} },
};

static const Command commands[] = {
        /* modifier (4 keys)                          keysyms (4 keys)                              function         argument */
        { {ControlMask, ShiftMask, 0,         0},    {XK_w,      XK_h,    0,         0},            setlayout,       {.v = &layouts[0]} },
        { {ControlMask, 0,         0,         0},    {XK_w,      XK_o,    0,         0},            setlayout,       {.v = &layouts[2]} },
        { {ControlMask, ShiftMask, 0,         0},    {XK_w,      XK_o,    0,         0},            onlyclient,      {0} },
        { {ControlMask, 0,         0,         0},    {XK_w,      XK_v,    0,         0},            setlayout,       {.v = &layouts[0]} },
        { {ControlMask, 0,         0,         0},    {XK_w,      XK_less, 0,         0},            setmfact,        {.f = -0.05} },
        { {ControlMask, ShiftMask, 0,         0},    {XK_w,      XK_less, 0,         0},            setmfact,        {.f = +0.05} },
        { {ControlMask, ShiftMask, 0,         0},    {XK_w,      XK_0,    0,         0},            setmfact,        {.f = +1.50} },
        { {ShiftMask,   0,         0,         0},    {XK_period, XK_e,    0,         0},            spawn,           {.v = dmenucmd} },
        { {ShiftMask,   0,         0,         0},    {XK_period, XK_o,    0,         0},            spawn,           {.v = dmenucmd} },
        { {ShiftMask,   0,         0,         0},    {XK_period, XK_q,    XK_Return, 0},            quit,            {0} },
        { {ShiftMask,   0,         0,         0},    {XK_period, XK_b,    XK_d,      XK_Return},    killclient,      {0} },
        { {ShiftMask,   0,         0,         0},    {XK_period, XK_b,    XK_n,      XK_Return},    focusstack,      {.i = +1} },
        { {ShiftMask,   0,         ShiftMask, 0},    {XK_period, XK_b,    XK_n,      XK_Return},    focusstack,      {.i = -1} },
};
#endif // KEYMODES_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
/* button definitions */
#if STATUSBUTTON_PATCH
/* click can be ClkButton, ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
#else
/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
#endif //
static const Button buttons[] = {
        /* click                event mask           button          function        argument */
        #if BAR_STATUSBUTTON_PATCH
        { ClkButton,            0,                   Button1,        spawn,          {.v = dmenucmd } },
        #endif // BAR_STATUSBUTTON_PATCH
        { ClkLtSymbol,          0,                   Button1,        setlayout,      {0} },
        #if BAR_LAYOUTMENU_PATCH
        { ClkLtSymbol,          0,                   Button3,        layoutmenu,     {0} },
        #else
        { ClkLtSymbol,          0,                   Button3,        setlayout,      {.v = &layouts[2]} },
        #endif // BAR_LAYOUTMENU_PATCH
        #if BAR_WINTITLEACTIONS_PATCH
        { ClkWinTitle,          0,                   Button1,        togglewin,      {0} },
        { ClkWinTitle,          0,                   Button3,        showhideclient, {0} },
        #endif // BAR_WINTITLEACTIONS_PATCH
        { ClkWinTitle,          0,                   Button2,        zoom,           {0} },
        #if BAR_STATUSCMD_PATCH && BAR_DWMBLOCKS_PATCH
        { ClkStatusText,        0,                   Button1,        sigstatusbar,   {.i = 1 } },
        { ClkStatusText,        0,                   Button2,        sigstatusbar,   {.i = 2 } },
        { ClkStatusText,        0,                   Button3,        sigstatusbar,   {.i = 3 } },
        #elif BAR_STATUSCMD_PATCH
        { ClkStatusText,        0,                   Button1,        spawn,          {.v = statuscmd } },
        { ClkStatusText,        0,                   Button2,        spawn,          {.v = statuscmd } },
        { ClkStatusText,        0,                   Button3,        spawn,          {.v = statuscmd } },
        #else
        { ClkStatusText,        0,                   Button2,        spawn,          {.v = termcmd } },
        #endif // BAR_STATUSCMD_PATCH
        #if PLACEMOUSE_PATCH
        /* placemouse options, choose which feels more natural:
         ,*    0 - tiled position is relative to mouse cursor
         ,*    1 - tiled postiion is relative to window center
         ,*    2 - mouse pointer warps to window center
         ,*
         ,* The moveorplace uses movemouse or placemouse depending on the floating state
         ,* of the selected client. Set up individual keybindings for the two if you want
         ,* to control these separately (i.e. to retain the feature to move a tiled window
         ,* into a floating position).
         ,*/
        { ClkClientWin,         MODKEY,              Button1,        moveorplace,    {.i = 1} },
        #else
        { ClkClientWin,         MODKEY,              Button1,        movemouse,      {0} },
        #endif // PLACEMOUSE_PATCH
        { ClkClientWin,         MODKEY,              Button2,        togglefloating, {0} },
        { ClkClientWin,         MODKEY,              Button3,        resizemouse,    {0} },
        #if TAPRESIZE_PATCH
        { ClkClientWin,         MODKEY,              Button4,        resizemousescroll, {.v = &scrollargs[0]} },
        { ClkClientWin,         MODKEY,              Button5,        resizemousescroll, {.v = &scrollargs[1]} },
        { ClkClientWin,         MODKEY,              Button6,        resizemousescroll, {.v = &scrollargs[2]} },
        { ClkClientWin,         MODKEY,              Button7,        resizemousescroll, {.v = &scrollargs[3]} },
        #endif // TAPRESIZE_PATCH
        #if DRAGCFACT_PATCH && CFACTS_PATCH
        { ClkClientWin,         MODKEY|ShiftMask,    Button3,        dragcfact,      {0} },
        #endif // DRAGCFACT_PATCH
        #if DRAGMFACT_PATCH
        { ClkClientWin,         MODKEY|ShiftMask,    Button1,        dragmfact,      {0} },
        #endif // DRAGMFACT_PATCH
        { ClkTagBar,            0,                   Button1,        view,           {0} },
        { ClkTagBar,            0,                   Button3,        toggleview,     {0} },
        { ClkTagBar,            MODKEY,              Button1,        tag,            {0} },
        { ClkTagBar,            MODKEY,              Button3,        toggletag,      {0} },
        #if TAB_PATCH
        { ClkTabBar,            0,                   Button1,        focuswin,       {0} },
        #endif // TAB_PATCH
};
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if DWMC_PATCH
/* signal definitions */
/* signum must be greater than 0 */
/* trigger signals using `xsetroot -name "fsignal:<signame> [<type> <value>]"` */
static const Signal signals[] = {
        /* signum                    function */
        { "focusstack",              focusstack },
        { "setmfact",                setmfact },
        { "togglebar",               togglebar },
        #if TOGGLETOPBAR_PATCH
        { "toggletopbar",            toggletopbar },
        #endif // TOGGLETOPBAR_PATCH
        { "incnmaster",              incnmaster },
        { "togglefloating",          togglefloating },
        { "focusmon",                focusmon },
        #if STACKER_PATCH
        { "pushstack",               pushstack },
        #endif // STACKER_PATCH
        #if FLOATPOS_PATCH
        { "floatpos",                floatpos },
        #endif // FLOATPOS_PATCH
        #if FOCUSURGENT_PATCH
        { "focusurgent",             focusurgent },
        #endif // FOCUSURGENT_PATCH
        #if FOCUSADJACENTTAG_PATCH
        { "viewtoleft",              viewtoleft },
        { "viewtoright",             viewtoright },
        { "tagtoleft",               tagtoleft },
        { "tagtoright",              tagtoright},
        { "tagandviewtoleft",        tagandviewtoleft },
        { "tagandviewtoright",       tagandviewtoright },
        #endif // FOCUSADJACENTTAG_PATCH
        #if SWAPFOCUS_PATCH && PERTAG_PATCH
        { "swapfocus",               swapfocus },
        #endif // SWAPFOCUS_PATCH
        #if SWITCHCOL_PATCH
        { "switchcol",               switchcol },
        #endif // SWITCHCOL_PATCH
        #if ROTATESTACK_PATCH
        { "rotatestack",             rotatestack },
        #endif // ROTATESTACK_PATCH
        #if INPLACEROTATE_PATCH
        { "inplacerotate",           inplacerotate },
        #endif // INPLACEROTATE_PATCH
        #if PUSH_PATCH || PUSH_NO_MASTER_PATCH
        { "pushdown",                pushdown },
        { "pushup",                  pushup },
        #endif // PUSH_PATCH / PUSH_NO_MASTER_PATCH
        #if FLEXTILE_DELUXE_LAYOUT
        { "incnstack",               incnstack },
        { "rotatelayoutaxis",        rotatelayoutaxis },
        { "setlayoutaxisex",         setlayoutaxisex },
        { "mirrorlayout",            mirrorlayout },
        #endif // FLEXTILE_DELUXE_LAYOUT
        #if CFACTS_PATCH
        { "setcfact",                setcfact },
        #endif // CFACTS_PATCH
        #if MOVEPLACE_PATCH
        { "moveplace",               moveplace },
        #endif // MOVEPLACE_PATCH
        #if EXRESIZE_PATCH
        { "explace",                 explace },
        { "togglehorizontalexpand",  togglehorizontalexpand },
        { "toggleverticalexpand",    toggleverticalexpand },
        { "togglemaximize",          togglemaximize },
        #endif // EXRESIZE_PATCH
        #if KEYMODES_PATCH
        { "setkeymode",              setkeymode },
        #endif // KEYMODES_PATCH
        #if TRANSFER_PATCH
        { "transfer",                transfer },
        #endif // TRANSFER_PATCH
        #if TRANSFER_ALL_PATCH
        { "transferall",             transferall },
        #endif // TRANSFER_ALL_PATCH
        { "tagmon",                  tagmon },
        { "zoom",                    zoom },
        #if VANITYGAPS_PATCH
        { "incrgaps",                incrgaps },
        { "incrigaps",               incrigaps },
        { "incrogaps",               incrogaps },
        { "incrihgaps",              incrihgaps },
        { "incrivgaps",              incrivgaps },
        { "incrohgaps",              incrohgaps },
        { "incrovgaps",              incrovgaps },
        { "togglegaps",              togglegaps },
        { "defaultgaps",             defaultgaps },
        { "setgaps",                 setgapsex },
        #endif // VANITYGAPS_PATCH
        { "view",                    view },
        { "viewall",                 viewallex },
        { "viewex",                  viewex },
        { "toggleview",              toggleview },
        #if BAR_WINTITLEACTIONS_PATCH
        { "showhideclient",          showhideclient },
        #endif // BAR_WINTITLEACTIONS_PATCH
        #if SHIFTBOTH_PATCH
        { "shiftboth",               shiftboth },
        #endif // SHIFTBOTH_PATCH
        #if SHIFTTAG_PATCH
        { "shifttag",                shifttag },
        #endif // SHIFTTAG_PATCH
        #if SHIFTTAGCLIENTS_PATCH
        { "shifttagclients",         shifttagclients },
        #endif // SHIFTTAGCLIENTS_PATCH
        #if SHIFTVIEW_PATCH
        { "shiftview",               shiftview },
        #endif // SHIFTVIEW_PATCH
        #if SHIFTVIEW_CLIENTS_PATCH
        { "shiftviewclients",        shiftviewclients },
        #endif // SHIFTVIEW_CLIENTS_PATCH
        #if SHIFTSWAPTAGS_PATCH && SWAPTAGS_PATCH
        { "shiftswaptags",           shiftswaptags },
        #endif // SHIFTSWAPTAGS_PATCH
        #if SELFRESTART_PATCH
        { "self_restart",            self_restart },
        #endif // SELFRESTART_PATCH
        #if BAR_TAGGRID_PATCH
        { "switchtag",               switchtag },
        #endif // BAR_TAGGRID_PATCH
        #if STICKY_PATCH
        { "togglesticky",            togglesticky },
        #endif // STICKY_PATCH
        #if SETBORDERPX_PATCH
        { "setborderpx",             setborderpx },
        #endif // SETBORDERPX_PATCH
        #if CYCLELAYOUTS_PATCH
        { "cyclelayout",             cyclelayout },
        #endif // CYCLELAYOUTS_PATCH
        #if MPDCONTROL_PATCH
        { "mpdchange",               mpdchange },
        { "mpdcontrol",              mpdcontrol },
        #endif // MPDCONTROL_PATCH
        { "toggleviewex",            toggleviewex },
        { "tag",                     tag },
        { "tagall",                  tagallex },
        { "tagex",                   tagex },
        { "toggletag",               toggletag },
        { "toggletagex",             toggletagex },
        #if TAGALLMON_PATCH
        { "tagallmon",               tagallmon },
        #endif // TAGALLMON_PATCH
        #if TAGSWAPMON_PATCH
        { "tagswapmon",              tagswapmon},
        #endif // TAGSWAPMON_PATCH
        #if BAR_ALTERNATIVE_TAGS_PATCH
        { "togglealttag",            togglealttag },
        #endif // BAR_ALTERNATIVE_TAGS_PATCH
        #if TOGGLEFULLSCREEN_PATCH
        { "togglefullscreen",        togglefullscreen },
        #endif // TOGGLEFULLSCREEN_PATCH
        #if !FAKEFULLSCREEN_PATCH && FAKEFULLSCREEN_CLIENT_PATCH
        { "togglefakefullscreen",    togglefakefullscreen },
        #endif // FAKEFULLSCREEN_CLIENT_PATCH
        #if FULLSCREEN_PATCH
        { "fullscreen",              fullscreen },
        #endif // FULLSCREEN_PATCH
        #if MAXIMIZE_PATCH
        { "togglehorizontalmax",     togglehorizontalmax },
        { "toggleverticalmax",       toggleverticalmax },
        { "togglemax",               togglemax },
        #endif // MAXIMIZE_PATCH
        #if SCRATCHPADS_PATCH && !RENAMED_SCRATCHPADS_PATCH
        { "togglescratch",           togglescratch },
        #endif // SCRATCHPADS_PATCH
        #if UNFLOATVISIBLE_PATCH
        { "unfloatvisible",          unfloatvisible },
        #endif // UNFLOATVISIBLE_PATCH
        { "killclient",              killclient },
        #if WINVIEW_PATCH
        { "winview",                 winview },
        #endif // WINVIEW_PATCH
        #if XRDB_PATCH && !BAR_VTCOLORS_PATCH
        { "xrdb",                    xrdb },
        #endif // XRDB_PATCH
        #if TAGOTHERMONITOR_PATCH
        { "tagnextmonex",            tagnextmonex },
        { "tagprevmonex",            tagprevmonex },
        #endif // TAGOTHERMONITOR_PATCH
        { "quit",                    quit },
        { "setlayout",               setlayout },
        { "setlayoutex",             setlayoutex },
};
#elif FSIGNAL_PATCH
/* signal definitions */
/* signum must be greater than 0 */
/* trigger signals using `xsetroot -name "fsignal:<signum>"` */
static Signal signals[] = {
        /* signum       function        argument  */
        { 1,            setlayout,      {.v = 0} },
};
#endif // DWMC_PATCH
#+END_SRC

#+BEGIN_SRC c :tangle config.def.h
#if IPC_PATCH
static const char *ipcsockpath = "/tmp/dwm.sock";
static IPCCommand ipccommands[] = {
        IPCCOMMAND( focusmon, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( focusstack, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( incnmaster, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( killclient, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( quit, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( setlayoutsafe, 1, {ARG_TYPE_PTR} ),
        IPCCOMMAND( setmfact, 1, {ARG_TYPE_FLOAT} ),
        IPCCOMMAND( setstatus, 1, {ARG_TYPE_STR} ),
        IPCCOMMAND( tag, 1, {ARG_TYPE_UINT} ),
        IPCCOMMAND( tagmon, 1, {ARG_TYPE_UINT} ),
        IPCCOMMAND( togglebar, 1, {ARG_TYPE_NONE} ),
        #if TOGGLETOPBAR_PATCH
        IPCCOMMAND( toggletopbar, 1, {ARG_TYPE_NONE} ),
        #endif // TOGGLETOPBAR_PATCH
        IPCCOMMAND( togglefloating, 1, {ARG_TYPE_NONE} ),
        IPCCOMMAND( toggletag, 1, {ARG_TYPE_UINT} ),
        IPCCOMMAND( toggleview, 1, {ARG_TYPE_UINT} ),
        IPCCOMMAND( view, 1, {ARG_TYPE_UINT} ),
        IPCCOMMAND( zoom, 1, {ARG_TYPE_NONE} ),
        #if BAR_ALTERNATIVE_TAGS_PATCH
        IPCCOMMAND( togglealttag, 1, {ARG_TYPE_NONE} ),
        #endif // BAR_ALTERNATIVE_TAGS_PATCH
        #if BAR_TAGGRID_PATCH
        IPCCOMMAND( switchtag, 1, {ARG_TYPE_UINT} ),
        #endif // BAR_TAGGRID_PATCH
        #if CFACTS_PATCH
        IPCCOMMAND( setcfact, 1, {ARG_TYPE_FLOAT} ),
        #endif // CFACTS_PATCH
        #if CYCLELAYOUTS_PATCH
        IPCCOMMAND( cyclelayout, 1, {ARG_TYPE_SINT} ),
        #endif // CYCLELAYOUTS_PATCH
        #if EXRESIZE_PATCH
        IPCCOMMAND( explace, 1, {ARG_TYPE_UINT} ),
        IPCCOMMAND( togglehorizontalexpand, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( toggleverticalexpand, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( togglemaximize, 1, {ARG_TYPE_SINT} ),
        #endif // EXRESIZE_PATCH
        #if !FAKEFULLSCREEN_PATCH && FAKEFULLSCREEN_CLIENT_PATCH
        IPCCOMMAND( togglefakefullscreen, 1, {ARG_TYPE_NONE} ),
        #endif // FAKEFULLSCREEN_CLIENT_PATCH
        #if FLOATPOS_PATCH
        IPCCOMMAND( floatpos, 1, {ARG_TYPE_STR} ),
        #endif // FLOATPOS_PATCH
        #if FULLSCREEN_PATCH
        IPCCOMMAND( fullscreen, 1, {ARG_TYPE_NONE} ),
        #endif // FULLSCREEN_PATCH
        #if FLEXTILE_DELUXE_LAYOUT
        IPCCOMMAND( incnstack, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( rotatelayoutaxis, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( setlayoutaxisex, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( mirrorlayout, 1, {ARG_TYPE_NONE} ),
        #endif // FLEXTILE_DELUXE_LAYOUT
        #if FOCUSURGENT_PATCH
        IPCCOMMAND( focusurgent, 1, {ARG_TYPE_NONE} ),
        #endif // FOCUSURGENT_PATCH
        #if FOCUSADJACENTTAG_PATCH
        IPCCOMMAND( viewtoleft, 1, {ARG_TYPE_NONE} ),
        IPCCOMMAND( viewtoright, 1, {ARG_TYPE_NONE} ),
        IPCCOMMAND( tagtoleft, 1, {ARG_TYPE_NONE} ),
        IPCCOMMAND( tagtoright, 1, {ARG_TYPE_NONE} ),
        IPCCOMMAND( tagandviewtoleft, 1, {ARG_TYPE_NONE} ),
        IPCCOMMAND( tagandviewtoright, 1, {ARG_TYPE_NONE} ),
        #endif // FOCUSADJACENTTAG_PATCH
        #if INPLACEROTATE_PATCH
        IPCCOMMAND( inplacerotate, 1, {ARG_TYPE_SINT} ),
        #endif // INPLACEROTATE_PATCH
        #if KEYMODES_PATCH
        IPCCOMMAND( setkeymode, 1, {ARG_TYPE_UINT} ),
        #endif // KEYMODES_PATCH
        #if MAXIMIZE_PATCH
        IPCCOMMAND( togglehorizontalmax, 1, {ARG_TYPE_NONE} ),
        IPCCOMMAND( toggleverticalmax, 1, {ARG_TYPE_NONE} ),
        IPCCOMMAND( togglemax, 1, {ARG_TYPE_NONE} ),
        #endif // MAXIMIZE_PATCH
        #if MPDCONTROL_PATCH
        IPCCOMMAND( mpdchange, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( mpdcontrol, 1, {ARG_TYPE_NONE} ),
        #endif // MPDCONTROL_PATCH
        #if MOVEPLACE_PATCH
        IPCCOMMAND( moveplace, 1, {ARG_TYPE_UINT} ),
        #endif // MOVEPLACE_PATCH
        #if MOVERESIZE_PATCH
        IPCCOMMAND( moveresize, 1, {ARG_TYPE_STR} ),
        #endif // MOVERESIZE_PATCH
        #if NAMETAG_PATCH
        IPCCOMMAND( nametag, 1, {ARG_TYPE_NONE} ),
        #endif // NAMETAG_PATCH
        #if RIODRAW_PATCH
        IPCCOMMAND( rioresize, 1, {ARG_TYPE_NONE} ),
        #endif // RIODRAW_PATCH
        #if PUSH_PATCH || PUSH_NO_MASTER_PATCH
        IPCCOMMAND( pushdown, 1, {ARG_TYPE_NONE} ),
        IPCCOMMAND( pushup, 1, {ARG_TYPE_NONE} ),
        #endif // PUSH_PATCH / PUSH_NO_MASTER_PATCH
        #if ROTATESTACK_PATCH
        IPCCOMMAND( rotatestack, 1, {ARG_TYPE_SINT} ),
        #endif // ROTATESTACK_PATCH
        #if SCRATCHPADS_PATCH && !RENAMED_SCRATCHPADS_PATCH
        IPCCOMMAND( togglescratch, 1, {ARG_TYPE_UINT} ),
        #endif // SCRATCHPADS_PATCH
        #if SELFRESTART_PATCH
        IPCCOMMAND( self_restart, 1, {ARG_TYPE_NONE} ),
        #endif // SELFRESTART_PATCH
        #if SETBORDERPX_PATCH
        IPCCOMMAND( setborderpx, 1, {ARG_TYPE_SINT} ),
        #endif // SETBORDERPX_PATCH
        #if BAR_WINTITLEACTIONS_PATCH
        IPCCOMMAND( showhideclient, 1, {ARG_TYPE_NONE} ),
        #endif // BAR_WINTITLEACTIONS_PATCH
        #if SHIFTBOTH_PATCH
        IPCCOMMAND( shiftboth, 1, {ARG_TYPE_SINT} ),
        #endif // SHIFTBOTH_PATCH
        #if SHIFTTAG_PATCH
        IPCCOMMAND( shifttag, 1, {ARG_TYPE_SINT} ),
        #endif // SHIFTTAG_PATCH
        #if SHIFTTAGCLIENTS_PATCH
        IPCCOMMAND( shifttagclients, 1, {ARG_TYPE_SINT} ),
        #endif // SHIFTVIEWCLIENTS_PATCH
        #if SHIFTVIEW_PATCH
        IPCCOMMAND( shiftview, 1, {ARG_TYPE_SINT} ),
        #endif // SHIFTVIEW_PATCH
        #if SHIFTVIEW_CLIENTS_PATCH
        IPCCOMMAND( shiftviewclients, 1, {ARG_TYPE_SINT} ),
        #endif // SHIFTVIEW_CLIENTS_PATCH
        #if SHIFTSWAPTAGS_PATCH && SWAPTAGS_PATCH
        IPCCOMMAND( shiftswaptags, 1, {ARG_TYPE_SINT} ),
        #endif // SHIFTSWAPTAGS_PATCH
        #if STACKER_PATCH
        IPCCOMMAND( pushstack, 1, {ARG_TYPE_SINT} ),
        #endif // STACKER_PATCH
        #if STICKY_PATCH
        IPCCOMMAND( togglesticky, 1, {ARG_TYPE_NONE} ),
        #endif // STICKY_PATCH
        #if SWAPFOCUS_PATCH && PERTAG_PATCH
        IPCCOMMAND( swapfocus, 1, {ARG_TYPE_SINT} ),
        #endif // SWAPFOCUS_PATCH
        #if SWITCHCOL_PATCH
        IPCCOMMAND( switchcol, 1, {ARG_TYPE_NONE} ),
        #endif // SWITCHCOL_PATCH
        #if TAGALLMON_PATCH
        IPCCOMMAND( tagallmon, 1, {ARG_TYPE_SINT} ),
        #endif // TAGALLMON_PATCH
        #if TAGOTHERMONITOR_PATCH
        IPCCOMMAND( tagnextmonex, 1, {ARG_TYPE_UINT} ),
        IPCCOMMAND( tagprevmonex, 1, {ARG_TYPE_UINT} ),
        #endif // TAGOTHERMONITOR_PATCH
        #if TAGSWAPMON_PATCH
        IPCCOMMAND( tagswapmon, 1, {ARG_TYPE_SINT} ),
        #endif // TAGSWAPMON_PATCH
        #if TOGGLEFULLSCREEN_PATCH
        IPCCOMMAND( togglefullscreen, 1, {ARG_TYPE_NONE} ),
        #endif // TOGGLEFULLSCREEN_PATCH
        #if TRANSFER_PATCH
        IPCCOMMAND( transfer, 1, {ARG_TYPE_NONE} ),
        #endif // TRANSFER_PATCH
        #if TRANSFER_ALL_PATCH
        IPCCOMMAND( transferall, 1, {ARG_TYPE_NONE} ),
        #endif // TRANSFER_ALL_PATCH
        #if UNFLOATVISIBLE_PATCH
        IPCCOMMAND( unfloatvisible, 1, {ARG_TYPE_NONE} ),
        #endif // UNFLOATVISIBLE_PATCH
        #if VANITYGAPS_PATCH
        IPCCOMMAND( incrgaps, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( incrigaps, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( incrogaps, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( incrihgaps, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( incrivgaps, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( incrohgaps, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( incrovgaps, 1, {ARG_TYPE_SINT} ),
        IPCCOMMAND( togglegaps, 1, {ARG_TYPE_NONE} ),
        IPCCOMMAND( defaultgaps, 1, {ARG_TYPE_NONE} ),
        IPCCOMMAND( setgapsex, 1, {ARG_TYPE_SINT} ),
        #endif // VANITYGAPS_PATCH
        #if WINVIEW_PATCH
        IPCCOMMAND( winview, 1, {ARG_TYPE_NONE} ),
        #endif // WINVIEW_PATCH
        #if XRDB_PATCH && !BAR_VTCOLORS_PATCH
        IPCCOMMAND( xrdb, 1, {ARG_TYPE_NONE} ),
        #endif // XRDB_PATCH
};
#endif // IPC_PATCH
#+END_SRC

* Status Bar

** Polybar

To learn more about how to configure Polybar go to https://github.com/polybar/polybar

*** General

**** Colors

#+BEGIN_SRC conf :tangle polybar/config.ini
[colors]
dark-gray                 = ${xrdb:background:#282A36}
light-gray                = ${xrdb:color8:#4D4D4D}
lighter-gray              = ${xrdb:color7:#BFBFBF}
white                     = ${xrdb:foreground:#F8F8F2}
purple                    = ${xrdb:color4:#BD93F9}
blue                      = ${xrdb:color6:#8BE9FD}
red                       = ${xrdb:color1:#FF5555}
pink                      = ${xrdb:color5:#FF79C6}
yellow                    = ${xrdb:color3:#F1FA8C}
green                     = ${xrdb:color2:#50FA7B}
orange                    = ${xrdb:color16:#FFB86C}

background                = #CC282A36
background-alt            = ${self.light-gray}
foreground                = ${self.white}
foreground-alt            = ${self.lighter-gray}
primary                   = ${self.purple}
secondary                 = ${self.blue}
alert                     = ${self.red}

; left
powermenu-foreground      = ${self.blue}
powermenu-background      = ${self.background}
powermenu-underline       = ${self.background}
powermenu-overline        = ${self.background}

dwm-title-foreground      = ${self.foreground}
dwm-title-background      = ${self.background}
dwm-title-underline       = ${self.background}
dwm-title-overline        = ${self.background}

dwm-layout-foreground     = ${self.green}
dwm-layout-background     = ${self.foreground}
dwm-layout-underline      = ${self.background}
dwm-layout-overline       = ${self.background}

dwm-floating-foreground   = ${self.pink}
dwm-floating-background   = ${self.foreground}
dwm-floating-underline    = ${self.background}
dwm-floating-overline     = ${self.background}

dwm-focused-foreground    = ${self.purple}
dwm-focused-background    = ${self.background}
dwm-focused-underline     = ${self.background}
dwm-focused-overline      = ${self.background}

dwm-unfocused-foreground  = ${self.pink}
dwm-unfocused-background  = ${self.background}
dwm-unfocused-underline   = ${self.background}
dwm-unfocused-overline    = ${self.background}

dwm-visible-foreground    = ${self.yellow}
dwm-visible-background    = ${self.background}
dwm-visible-underline     = ${self.background}
dwm-visible-overline      = ${self.background}

dwm-urgent-foreground     = ${self.red}
dwm-urgent-background     = ${self.background}
dwm-urgent-underline      = ${self.background}
dwm-urgent-overline       = ${self.background}

dwm-empty-foreground      = ${self.light-gray}
dwm-empty-background      = ${self.background}
dwm-empty-underline       = ${self.background}
dwm-empty-overline        = ${self.background}

media-playing-foreground  = ${self.green}
media-playing-background  = ${self.background}
media-playing-underline   = ${self.background}
media-playing-overline    = ${self.background}

; center
tray-background           = ${self.background}

; right
kernel-foreground         = ${self.orange}
kernel-background         = ${self.background}
kernel-underline          = ${self.background}
kernel-overline           = ${self.background}

cpu-foreground            = ${self.purple}
cpu-background            = ${self.background}
cpu-underline             = ${self.background}
cpu-overline              = ${self.background}

memory-foreground         = ${self.blue}
memory-background         = ${self.background}
memory-underline          = ${self.background}
memory-overline           = ${self.background}

filesystem-foreground     = ${self.pink}
filesystem-background     = ${self.background}
filesystem-underline      = ${self.background}
filesystem-overline       = ${self.background}

date-foreground           = ${self.yellow}
date-background           = ${self.background}
date-underline            = ${self.background}
date-overline             = ${self.background}

time-foreground           = ${self.purple}
time-background           = ${self.background}
time-underline            = ${self.background}
time-overline             = ${self.background}

deadd-notification-center-foreground = ${self.green}
deadd-notification-center-background = ${self.background}
deadd-notification-center-underline  = ${self.background}
deadd-notification-center-overline   = ${self.background}

dunst-foreground = ${self.green}
dunst-background = ${self.background}
dunst-underline  = ${self.background}
dunst-overline   = ${self.background}

xfce4-notifyd-foreground = ${self.green}
xfce4-notifyd-background = ${self.background}
xfce4-notifyd-underline  = ${self.background}
xfce4-notifyd-overline   = ${self.background}

volume-foreground           = ${self.red}
volume-background           = ${self.background}
volume-underline            = ${self.background}
volume-overline             = ${self.background}
#+END_SRC

**** Sizes

#+BEGIN_SRC conf :tangle polybar/config.ini
[sizes]
bar-height          = ${xrdb:polybar.bar-height:25}
module-margin       = ${xrdb:polybar.module-margin:0}
module-padding      = ${xrdb:polybar.module-padding:0}
module-dwm-padding  = ${xrdb:polybar.module-dwm-padding:2}
tray-maxsize        = ${xrdb:polybar.tray-maxsize:25}
tray-scale          = ${xrdb:polybar.tray-scale:1}
maxlen              = ${xrdb:polybar.maxlen:50}
#+END_SRC

**** Intervals

Define module update intervals in seconds.

| Seconds | Minutes | Hours |
|---------+---------+-------|
|     600 |      10 |  0.17 |
|     900 |      15 |  0.25 |
|   86400 |    1440 |    24 |

#+BEGIN_SRC conf :tangle polybar/config.ini
[intervals]
media-playing = 1
kernel        = 86400
cpu           = 1
memory        = 1
filesystem    = 600
date          = 1
time          = 1
dunst         = 1
#+END_SRC

**** Global Window Manager

#+BEGIN_SRC conf :tangle polybar/config.ini
[global/wm]
; Adjust the _NET_WM_STRUT_PARTIAL top value
;   Used for top aligned bars
margin-bottom = 0

; Adjust the _NET_WM_STRUT_PARTIAL bottom value
;   Used for bottom aligned bars
margin-top = 0
#+END_SRC

*** Bars

#+BEGIN_SRC conf :tangle polybar/config.ini
[bar/mybar]
; Use either of the following command to list available outputs:
; If unspecified, the application will pick the first one it finds.
; $ polybar -m | cut -d ':' -f 1
; $ xrandr -q | grep " connected" | cut -d ' ' -f1
; If no monitor is given, the primary monitor is used if it exists
monitor = ${env:MONITOR}

; Use the specified monitor as a fallback if the main one is not found.
; monitor-fallback =

; Require the monitor to be in connected state
; XRandR sometimes reports my monitor as being disconnected (when in use)
monitor-strict = false

; Use fuzzy matching for monitors (only ignores dashes -)
; Useful when monitors are named differently with different drivers.
monitor-exact = true

; Tell the Window Manager not to configure the window.
; Use this to detach the bar if your WM is locking its size/position.
; Note: With this most WMs will no longer reserve space for
; the bar and it will overlap other windows. You need to configure
; your WM to add a gap where the bar will be placed.
override-redirect = false

; Put the bar at the bottom of the screen
bottom = false

; Prefer fixed center position for the `modules-center` block.
; The center block will stay in the middle of the bar whenever
; possible. It can still be pushed around if other blocks need
; more space.
; When false, the center block is centered in the space between
; the left and right block.
fixed-center = true

; Dimension defined as pixel value (e.g. 35) or percentage (e.g. 50%),
; the percentage can optionally be extended with a pixel offset like so:
; 50%:-10, this will result in a width or height of 50% minus 10 pixels
width = 100%
height = ${sizes.bar-height}

; Offset defined as pixel value (e.g. 35) or percentage (e.g. 50%)
; the percentage can optionally be extended with a pixel offset like so:
; 50%:-10, this will result in an offset in the x or y direction
; of 50% minus 10 pixels
offset-x = 0
offset-y = 0

; Background ARGB color (e.g. #f00, #ff992a, #ddff1023)
background = ${colors.background}

; Foreground ARGB color (e.g. #f00, #ff992a, #ddff1023)
foreground = ${colors.foreground}

; Background gradient (vertical steps)
;   background-[0-9]+ = #aarrggbb
; background-0 =

; Value used for drawing rounded corners
; Note: This shouldn't be used together with border-size because the border
; doesn't get rounded. For this to work you may also need to enable
; pseudo-transparency or use a compositor like compton.
; Individual top/bottom values can be defined using:
;   radius-{top,bottom}
radius = 10.0

; Under-/overline pixel size and argb color
; Individual values can be defined using:
;   {overline,underline}-size
;   {overline,underline}-color
overline-size  = 0
underline-size = 0

; Values applied to all borders
; Individual side values can be defined using:
;   border-{left,top,right,bottom}-size
;   border-{left,top,right,bottom}-color
; The top and bottom borders are added to the bar height, so the effective
; window height is:
;   height + border-top-size + border-bottom-size
; Meanwhile the effective window width is defined entirely by the width key and
; the border is placed within this area. So you effectively only have the
; following horizontal space on the bar:
;   width - border-right-size - border-left-size
; border-size can be defined as pixel value (e.g. 35) or percentage (e.g. 50%),
; the percentage can optionally be extended with a pixel offset like so:
; 50%:-10, this will result in 50% minus 10 pixels. The percentage is relative
; to the monitor width or height depending on the border direction.
; border-size =
; border-color =

; Number of spaces to add at the beginning/end of the bar
; Individual side values can be defined using:
;   padding-{left,right}
padding-left  = ${self.module-margin}
padding-right = ${self.module-margin}

; Number of spaces to add before/after each module
; Individual side values can be defined using:
;   module-margin-{left,right}
module-margin = ${sizes.module-margin}

; Fonts are defined using <font-name>;<vertical-offset>
; Font names are specified using a fontconfig pattern.
;   font-0 = NotoSans-Regular:size=8;2
;   font-1 = MaterialIcons:size=10
;   font-2 = Termsynu:size=8;-1
;   font-3 = FontAwesome:size=10
; See the Fonts wiki page for more details
font-0 = "Ubuntu Nerd Font:style=Medium:size=11;3"
font-1 = "MonaspiceNe NF:size=11;3"
font-2 = "DroidSansM Nerd Font:size=11;3"
font-3 = "IPAPGothic:size=11;3"
font-4 = "Baekmuk Dotum:size=11;3"
font-5 = "IPAPGothic:size=11;3"

; Modules are added to one of the available blocks
;   modules-left = cpu ram
;   modules-center = xwindow xbacklight
;   modules-right = ipc clock
modules-left   = powermenu-left powermenu powermenu-right dwm volume-left volume volume-right media-playing-left media-playing-change media-playing-prev media-playing-play-pause media-playing-next media-playing media-playing-right
; modules-center =
modules-right  = kernel-left kernel kernel-right cpu-left cpu cpu-right memory-left memory memory-right filesystem-left filesystem filesystem-right date-left date date-right time-left time time-right dunst-left dunst-status dunst-clear dunst-history-view dunst-history-clear dunst-history-length dunst-right

; The separator will be inserted between the output of each module
separator = ""

; This value is used to add extra spacing between elements
; @deprecated: This parameter will be removed in an upcoming version
; spacing = 0

; Opacity value between 0.0 and 1.0 used on fade in/out
dim-value = 1.0

; Value to be used to set the WM_NAME atom
; If the value is empty or undefined, the atom value
; will be created from the following template: polybar-[BAR]_[MONITOR]
; NOTE: The placeholders are not available for custom values
; wm-name =

; Locale used to localize various module data (e.g. date)
; Expects a valid libc locale, for example: sv_SE.UTF-8
locale = en_US.utf8

; Position of the system tray window
; If empty or undefined, tray support will be disabled
; NOTE: A center aligned tray will cover center aligned modules
;
; Available positions:
;   left
;   center
;   right
;   none
tray-position = ${env:TRAY_POS}

; If true, the bar will not shift its
; contents when the tray changes
tray-detached = false

; Tray icon max size
tray-maxsize = ${sizes.tray-maxsize}

; DEPRECATED! Since 3.3.0 the tray always uses pseudo-transparency
; Enable pseudo transparency
; Will automatically be enabled if a fully transparent
; background color is defined using `tray-background`
; tray-transparent = false

; Background color for the tray container
; ARGB color (e.g. #f00, #ff992a, #ddff1023)
; By default the tray container will use the bar
; background color.
tray-background = ${colors.tray-background}

; Tray offset defined as pixel value (e.g. 35) or percentage (e.g. 50%)
tray-offset-x = 0
tray-offset-y = 0

; Pad the sides of each tray icon
tray-padding = ${self.module-margin}

; Scale factor for tray clients
tray-scale = ${sizes.tray-scale}

; Restack the bar window. Fixes the issue where the
; bar is being drawn on top of fullscreen windows.
;
; Currently supported options:
;   generic (works in xmonad, may work with other WMs)
;   bspwm
;   i3 (requires: `override-redirect = true`)
; wm-restack = generic

; Set a DPI values used when rendering text
; This only affects scalable fonts
; Set this to 0 to let polybar calculate the dpi from the screen size.
; dpi =
dpi-x = ${xrdb:dpi}
dpi-y = ${xrdb:dpi}

; Enable support for inter-process messaging
; See the Messaging wiki page for more details.
enable-ipc = true

; Fallback click handlers that will be called if
; there's no matching module handler found.
; click-left =
; click-middle =
; click-right =
; scroll-up =
; scroll-down =
; double-click-left =
; double-click-middle =
; double-click-right =

; Requires polybar to be built with xcursor support (xcb-util-cursor)
; Possible values are:
; - default   : The default pointer as before, can also be an empty string (default)
; - pointer   : Typically in the form of a hand
; - ns-resize : Up and down arrows, can be used to indicate scrolling
cursor-click = pointer
cursor-scroll = ns-resize
#+END_SRC

*** Modules

**** Power Menu

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/powermenu-left]
type = custom/text
content = " "
content-foreground = ${colors.powermenu-background}
content-underline  = ${colors.powermenu-underline}
content-overline   = ${colors.powermenu-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/powermenu-right]
type = custom/text
content = " "
content-foreground = ${colors.powermenu-background}
content-underline  = ${colors.powermenu-underline}
content-overline   = ${colors.powermenu-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/powermenu]
type = custom/text
; content = " Menu"
content = ""
; content = ""

; "content" has the same properties as "format-NAME"
content-foreground = ${colors.powermenu-foreground}
content-background = ${colors.powermenu-background}
content-underline  = ${colors.powermenu-underline}
content-overline   = ${colors.powermenu-overline}
content-padding    = ${sizes.module-padding}

; "click-(left|middle|right)" will be executed using "/bin/sh -c $COMMAND"
; click-left = notify-send left
; click-middle = notify-send middle
; click-right = notify-send right
click-left  = "rofi -show combi"
click-right = "~/.scripts/control-center.sh --rofi"

; "scroll-(up|down)" will be executed using "/bin/sh -c $COMMAND"
; scroll-up = notify-send scroll up
; scroll-down = notify-send scroll down
#+END_SRC

**** DWM

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/dwm]
type = internal/dwm
; format = <label-tags> <label-layout> <label-floating> <label-title>
format = <label-tags>
; Path to dwm socket (default: /tmp/dwm.sock)
; socket-path = /tmp/dwm.sock

; Left-click to view tag, right-click to toggle tag view
enable-tags-click = true
; Scroll to cycle between available tags
enable-tags-scroll = true
; If true and enable-tags-scroll = true, scrolling will view all tags regardless if occupied
tags-scroll-empty = true
; If true and enable-tags-scroll = true, scrolling will cycle through tags backwards
tags-scroll-reverse = false
; If true and enable-tags-scroll = true, wrap active tag when scrolling
tags-scroll-wrap = true
; Left-click to set secondary layout, right-click to switch to previous layout
enable-layout-click = true
; Scroll to cycle between available layouts
enable-layout-scroll = false
; Wrap when scrolling and reaching beginning/end of layouts
layout-scroll-wrap = true
; Reverse scroll direction
layout-scroll-reverse = false

; If enable-layout-click = true, clicking the layout symbol will switch to this layout
secondary-layout-symbol = [M]

; Separator in between shown tags
; label-separator = |

; Title of currently focused window
; Available tokens:
;   %title%
label-title = %title%
label-title-foreground = ${colors.dwm-title-foreground}
label-title-background = ${colors.dwm-title-background}
label-title-underline  = ${colors.dwm-title-underline}
label-title-overline   = ${colors.dwm-title-overline}
label-title-maxlen     = ${sizes.maxlen}
label-title-padding    = ${sizes.module-dwm-padding}

; Symbol of current layout
; Available tokens:
;   %symbol%
label-layout = %symbol%
label-layout-foreground = ${colors.dwm-layout-foreground}
label-layout-background = ${colors.dwm-layout-background}
label-layout-underline  = ${colors.dwm-layout-underline}
label-layout-overline   = ${colors.dwm-layout-overline }
label-layout-padding    = ${sizes.module-dwm-padding}

; Text to show when currently focused window is floating
label-floating = "(F)"
label-floating-foreground = ${colors.dwm-floating-foreground}
label-floating-background = ${colors.dwm-floating-background}
label-floating-underline  = ${colors.dwm-floating-underline}
label-floating-overline   = ${colors.dwm-floating-overline}
label-floating-padding    = ${sizes.module-dwm-padding}

; States: focused, unfocused, visible, urgent, empty
; Available tokens:
;   %name%

; focused = Selected tag on focused monitor
label-focused = %name%
label-focused-foreground = ${colors.dwm-focused-foreground}
label-focused-background = ${colors.dwm-focused-background}
label-focused-underline  = ${colors.dwm-focused-underline}
label-focused-overline   = ${colors.dwm-focused-overline}
label-focused-padding    = ${sizes.module-dwm-padding}

; unfocused = Unselected tag on unselected monitor
label-unfocused = %name%
label-unfocused-foreground = ${colors.dwm-unfocused-foreground}
label-unfocused-background = ${colors.dwm-unfocused-background}
label-unfocused-underline  = ${colors.dwm-unfocused-underline}
label-unfocused-overline   = ${colors.dwm-unfocused-overline}
label-unfocused-padding    = ${sizes.module-dwm-padding}

; visible = Unselected tag, but occupied tag on any monitor
label-visible = %name%
label-visible-foreground = ${colors.dwm-visible-foreground}
label-visible-background = ${colors.dwm-visible-background}
label-visible-underline  = ${colors.dwm-visible-underline}
label-visible-overline   = ${colors.dwm-visible-overline}
label-visible-padding    = ${sizes.module-dwm-padding}

; urgent = Unselected tag with window that has urgency hint set
label-urgent = %name%
label-urgent-foreground = ${colors.dwm-urgent-foreground}
label-urgent-background = ${colors.dwm-urgent-background}
label-urgent-underline  = ${colors.dwm-urgent-underline}
label-urgent-overline   = ${colors.dwm-urgent-overline}
label-urgent-padding    = ${sizes.module-dwm-padding}

; empty = Unselected and unoccupied tag
; This can be set to an empty string to hide empty tags
label-empty = %name%
label-empty-foreground = ${colors.dwm-empty-foreground}
label-empty-background = ${colors.dwm-empty-background}
label-empty-underline  = ${colors.dwm-empty-underline}
label-empty-overline   = ${colors.dwm-empty-overline}
label-empty-padding    = ${sizes.module-dwm-padding}
#+END_SRC

**** Media Playing (Playerctl)

***** Module

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/media-playing-left]
type = custom/text
content = " "
content-foreground = ${colors.media-playing-background}
content-underline  = ${colors.media-playing-underline}
content-overline   = ${colors.media-playing-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/media-playing-right]
type = custom/text
content = " "
content-foreground = ${colors.media-playing-background}
content-underline  = ${colors.media-playing-underline}
content-overline   = ${colors.media-playing-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/media-playing]
type = custom/script
exec = ~/.config/dwm-flexipatch/polybar/scripts/scroll-media-playing.sh
tail = true
interval = ${intervals.media-playing}
format = <label>
label = %output%
label-foreground = ${colors.media-playing-foreground}
label-background = ${colors.media-playing-background}
label-underline  = ${colors.media-playing-underline}
label-overline   = ${colors.media-playing-overline}
label-maxlen     = ${sizes.maxlen}
label-padding    = 1
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/media-playing-change]
type = custom/script
exec = ~/.config/dwm-flexipatch/polybar/scripts/get-media-source-icon.sh
interval = ${intervals.media-playing}
format = <label>
label = %output%
label-foreground = ${colors.media-playing-foreground}
label-background = ${colors.media-playing-background}
label-underline  = ${colors.media-playing-underline}
label-overline   = ${colors.media-playing-overline}
label-maxlen     = ${sizes.maxlen}
label-padding    = 1
click-left = "~/.scripts/playerctl.sh --change"
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/media-playing-prev]
type = custom/text
content = ""
content-foreground = ${colors.media-playing-foreground}
content-background = ${colors.media-playing-background}
content-underline  = ${colors.media-playing-underline}
content-overline   = ${colors.media-playing-overline}
content-maxlen     = ${sizes.maxlen}
content-padding    = 1
click-left = "~/.scripts/playerctl.sh --prev"
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/media-playing-play-pause]
type = custom/script
exec = ~/.config/dwm-flexipatch/polybar/scripts/get-media-status-icon.sh
format = <label>
label = %output%
label-foreground = ${colors.media-playing-foreground}
label-background = ${colors.media-playing-background}
label-underline  = ${colors.media-playing-underline}
label-overline   = ${colors.media-playing-overline}
label-maxlen     = ${sizes.maxlen}
label-padding    = 1
click-left = "~/.scripts/playerctl.sh --play-pause"
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/media-playing-next]
type = custom/text
content = ""
content-foreground = ${colors.media-playing-foreground}
content-background = ${colors.media-playing-background}
content-underline  = ${colors.media-playing-underline}
content-overline   = ${colors.media-playing-overline}
content-maxlen     = ${sizes.maxlen}
content-padding    = 1
click-left = "~/.scripts/playerctl.sh --next"
#+END_SRC

***** Script

#+BEGIN_SRC shell :shebang #!/usr/bin/env bash :tangle polybar/scripts/get-media-source-icon.sh
mediaStatus=$(playerctl --player=playerctld metadata 2>&1)

if [[ "$mediaStatus" == "No player could handle this command" ]]; then
    echo ""
else
    trackid=$(playerctl --player=playerctld metadata --format '{{ mpris:trackid }}')
    title=$(playerctl --player=playerctld metadata --format '{{ xesam:title }}')

    if grep -q -i "netflix" <<< "$title"; then
        echo ""
    elif grep -q -i "hulu" <<< "$title"; then
        echo ""
    elif grep -q -i "prime video" <<< "$title"; then
        echo ""
    elif grep -q -i "youtube tv" <<< "$title"; then
        echo ""
    elif grep -q -i "chromium" <<< "$trackid"; then
        echo ""
    elif grep -q -i "vlc" <<< "$trackid"; then
        echo ""
    elif grep -q -i "spotify" <<< "$trackid"; then
        echo ""
    else
        echo ""
    fi
fi
#+END_SRC

#+BEGIN_SRC shell :shebang #!/usr/bin/env bash :tangle polybar/scripts/get-media-status-icon.sh
mediaStatus=$(~/.config/dwm-flexipatch/polybar/scripts/get-media-status.sh)

if [[ "$mediaStatus" == "N/A" ]]; then
    echo ""
else
    if [[ "$mediaStatus" == "Playing" ]]; then
        echo ""
    elif [[ "$mediaStatus" == "Paused" ]]; then
        echo ""
    fi
fi
#+END_SRC

#+BEGIN_SRC shell :shebang #!/usr/bin/env bash :tangle polybar/scripts/get-media-status.sh
mediaStatus=$(playerctl --player=playerctld metadata 2>&1)

if [[ "$mediaStatus" == "No player could handle this command" ]]; then
    echo "N/A"
else
    status=$(playerctl --player=playerctld metadata --format '{{ status }}')

    echo $status
fi
#+END_SRC

#+BEGIN_SRC shell :shebang #!/usr/bin/env bash :tangle polybar/scripts/get-media-playing.sh
mediaStatus=$(playerctl --player=playerctld metadata 2>&1)

if [[ "$mediaStatus" == "No player could handle this command" ]]; then
        echo "N/A"
else
        artist=$(playerctl --player=playerctld metadata --format '{{ artist }}')
        title=$(playerctl --player=playerctld metadata --format '{{ title }}')

        if [[ $artist == "" ]]; then
            artist="N/A"
        fi

        if [[ $title == "" ]]; then
            title="N/A"
        fi

        echo " $title |  $artist"
fi
#+END_SRC

#+BEGIN_SRC shell :shebang #!/usr/bin/env bash :tangle polybar/scripts/scroll-media-playing.sh
zscroll \
    --length $(xrdb -get polybar.maxlen) \
    --delay 0.2 \
    --scroll-padding " | " \
    --match-command "`dirname $0`/get-media-status.sh" \
    --match-text "Playing" "--scroll 1" \
    --match-text "Paused" "--scroll 0" \
    --update-check true "`dirname $0`/get-media-playing.sh" &

wait
#+END_SRC

**** Date

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/date-left]
type = custom/text
content = " "
content-foreground = ${colors.date-background}
content-underline  = ${colors.date-underline}
content-overline   = ${colors.date-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/date-right]
type = custom/text
content = " "
content-foreground = ${colors.date-background}
content-underline  = ${colors.date-underline}
content-overline   = ${colors.date-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/date]
type = internal/date

; Seconds to sleep between updates
; Default: 1.0
interval = ${intervals.date}

; See "https://en.cppreference.com/w/cpp/io/manip/put_time" for details on how to format the date string
; NOTE: if you want to use syntax tags here you need to use %%{...}
date = %a %D

; Optional time format
; time = %X

; if `date-alt` or `time-alt` is defined, clicking
; the module will toggle between formats
date-alt = %A, %B %d, %Y
; time-alt = %H:%M:%S

; Available tags:
;   <label> (default)
format = <label>

; Available tokens:
;   %date%
;   %time%
; Default: %date%
label = " %date%"
; label-font = 3
label-foreground = ${colors.date-foreground}
label-background = ${colors.date-background}
label-underline  = ${colors.date-underline}
label-overline   = ${colors.date-overline}
label-padding    = ${sizes.module-padding}
#+END_SRC

**** Time

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/time-left]
type = custom/text
content = " "
content-foreground = ${colors.time-background}
content-underline  = ${colors.time-underline}
content-overline   = ${colors.time-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/time-right]
type = custom/text
content = " "
content-foreground = ${colors.time-background}
content-underline  = ${colors.time-underline}
content-overline   = ${colors.time-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/time]
type = internal/date

; Seconds to sleep between updates
; Default: 1.0
interval = ${intervals.time}

; See "https://en.cppreference.com/w/cpp/io/manip/put_time" for details on how to format the date string
; NOTE: if you want to use syntax tags here you need to use %%{...}
; date = %a %x

; Optional time format
time = %X

; if `date-alt` or `time-alt` is defined, clicking
; the module will toggle between formats
; date-alt = %A, %B %d, %Y
time-alt = UTC%z (%Z)

; Available tags:
;   <label> (default)
format = <label>

; Available tokens:
;   %date%
;   %time%
; Default: %date%
label = " %time%"
; label-font = 3
label-foreground = ${colors.time-foreground}
label-background = ${colors.time-background}
label-underline  = ${colors.time-underline}
label-overline   = ${colors.time-overline}
label-padding    = ${sizes.module-padding}
#+END_SRC

**** Kernel

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/kernel-left]
type = custom/text
content = " "
content-foreground = ${colors.kernel-background}
content-underline  = ${colors.kernel-underline}
content-overline   = ${colors.kernel-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/kernel-right]
type = custom/text
content = " "
content-foreground = ${colors.kernel-background}
content-underline  = ${colors.kernel-underline}
content-overline   = ${colors.kernel-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/kernel]
type = custom/script

; Available tokens:
;   %counter%
; Command to be executed (using "/bin/sh -c [command]")
exec = echo " $(uname -r)"

; Conditional command that, if defined, needs to exit successfully
; before the main exec command is invoked.
; Default: ""
; exec-if = pgrep -x myservice

; Will the script output continous content?
; Default: false
tail = false

; Seconds to sleep between updates
; Default: 5 (0 if `tail = true`)
interval = ${intervals.kernel}

; Available tags:
;   <output> - deprecated
;   <label> (default)
format = %{A1:kitty bash -c "fastfetch && nvidia-smi && sleep 15":}<label>%{A}
format-foreground = ${colors.kernel-foreground}
format-background = ${colors.kernel-background}
format-underline  = ${colors.kernel-underline}
format-overline   = ${colors.kernel-overline}

; Available tokens:
;   %output%
; Default: %output%
label = %output%
label-padding    = ${sizes.module-padding}

; Available tokens:
;   %counter%
;   %pid%
;
; "click-(left|middle|right)" will be executed using "/bin/sh -c [command]"
; click-left = echo left %counter%
; click-middle = echo middle %counter%
; click-right = echo right %counter%
; double-click-left = echo double left %counter%
; double-click-middle = echo double middle %counter%
; double-click-right = echo double right %counter%

; Available tokens:
;   %counter%
;   %pid%
;
; "scroll-(up|down)" will be executed using "/bin/sh -c [command]"
; scroll-up = echo scroll up %counter%
; scroll-down = echo scroll down %counter%
#+END_SRC

**** CPU

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/cpu-left]
type = custom/text
content = " "
content-foreground = ${colors.cpu-background}
content-underline  = ${colors.cpu-underline}
content-overline   = ${colors.cpu-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/cpu-right]
type = custom/text
content = " "
content-foreground = ${colors.cpu-background}
content-underline  = ${colors.cpu-underline}
content-overline   = ${colors.cpu-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/cpu]
type = internal/cpu

; Seconds to sleep between updates
; Default: 1
interval = ${intervals.cpu}

; Available tags:
;   <label> (default)
;   <bar-load>
;   <ramp-load>
;   <ramp-coreload>
format = %{A1:kitty btop:}<label>%{A}

; Available tokens:
;   %percentage% (default) - total cpu load averaged over all cores
;   %percentage-sum% - Cumulative load on all cores
;   %percentage-cores% - load percentage for each core
;   %percentage-core[1-9]% - load percentage for specific core
label =  %percentage%%
label-padding    = ${sizes.module-padding}
label-foreground = ${colors.cpu-foreground}
label-background = ${colors.cpu-background}
label-underline  = ${colors.cpu-underline}
label-overline   = ${colors.cpu-overline}

; Spacing between individual per-core ramps
ramp-coreload-spacing = 1
ramp-coreload-0 = 
ramp-coreload-1 = 
ramp-coreload-2 = 
ramp-coreload-3 = 
ramp-coreload-4 = 
ramp-coreload-5 = 
ramp-coreload-6 = 
ramp-coreload-7 = 
ramp-coreload-foreground = ${colors.cpu}
#+END_SRC

**** Memory

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/memory-left]
type = custom/text
content = " "
content-foreground = ${colors.memory-background}
content-underline  = ${colors.memory-underline}
content-overline   = ${colors.memory-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/memory-right]
type = custom/text
content = " "
content-foreground = ${colors.memory-background}
content-underline  = ${colors.memory-underline}
content-overline   = ${colors.memory-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/memory]
type = internal/memory

; Seconds to sleep between updates
; Default: 1
interval = ${intervals.memory}

; Available tags:
;   <label> (default)
;   <bar-used>
;   <bar-free>
;   <ramp-used>
;   <ramp-free>
;   <bar-swap-used>
;   <bar-swap-free>
;   <ramp-swap-used>
;   <ramp-swap-free>
format = %{A1:kitty btop:}<label>%{A}

; Available tokens:
;   %percentage_used% (default)
;   %percentage_free%
;   %gb_used%
;   %gb_free%
;   %gb_total%
;   %mb_used%
;   %mb_free%
;   %mb_total%
;   %percentage_swap_used%
;   %percentage_swap_free%
;   %mb_swap_total%
;   %mb_swap_free%
;   %mb_swap_used%
;   %gb_swap_total%
;   %gb_swap_free%
;   %gb_swap_used%

label =   %percentage_used%%
label-padding    = ${sizes.module-padding}
label-foreground = ${colors.memory-foreground}
label-background = ${colors.memory-background}
label-underline  = ${colors.memory-underline}
label-overline   = ${colors.memory-overline}

; Only applies if <bar-used> is used
bar-used-indicator =
bar-used-width = 50
bar-used-foreground-0 = #55aa55
bar-used-foreground-1 = #557755
bar-used-foreground-2 = #f5a70a
bar-used-foreground-3 = #ff5555
bar-used-fill = 
bar-used-empty = 
bar-used-empty-foreground = #444444

; Only applies if <ramp-used> is used
ramp-used-0 = 
ramp-used-1 = 
ramp-used-2 = 
ramp-used-3 = 
ramp-used-4 = 
ramp-used-5 = 
ramp-used-6 = 
ramp-used-7 = 
ramp-used-foreground = ${colors.memory}

; Only applies if <ramp-free> is used
ramp-free-0 = 
ramp-free-1 = 
ramp-free-2 = 
ramp-free-3 = 
ramp-free-4 = 
ramp-free-5 = 
ramp-free-6 = 
ramp-free-7 = 
ramp-free-foreground = ${colors.memory}
#+END_SRC

**** Filesystem

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/filesystem-left]
type = custom/text
content = " "
content-foreground = ${colors.filesystem-background}
content-underline  = ${colors.filesystem-underline}
content-overline   = ${colors.filesystem-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/filesystem-right]
type = custom/text
content = " "
content-foreground = ${colors.filesystem-background}
content-underline  = ${colors.filesystem-underline}
content-overline   = ${colors.filesystem-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/filesystem]
type = internal/fs

; Mountpoints to display
mount-0 = /home

; Seconds to sleep between updates
; Default: 30
interval = ${intervals.filesystem}

; Display fixed precision values
; Default: false
fixed-values = true

; Spacing between entries
; Default: 2
spacing = ${sizes.module-margin}

; Available tags:
;   <label-mounted> (default)
;   <bar-free>
;   <bar-used>
;   <ramp-capacity>
format-mounted = %{A1:qdirstat &:}<label-mounted>%{A}

; Available tags:
;   <label-unmounted> (default)
format-unmounted = %{A1:gnome-disks &:} <label-unmounted> %{A}

; Available tokens:
;   %mountpoint%
;   %type%
;   %fsname%
;   %percentage_free%
;   %percentage_used%
;   %total%
;   %free%
;   %used%
; Default: %mountpoint% %percentage_free%%
label-mounted =  %percentage_used%%
label-mounted-foreground = ${colors.filesystem-foreground}
label-mounted-background = ${colors.filesystem-background}
label-mounted-underline  = ${colors.filesystem-underline}
label-mounted-overline   = ${colors.filesystem-overline}
label-mounted-padding    = ${sizes.module-padding}

; Available tokens:
;   %mountpoint%
; Default: %mountpoint% is not mounted
label-unmounted = %mountpoint% is not mounted
label-unmounted-foreground = ${colors.filesystem-foreground}
label-unmounted-background = ${colors.filesystem-background}
label-unmounted-underline  = ${colors.filesystem-underline}
label-unmounted-overline   = ${colors.filesystem-overline}
label-unmounted-padding    = ${sizes.module-padding}
#+END_SRC

**** Deadd Notification Center

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/deadd-notification-center-left]
type = custom/text
content = " "
content-foreground = ${colors.deadd-notification-center-background}
content-underline  = ${colors.deadd-notification-center-underline}
content-overline   = ${colors.deadd-notification-center-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/deadd-notification-center-right]
type = custom/text
content = " "
content-foreground = ${colors.deadd-notification-center-background}
content-underline  = ${colors.deadd-notification-center-underline}
content-overline   = ${colors.deadd-notification-center-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/deadd-notification-center]
type = custom/text
content = ""

; "content" has the same properties as "format-NAME"
; content-background = #000
content-foreground = ${colors.deadd-notification-center-foreground}
content-background = ${colors.deadd-notification-center-background}
content-underline  = ${colors.deadd-notification-center-underline}
content-overline   = ${colors.deadd-notification-center-overline}
content-padding    = ${sizes.module-padding}

; "click-(left|middle|right)" will be executed using "/bin/sh -c $COMMAND"
click-left = "~/.scripts/deadd.sh --toggle-center"
; click-middle = notify-send middle
click-right = "~/.scripts/deadd.sh --rofi"

; "scroll-(up|down)" will be executed using "/bin/sh -c $COMMAND"
; scroll-up = notify-send scroll up
; scroll-down = notify-send scroll down
#+END_SRC

**** Dunst

***** Module

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/dunst-left]
type = custom/text
content = " "
content-foreground = ${colors.dunst-background}
content-underline  = ${colors.dunst-underline}
content-overline   = ${colors.dunst-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/dunst-right]
type = custom/text
content = " "
content-foreground = ${colors.dunst-background}
content-underline  = ${colors.dunst-underline}
content-overline   = ${colors.dunst-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/dunst-status]
type = custom/script
exec = ~/.config/dwm-flexipatch/polybar/scripts/dunst-status.sh
interval = ${intervals.dunst}
format = <label>
label = %output%
label-foreground = ${colors.dunst-foreground}
label-background = ${colors.dunst-background}
label-underline  = ${colors.dunst-underline}
label-overline   = ${colors.dunst-overline}
label-padding    = ${sizes.module-padding}
click-left = "dunstctl set-paused toggle"
click-right = "~/.scripts/dunst.sh --rofi"
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/dunst-clear]
type = custom/text
content = ""
content-foreground = ${colors.dunst-foreground}
content-background = ${colors.dunst-background}
content-underline  = ${colors.dunst-underline}
content-overline   = ${colors.dunst-overline}
content-padding    = 1
click-left = "dunstctl close-all"
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/dunst-history-view]
type = custom/text
content = ""
content-foreground = ${colors.dunst-foreground}
content-background = ${colors.dunst-background}
content-underline  = ${colors.dunst-underline}
content-overline   = ${colors.dunst-overline}
content-padding    = 1
click-left = "~/.scripts/dunst.sh --history"
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/dunst-history-clear]
type = custom/text
content = ""
content-foreground = ${colors.dunst-foreground}
content-background = ${colors.dunst-background}
content-underline  = ${colors.dunst-underline}
content-overline   = ${colors.dunst-overline}
content-padding    = 1
click-left = "dunstctl history-clear"
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/dunst-history-length]
type = custom/script
exec = "dunstctl count history"
interval = ${intervals.dunst}
format = <label>
label = %output%
label-foreground = ${colors.dunst-foreground}
label-background = ${colors.dunst-background}
label-underline  = ${colors.dunst-underline}
label-overline   = ${colors.dunst-overline}
label-padding    = 1
#+END_SRC

***** Script

#+BEGIN_SRC shell :shebang #!/usr/bin/env bash :tangle polybar/scripts/dunst-status.sh
isPaused=$(dunstctl is-paused)

if [[ "$isPaused" == "true" ]]; then
    echo ""
else
    echo ""
fi
#+END_SRC

**** xfce4-notifyd

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/xfce4-notifyd-left]
type = custom/text
content = " "
content-foreground = ${colors.xfce4-notifyd-background}
content-underline  = ${colors.xfce4-notifyd-underline}
content-overline   = ${colors.xfce4-notifyd-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/xfce4-notifyd-right]
type = custom/text
content = " "
content-foreground = ${colors.xfce4-notifyd-background}
content-underline  = ${colors.xfce4-notifyd-underline}
content-overline   = ${colors.xfce4-notifyd-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/xfce4-notifyd]
type = custom/text
content = ""

; "content" has the same properties as "format-NAME"
; content-background = #000
content-foreground = ${colors.xfce4-notifyd-foreground}
content-background = ${colors.xfce4-notifyd-background}
content-underline  = ${colors.xfce4-notifyd-underline}
content-overline   = ${colors.xfce4-notifyd-overline}
content-padding    = ${sizes.module-padding}

; "click-(left|middle|right)" will be executed using "/bin/sh -c $COMMAND"
click-left = "~/.scripts/xfce4-notifyd.sh --toggle-center"
; click-middle = notify-send middle
click-right = "~/.scripts/xfce4-notifyd.sh --rofi"

; "scroll-(up|down)" will be executed using "/bin/sh -c $COMMAND"
; scroll-up = notify-send scroll up
; scroll-down = notify-send scroll down
#+END_SRC

**** Pulseaudio

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/volume-left]
type = custom/text
content = " "
content-foreground = ${colors.volume-background}
content-underline  = ${colors.volume-underline}
content-overline   = ${colors.volume-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/volume-right]
type = custom/text
content = " "
content-foreground = ${colors.volume-background}
content-underline  = ${colors.volume-underline}
content-overline   = ${colors.volume-overline}
content-padding    = ${sizes.module-padding}
#+END_SRC

#+BEGIN_SRC conf :tangle polybar/config.ini
[module/volume]
type = internal/pulseaudio

; Sink to be used, if it exists (find using `pacmd list-sinks`, name field)
; If not, uses default sink
; sink = alsa_output.pci-0000_12_00.3.analog-stereo

; Use PA_VOLUME_UI_MAX (~153%) if true, or PA_VOLUME_NORM (100%) if false
; Default: true
use-ui-max = true

; Interval for volume increase/decrease (in percent points)
; Default: 5
interval = 5

; Available tags:
;   <label-volume> (default)
;   <ramp-volume>
;   <bar-volume>
format-volume = <ramp-volume> <label-volume>
format-volume-padding    = ${sizes.module-padding}
format-volume-foreground = ${colors.volume-foreground}
format-volume-background = ${colors.volume-background}
format-volume-underline  = ${colors.volume-underline}
format-volume-overline   = ${colors.volume-overline}

; Available tags:
;   <label-muted> (default)
;   <ramp-volume>
;   <bar-volume>
format-muted = <label-muted>
format-muted-padding    = ${sizes.module-padding}
format-muted-foreground = ${colors.volume-foreground}
format-muted-background = ${colors.volume-background}
format-muted-underline  = ${colors.volume-underline}
format-muted-overline   = ${colors.volume-overline}

; Available tokens:
;   %percentage% (default)
;   %decibels%
;label-volume = %percentage%%

; Available tokens:
;   %percentage% (default)
;   %decibels%
label-muted =  muted

; Only applies if <ramp-volume> is used
ramp-volume-0 = 
ramp-volume-1 = 
ramp-volume-2 = 

; Right and Middle click
click-right = pavucontrol
; click-middle =
#+END_SRC

*** Launch Script

#+BEGIN_SRC shell :shebang #!/usr/bin/env bash :tangle polybar/launch.sh
BAR="mybar"
CONFIG="~/.config/dwm-flexipatch/polybar/config.ini"
NUM_MONITORS=0
CONNECTED_MONITORS=$(xrandr --query | grep " connected" | cut -d" " -f1)
TRAY_POS="center"

pkill polybar
while pgrep -u $UID -x polybar >/dev/null; do sleep 1; done

rm /tmp/polybar.pids
sleep 1

for m in $CONNECTED_MONITORS; do
    let "NUM_MONITORS+=1"
done

if [ $NUM_MONITORS == 1 ]; then
    # Launch on only monitor w/ systray
    MONITOR=$CONNECTED_MONITORS TRAY_POS=$TRAY_POS polybar --reload -c $CONFIG $BAR &
else
    PRIMARY=$(xrandr --query | grep " connected" | grep "primary" | cut -d" " -f1)
    OTHERS=$(xrandr --query | grep " connected" | grep -v "primary" | cut -d" " -f1)

    # Launch on primary monitor w/ systray
    MONITOR=$PRIMARY TRAY_POS=$TRAY_POS polybar --reload -c $CONFIG $BAR &
    sleep 1

    # Launch on all other monitors w/o systray
    for m in $OTHERS; do
        MONITOR=$m TRAY_POS=none polybar --reload -c $CONFIG $BAR &
    done
fi

echo "$!" >>/tmp/polybar.pids
#+END_SRC

* Justfile

#+BEGIN_SRC just :tangle justfile
set shell := ["bash", "-c"]

# List just commands by default
default:
    @just --list

# Update doom emacs and sync config
dwm-rebuild:
    sudo make clean install

# Run polybar launch script
dwm-launch-polybar:
    ./polybar/launch.sh
#+END_SRC
